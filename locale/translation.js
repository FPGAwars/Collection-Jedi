// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('Comb');
gettext('Const');
gettext('Perif');
gettext('Pines');
gettext('Templates');
gettext('Varios');
gettext('Varios-2');
gettext('Codificadores');
gettext('Decodificadores');
gettext('Demux');
gettext('Mux');
gettext('Puertas');
gettext('Tablas');
gettext('cod-2-1');
gettext('Codificador de 2 a 1. La salida zero se activa cuando ninguna entrada está activada');
gettext('cod-4-2-bus');
gettext('Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad. Entradas y salidas de buses');
gettext('cod-4-2');
gettext('Codificador de 4 a 2, con prioridad. La salida zero se activa cuando ninguna entrada está activad');
gettext('cod-5-3-bus');
gettext('Codificador de 5 a 3, con prioridad. La salida zero se activa cuando ninguna entrada está activada');
gettext('cod-8-3-bus');
gettext('Codificador de 8 a 3, con prioridad. La salida zero se activa cuando ninguna entrada está activada');
gettext('cod-8-3');
gettext('7Seg');
gettext('10bitBCD-3charASCII');
gettext('Decodificador de BCD a ASCII');
gettext('BCD-ASCII');
gettext('Circuito combinacional de 4 entradas y 8 salidas');
gettext('decod-1-2');
gettext('Decodificador de 1 a 2');
gettext('decod-2-4-bus');
gettext('Decodificador de 2 a 4, con salida en bus');
gettext('decod-2-4');
gettext('Decodificador de 2 a 4');
gettext('decod-3-5-inv-bus');
gettext('Decodificador de 3 a 5, lógica invertida, con salida en bus');
gettext('decod-3-6-inv-bus');
gettext('Decodificador de 3 a 6, lógica invertida, con salida en bus');
gettext('decod-3-8-bus');
gettext('Decodificador de 3 a 8, con salida en bus');
gettext('decod-3-8-flip');
gettext('Decodificador de 3 a 8');
gettext('decod-3-8');
gettext('Anodo-comun');
gettext('Catodo-comun');
gettext('displayBit');
gettext('DisplayBit. Decodificador de 1 bit a 7 segmentos. Ánodo común');
gettext('displayBit2');
gettext('DisplayBit2. Decodificador de 2 bits a 7 segmentos. Ánodo común');
gettext('displayBit3');
gettext('DisplayBit3. Decodificador de 3 bits a 7 segmentos. Ánodo común');
gettext('displayDEC');
gettext('DisplayDEC. Decodificador BCD a 7 segmentos. Ánodo común');
gettext('displayHEX');
gettext('DisplayHEX. Decodificador de binario a hexadecimal-7 segmentos. Ánodo común');
gettext('displayBit');
gettext('DisplayBit. Decodificador de 1 bit a 7 segmentos. Cátodo común');
gettext('displayBit2');
gettext('DisplayBit2. Decodificador de 2 bits a 7 segmentos. Cátodo común');
gettext('displayBit3');
gettext('DisplayBit3. Decodificador de 3 bits a 7 segmentos. Cátodo común');
gettext('displayDEC');
gettext('DisplayDEC. Decodificador BCD a 7 segmentos. Cátodo común');
gettext('displayHEX');
gettext('DisplayHEX. Decodificador de binario a hexadecimal-7 segmentos. Cátodo común');
gettext('08-bits');
gettext('1-Bit');
gettext('Demux-1-2');
gettext('Demultiplexor de 8 bit, de 1 a 2');
gettext('Demux-1-2');
gettext('Demultiplexor de 1 bit, de 1 a 2');
gettext('Demux-2-4');
gettext('Demultiplexor de 1 bit, de 2 a 4');
gettext('Demux-3-8-bus');
gettext('Demultiplexor de 1 bit, de 3 a 8 (salida de bus)');
gettext('09-Bits');
gettext('1-Bit');
gettext('10-bits');
gettext('14-bits');
gettext('16-bits');
gettext('2-Bits');
gettext('24-Bits');
gettext('3-Bits');
gettext('32-bits');
gettext('4-Bits');
gettext('5-Bits');
gettext('7-Bit');
gettext('8-Bit');
gettext('mux-2-1');
gettext('9 bits, 2-1 Multiplexor');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1');
gettext('Mux-2-1');
gettext('Mux-4-1-flip');
gettext('Multiplexor de 4 a 1. Implementado en verilog');
gettext('Mux-4-1');
gettext('Mux-8bus-1');
gettext('Multiplexor de 8 a 1, con entradas de bus');
gettext('mux-2-1');
gettext('10 bits, 2-1 Multiplexor');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 14 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 16 bits');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1 de 2 bits');
gettext('Mux-2-1');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 2 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 24 bits');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1 de 3 bits');
gettext('Mux-2-1');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 3 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 32 bits');
gettext('Mux-4-1');
gettext('Multiplexor de 4 a 1 de 32 bits');
gettext('Mux-8-1');
gettext('Multiplexor de 8 a 1 de 32 bits');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1 de 4 bits');
gettext('Mux-2-1');
gettext('Mux-4-1-bus');
gettext('Multiplexor de 4 a 1 de 4 bits');
gettext('Mux-4-1');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 5 bits');
gettext('Mux-2-1');
gettext('Multiplexor de 2 a 1 de 7 bits');
gettext('Mux-16-1');
gettext('Multiplexor de 16 a 1 de 8 bits');
gettext('Mux-2-1-flip');
gettext('Multiplexor de 2 a 1 de 8 bits');
gettext('Mux-2-1');
gettext('Mux-4-1-bus');
gettext('Multiplexor de 4 a 1 de 8 bits');
gettext('Mux-4-1');
gettext('Mux-8-1');
gettext('Multiplexor de 8 a 1 de 8 bits');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('05-bits');
gettext('06-bits');
gettext('07-bits');
gettext('08-bits');
gettext('and');
gettext('Puerta AND');
gettext('nand');
gettext('Puerta NAND');
gettext('nor');
gettext('Puerta NOR');
gettext('not');
gettext('Puerta NOT');
gettext('or');
gettext('Puerta OR');
gettext('or6');
gettext('Puerta OR de 6 entradas');
gettext('xnor');
gettext('Puerta XNOR');
gettext('xor');
gettext('Puerta XOR');
gettext('and-2-1');
gettext('Habilitación de bus de 2 bits');
gettext('and-2-1');
gettext('Puerta AND de 3 entradas');
gettext('and3');
gettext('or3');
gettext('Puerta OR de 3 entradas');
gettext('and-4-1');
gettext('Puerta AND de dos operandos, de 1 y 4 bits');
gettext('not');
gettext('Puerta NOT para bus de 4 bits');
gettext('or4');
gettext('Puerta OR de 4 entradas');
gettext('and-1-4');
gettext('Puerta AND de 2 entradas de 1 y 4 bits. Habilitar de bus de 4 bits');
gettext('not');
gettext('Puerta NOT para bus de 5 bits');
gettext('or5-bus');
gettext('Puerta OR de 5 entradas de bus');
gettext('or5');
gettext('Puerta OR de 5 entradas');
gettext('and-7-1');
gettext('Habilitación de bus de 7 bits');
gettext('and-7');
gettext('AND bit a bit entre dos buses de 7 bits');
gettext('and-8-1');
gettext('Habilitación de bus de 8 bits');
gettext('and-8');
gettext('AND bit a bit entre dos buses de 8 bits');
gettext('not');
gettext('Puerta NOT para bus de 8 bits');
gettext('or-8');
gettext('OR bit a bit entre dos buses de 8 bits');
gettext('xor-8');
gettext('XOR bit a bit entre dos buses de 8 bits');
gettext('tablas_bin');
gettext('tablas_hex');
gettext('1bit_entrada');
gettext('2bit_entrada');
gettext('3bit_entrada');
gettext('4bit_entrada');
gettext('5bit_entrada');
gettext('6bit_entrada');
gettext('7bit_entrada');
gettext('8bit_entrada');
gettext('tabla-bin-1-1');
gettext('Circuito combinacional de 1 entradas y 1 salidas');
gettext('tabla-bin-1-2');
gettext('Circuito combinacional de 1 entradas y 2 salidas');
gettext('tabla-bin-1-3');
gettext('Circuito combinacional de 1 entradas y 3 salidas');
gettext('tabla-bin-1-4');
gettext('Circuito combinacional de 1 entradas y 4 salidas');
gettext('tabla-bin-1-5');
gettext('Circuito combinacional de 1 entradas y 5 salidas');
gettext('tabla-bin-1-6');
gettext('Circuito combinacional de 1 entradas y 6 salidas');
gettext('tabla-bin-1-7');
gettext('Circuito combinacional de 1 entradas y 7 salidas');
gettext('tabla-bin-1-8');
gettext('Circuito combinacional de 1 entradas y 8 salidas');
gettext('tabla-bin-2-1');
gettext('Circuito combinacional de 2 entradas y 1 salidas');
gettext('tabla-bin-2-2');
gettext('Circuito combinacional de 2 entradas y 2 salidas');
gettext('tabla-bin-2-3');
gettext('Circuito combinacional de 2 entradas y 3 salidas');
gettext('tabla-bin-2-4');
gettext('Circuito combinacional de 2 entradas y 4 salidas');
gettext('tabla-bin-2-5');
gettext('Circuito combinacional de 2 entradas y 5 salidas');
gettext('tabla-bin-2-6');
gettext('Circuito combinacional de 2 entradas y 6 salidas');
gettext('tabla-bin-2-7');
gettext('Circuito combinacional de 2 entradas y 7 salidas');
gettext('tabla-bin-2-8');
gettext('Circuito combinacional de 2 entradas y 8 salidas');
gettext('tabla-bin-3-1');
gettext('Circuito combinacional de 3 entradas y 1 salidas');
gettext('tabla-bin-3-2');
gettext('Circuito combinacional de 3 entradas y 2 salidas');
gettext('tabla-bin-3-3');
gettext('Circuito combinacional de 3 entradas y 3 salidas');
gettext('tabla-bin-3-4');
gettext('Circuito combinacional de 3 entradas y 4 salidas');
gettext('tabla-bin-3-5');
gettext('Circuito combinacional de 3 entradas y 5 salidas');
gettext('tabla-bin-3-6');
gettext('Circuito combinacional de 3 entradas y 6 salidas');
gettext('tabla-bin-3-7');
gettext('Circuito combinacional de 3 entradas y 7 salidas');
gettext('tabla-bin-3-8');
gettext('Circuito combinacional de 3 entradas y 8 salidas');
gettext('tabla-bin-4-1');
gettext('Circuito combinacional de 4 entradas y 1 salidas');
gettext('tabla-bin-4-2');
gettext('Circuito combinacional de 4 entradas y 2 salidas');
gettext('tabla-bin-4-3');
gettext('Circuito combinacional de 4 entradas y 3 salidas');
gettext('tabla-bin-4-4');
gettext('Circuito combinacional de 4 entradas y 4 salidas');
gettext('tabla-bin-4-5');
gettext('Circuito combinacional de 4 entradas y 5 salidas');
gettext('tabla-bin-4-6');
gettext('Circuito combinacional de 4 entradas y 6 salidas');
gettext('tabla-bin-4-7');
gettext('Circuito combinacional de 4 entradas y 7 salidas');
gettext('tabla-bin-4-8');
gettext('tabla-bin-5-1');
gettext('Circuito combinacional de 5 entradas y 1 salidas');
gettext('tabla-bin-5-2');
gettext('Circuito combinacional de 5 entradas y 2 salidas');
gettext('tabla-bin-5-3');
gettext('Circuito combinacional de 5 entradas y 3 salidas');
gettext('tabla-bin-5-4');
gettext('Circuito combinacional de 5 entradas y 4 salidas');
gettext('tabla-bin-5-5');
gettext('Circuito combinacional de 5 entradas y 5 salidas');
gettext('tabla-bin-5-6');
gettext('Circuito combinacional de 5 entradas y 6 salidas');
gettext('tabla-bin-5-7');
gettext('Circuito combinacional de 5 entradas y 7 salidas');
gettext('tabla-bin-5-8');
gettext('Circuito combinacional de 5 entradas y 8 salidas');
gettext('tabla-bin-6-1');
gettext('Circuito combinacional de 6 entradas y 1 salidas');
gettext('tabla-bin-6-2');
gettext('Circuito combinacional de 6 entradas y 2 salidas');
gettext('tabla-bin-6-3');
gettext('Circuito combinacional de 6 entradas y 3 salidas');
gettext('tabla-bin-6-4');
gettext('Circuito combinacional de 6 entradas y 4 salidas');
gettext('tabla-bin-6-5');
gettext('Circuito combinacional de 6 entradas y 5 salidas');
gettext('tabla-bin-6-6');
gettext('Circuito combinacional de 6 entradas y 6 salidas');
gettext('tabla-bin-6-7');
gettext('Circuito combinacional de 6 entradas y 7 salidas');
gettext('tabla-bin-6-8');
gettext('Circuito combinacional de 6 entradas y 8 salidas');
gettext('tabla-bin-7-1');
gettext('Circuito combinacional de 7 entradas y 1 salidas');
gettext('tabla-bin-7-2');
gettext('Circuito combinacional de 7 entradas y 2 salidas');
gettext('tabla-bin-7-3');
gettext('Circuito combinacional de 7 entradas y 3 salidas');
gettext('tabla-bin-7-4');
gettext('Circuito combinacional de 7 entradas y 4 salidas');
gettext('tabla-bin-7-5');
gettext('Circuito combinacional de 7 entradas y 5 salidas');
gettext('tabla-bin-7-6');
gettext('Circuito combinacional de 7 entradas y 6 salidas');
gettext('tabla-bin-7-7');
gettext('Circuito combinacional de 7 entradas y 7 salidas');
gettext('tabla-bin-7-8');
gettext('Circuito combinacional de 7 entradas y 8 salidas');
gettext('tabla-bin-8-1');
gettext('Circuito combinacional de 8 entradas y 1 salidas');
gettext('tabla-bin-8-2');
gettext('Circuito combinacional de 8 entradas y 2 salidas');
gettext('tabla-bin-8-3');
gettext('Circuito combinacional de 8 entradas y 3 salidas');
gettext('tabla-bin-8-4');
gettext('Circuito combinacional de 8 entradas y 4 salidas');
gettext('tabla-bin-8-5');
gettext('Circuito combinacional de 8 entradas y 5 salidas');
gettext('tabla-bin-8-6');
gettext('Circuito combinacional de 8 entradas y 6 salidas');
gettext('tabla-bin-8-7');
gettext('Circuito combinacional de 8 entradas y 7 salidas');
gettext('tabla-bin-8-8');
gettext('Circuito combinacional de 8 entradas y 8 salidas');
gettext('1bit_entrada');
gettext('2bit_entrada');
gettext('3bit_entrada');
gettext('4bit_entrada');
gettext('5bit_entrada');
gettext('6bit_entrada');
gettext('7bit_entrada');
gettext('8bit_entrada');
gettext('tabla-hex-1-1');
gettext('tabla-hex-1-2');
gettext('tabla-hex-1-3');
gettext('tabla-hex-1-4');
gettext('tabla-hex-1-5');
gettext('tabla-hex-1-6');
gettext('tabla-hex-1-7');
gettext('tabla-hex-1-8');
gettext('tabla-hex-2-1');
gettext('tabla-hex-2-2');
gettext('tabla-hex-2-3');
gettext('tabla-hex-2-4');
gettext('tabla-hex-2-5');
gettext('tabla-hex-2-6');
gettext('tabla-hex-2-7');
gettext('tabla-hex-2-8');
gettext('tabla-hex-3-1');
gettext('tabla-hex-3-2');
gettext('tabla-hex-3-3');
gettext('tabla-hex-3-4');
gettext('tabla-hex-3-5');
gettext('tabla-hex-3-6');
gettext('tabla-hex-3-7');
gettext('tabla-hex-3-8');
gettext('tabla-hex-3-9');
gettext('Circuito combinacional de 3 entradas y 9 salidas');
gettext('tabla-hex-4-1');
gettext('tabla-hex-4-12');
gettext('Circuito combinacional de 4 entradas y 12 salidas');
gettext('tabla-hex-4-2');
gettext('tabla-hex-4-3');
gettext('tabla-hex-4-32');
gettext('Circuito combinacional de 4 entradas y 32 salidas');
gettext('tabla-hex-4-4');
gettext('tabla-hex-4-5');
gettext('tabla-hex-4-6');
gettext('tabla-hex-4-7');
gettext('tabla-hex-4-8');
gettext('tabla-hex-5-1');
gettext('tabla-hex-5-16');
gettext('Circuito combinacional de 5 entradas y 16 salidas');
gettext('tabla-hex-5-2');
gettext('tabla-hex-5-3');
gettext('tabla-hex-5-4');
gettext('tabla-hex-5-5');
gettext('tabla-hex-5-6');
gettext('tabla-hex-5-7');
gettext('tabla-hex-5-8');
gettext('tabla-hex-5-9');
gettext('Circuito combinacional de 5 entradas y 9 salidas');
gettext('tabla-hex-6-1');
gettext('tabla-hex-6-16');
gettext('Circuito combinacional de 6 entradas y 16 salidas');
gettext('tabla-hex-6-2');
gettext('tabla-hex-6-3');
gettext('tabla-hex-6-4');
gettext('tabla-hex-6-5');
gettext('tabla-hex-6-6');
gettext('tabla-hex-6-7');
gettext('tabla-hex-6-8');
gettext('tabla-hex-6-9');
gettext('Circuito combinacional de 6 entradas y 9 salidas');
gettext('tabla-hex-7-1');
gettext('tabla-hex-7-2');
gettext('tabla-hex-7-3');
gettext('tabla-hex-7-4');
gettext('tabla-hex-7-5');
gettext('tabla-hex-7-6');
gettext('tabla-hex-7-7');
gettext('tabla-hex-7-8');
gettext('tabla-hex-8-1');
gettext('tabla-hex-8-2');
gettext('tabla-hex-8-3');
gettext('tabla-hex-8-4');
gettext('tabla-hex-8-5');
gettext('tabla-hex-8-6');
gettext('tabla-hex-8-7');
gettext('tabla-hex-8-8');
gettext('7Seg');
gettext('Bits');
gettext('Bus');
gettext('Anodo_comun');
gettext('Catodo_comun');
gettext('Digitos');
gettext('Letras');
gettext('Digitos');
gettext('Letras');
gettext('0');
gettext('Constante de  7 bits para mostrar el dígito 0 en un display de 7 segmentos. Ánodo común');
gettext('Valor genérico constante, de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 0 | 0 | 0 | 0 | 1 |');
gettext('1');
gettext('Constante de  7 bits para mostrar el dígito 1 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 1 | 1 | 1 | 1 |');
gettext('2');
gettext('Constante de  7 bits para mostrar el dígito 2 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 1 | 0 | 0 | 1 | 0 |');
gettext('3');
gettext('Constante de  7 bits para mostrar el dígito 3 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 0 | 1 | 1 | 0 |');
gettext('4');
gettext('Constante de  7 bits para mostrar el dígito 4 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 1 | 1 | 0 | 0 |');
gettext('5');
gettext('Constante de  7 bits para mostrar el dígito 5 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 0 | 0 | 1 | 0 | 0 |');
gettext('6');
gettext('Constante de  7 bits para mostrar el dígito 6 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 0 | 0 | 0 | 0 | 0 |');
gettext('7');
gettext('Constante de  7 bits para mostrar el dígito 7 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 | 1 | 1 |');
gettext('8');
gettext('Constante de  7 bits para mostrar el dígito 8 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 |  0| 0 | 0 | 0 | 0 |');
gettext('9');
gettext('Constante de  7 bits para mostrar el dígito 9 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 |  0| 0 | 1 | 0 | 0 |');
gettext('A');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal A en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 |  0| 1 | 0 | 0 | 0 |');
gettext('B');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal B en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  0| 0 | 0 | 0 | 0 |');
gettext('C');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal C en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 0 | 0 | 0 | 1 |');
gettext('D');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal D en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 0 | 0 | 1 | 0 |');
gettext('E');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal E en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 0 | 0 | 0 | 0 |');
gettext('F');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal F en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 1 | 0 | 0 | 0 |');
gettext('G');
gettext('Constante de  7 bits para mostrar la letral G en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 0 | 0 | 1 | 0 | 0 |');
gettext('H');
gettext('Constante de  7 bits para mostrar la letra H en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 | 0 | 1 | 0 | 0 | 0 |');
gettext('I');
gettext('Constante de  7 bits para mostrar la letra I en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 | 1 | 1 | 0 | 0 | 1 |');
gettext('J');
gettext('Constante de  7 bits para mostrar la letra J en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 0 | 0 | 1 | 1 |');
gettext('L');
gettext('Constante de  7 bits para mostrar la letra L en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 0 | 0 | 0 | 1 |');
gettext('N');
gettext('Constante de  7 bits para mostrar la letra N en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 0 | 1 | 0 | 1 | 0 |');
gettext('NN');
gettext('Constante de  7 bits para mostrar la letra ñ en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 0 | 1 | 0 | 1 | 0 |');
gettext('O');
gettext('Constante de  7 bits para mostrar la letra O en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 0 | 0 | 0 | 1 |');
gettext('P');
gettext('Constante de  7 bits para mostrar la letra P en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 1 | 1 | 0 | 0 | 0 |');
gettext('Q');
gettext('Constante de  7 bits para mostrar la letra Q en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 | 0 | 0 |');
gettext('R');
gettext('Constante de  7 bits para mostrar la letra R en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 1 | 0 | 1 | 0 |');
gettext('S');
gettext('Constante de  7 bits para mostrar la letra S en un display de 7 segmentos. Ánodo común');
gettext('U');
gettext('Constante de  7 bits para mostrar la letra U en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 0 | 0 | 0 | 1 |');
gettext('Y');
gettext('Constante de  7 bits para mostrar la letra Y en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 0 | 1 | 0 | 0 |');
gettext('Digitos');
gettext('Letras');
gettext('0');
gettext('Constante de  7 bits para mostrar el dígito 0 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 1 | 1 | 0 |');
gettext('1');
gettext('Constante de  7 bits para mostrar el dígito 1 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 0 | 0 | 0 | 0 |');
gettext('2');
gettext('Constante de  7 bits para mostrar el dígito 2 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  0| 1 | 1 | 0 | 1 |');
gettext('3');
gettext('Constante de  7 bits para mostrar el dígito 3 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 0 | 0 | 1 |');
gettext('4');
gettext('Constante de  7 bits para mostrar el dígito 4 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 0 | 0 | 1 | 1 |');
gettext('5');
gettext('Constante de  7 bits para mostrar el dígito 5 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  1| 1 | 0 | 1 | 1 |');
gettext('6');
gettext('Constante de  7 bits para mostrar el dígito 6 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  1| 1 | 1 | 1 | 1 |');
gettext('7');
gettext('Constante de  7 bits para mostrar el dígito 7 en un display de 7 segmentos');
gettext('8');
gettext('Constante de  7 bits para mostrar el dígito 8 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 1 | 1 | 1 |');
gettext('9');
gettext('Constante de  7 bits para mostrar el dígito 9 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 0 | 1 | 1 |');
gettext('A');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal A en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 0 | 1 | 1 | 1 |');
gettext('B');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal B en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 |  1| 1 | 1 | 1 | 1 |');
gettext('C');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal C en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 1 | 1 | 1 | 0 |');
gettext('D');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal D en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 1 | 1 | 0 | 1 |');
gettext('E');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal E en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 1 | 1 | 1 | 1 |');
gettext('F');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal F en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 0 | 1 | 1 | 1 |');
gettext('G');
gettext('Constante de  7 bits para mostrar la letral G en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 | 1 | 1 | 0 | 1 | 1 |');
gettext('H');
gettext('Constante de  7 bits para mostrar la letra H en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 | 1 | 0 | 1 | 1 | 1 |');
gettext('I');
gettext('Constante de  7 bits para mostrar la letra I en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 0 | 0 | 1 | 1 | 0 |');
gettext('J');
gettext('Constante de  7 bits para mostrar la letra J en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 1 | 1 | 1 | 0 | 0 |');
gettext('L');
gettext('Constante de  7 bits para mostrar la letra L en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 | 1 | 0 |');
gettext('N');
gettext('Constante de  7 bits para mostrar la letra N en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 1 | 0 | 1 | 0 | 1 |');
gettext('NN');
gettext('Constante de  7 bits para mostrar la letra ñ en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 1 | 0 | 1 | 0 | 1 |');
gettext('O');
gettext('Constante de  7 bits para mostrar la letra O en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 1 | 1 | 1 | 0 |');
gettext('P');
gettext('Constante de  7 bits para mostrar la letra P en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 0 | 0 | 1 | 1 | 1 |');
gettext('Q');
gettext('Constante de  7 bits para mostrar la letra Q en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 0 | 0 | 1 | 1 |');
gettext('R');
gettext('Constante de  7 bits para mostrar la letra R en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 0 | 1 | 0 | 1 |');
gettext('S');
gettext('Constante de  7 bits para mostrar la letra S en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 1 | 1 | 0 | 1 | 1 |');
gettext('U');
gettext('Constante de  7 bits para mostrar la letra U en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 1 | 1 | 1 | 1 | 0 |');
gettext('Y');
gettext('Constante de  7 bits para mostrar la letra Y en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 1 | 1 | 0 | 1 | 1 |');
gettext('0');
gettext('1');
gettext('2');
gettext('3');
gettext('4');
gettext('5');
gettext('6');
gettext('7');
gettext('8');
gettext('9');
gettext('A');
gettext('B');
gettext('C');
gettext('D');
gettext('E');
gettext('F');
gettext('G');
gettext('H');
gettext('I');
gettext('J');
gettext('L');
gettext('N');
gettext('NN');
gettext('O');
gettext('P');
gettext('Q');
gettext('R');
gettext('S');
gettext('U');
gettext('Y');
gettext('0');
gettext('Un bit constante a 0');
gettext('1');
gettext('Un bit constante a 1');
gettext('01_bits');
gettext('02_bits');
gettext('03_bits');
gettext('04_bits');
gettext('05_bits');
gettext('06_bits');
gettext('07_bits');
gettext('08_bits');
gettext('09_bits');
gettext('10_bits');
gettext('14_bits');
gettext('16_bits');
gettext('32_bits');
gettext('Generico');
gettext('Valor genérico constante, de 1 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_0');
gettext('Valor constante 0 para bus de 2 bits');
gettext('Valor_1');
gettext('Valor constante 1 para bus de 2 bits');
gettext('Valor_2');
gettext('Valor constante 2 para bus de 2 bits');
gettext('Valor_3');
gettext('Valor constante 3 para bus de 2 bits');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_00');
gettext('Valor constante 0 para bus de 3 bits');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_00');
gettext('Valor constante 0 para bus de 4 bits');
gettext('Valor_05');
gettext('Valor constante 5 para bus de 4 bits');
gettext('Valor_10');
gettext('Valor constante 10 para bus de 4 bits');
gettext('Valor_15');
gettext('Valor constante 15 para bus de 4 bits');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_00');
gettext('Valor constante 0, de 6 bits');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('ASCII');
gettext('Generico');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_000');
gettext('Valor constante 0 para bus de 8 bits');
gettext('Valor_085');
gettext('Valor constante 85 (55h) para bus de 8 bits');
gettext('Valor_170');
gettext('Valor constante 170 (AAh) para bus de 8 bits');
gettext('Valor_255');
gettext('Valor constante 255 para bus de 8 bits');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Char-A');
gettext('Código ASCII del carácter A');
gettext('Char-J');
gettext('Código ASCII del carácter J');
gettext('Char-L');
gettext('Código ASCII del carácter L');
gettext('Char-LF');
gettext('Código ASCII del carácter LF');
gettext('Generico');
gettext('Valor genérico constante, de 9 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 10 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 10 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('k-div-2-1');
gettext('Operacion con constante de 10bits: k/2 -1');
gettext('Generico');
gettext('Valor genérico constante, de 14 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('k-1');
gettext('Valor genérico constante (menos 1), de 14 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 16 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Generico');
gettext('Valor genérico constante, de 32 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor_00');
gettext('Valor constante 0, de 32 bits');
gettext('DHTxx');
gettext('Displays');
gettext('DHT11_serial');
gettext('Muestra los datos que da el DHT11 por el puerto serie.');
gettext('Hace el checksum de 8 bits.');
gettext('Sumador de un dos operandos de 8 bits (sin acarreo)');
gettext('Comparador de dos operandos de 8 bits');
gettext('Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato');
gettext('8 bits flip-flop');
gettext('Retrasa 2 ciclos de reloj.');
gettext('DFF ini = 0');
gettext('Toma los datos del DHT22 y DHT11 (AM230x).');
gettext('00 = línea a 1; 01 = pone la línea a 0; 10 = esperar dos flancos de bajada del DHT; 11 = leer los 40 bits.');
gettext('Bloque inout, con conexión de pin por la derecha');
gettext('Separador de bus de 2-bits en dos cables');
gettext('Ha de transcurrir 18ms estando la línea baja.');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente');
gettext('Temporizador en microsegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Espera el flanco de bajada de la línea, luego de subida y después el de bajada de nuevo.');
gettext('Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente');
gettext('Contador módulo M, ascendente, de 2 bits, con reset ');
gettext('Detecta los bits que son 0 ó 1 y los va metiendo en un registro de desplazamiento. Cuando llega a los 40 bits los muestra por la salida.');
gettext('Registro de desplazamiento (izquierda) de 32 bits');
gettext('Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos');
gettext('Registro de 8 bits');
gettext('Separador de bus de 40-bits en 5 buses de 8 bits');
gettext('Contador módulo M, ascendente, de 6 bits, con reset ');
gettext('Detector de flancos de subida y bajada. Emite tic por las salidas correspondientes al detecta los flancos');
gettext('Filtro digital para eliminación de señales espúreas.');
gettext('Corazón de bombeo de tics a con periodo paramétrico de segundos');
gettext('Conversor de datos binarios a datos seriales para el DHT11.');
gettext('Transmisor serie');
gettext('Máquina de contar, de 4 bits');
gettext('Biestable de almacenamiento del estado de la máquina');
gettext('Registro de 4 bits con entrada de reset');
gettext('Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 4 bits');
gettext('Conversor binario a ASCII.');
gettext('Une dos bytes en una salida de 10 bits. (Se pierden 5 bits.)');
gettext('space = ascii(32)');
gettext('Código ASCII del carácter %');
gettext('Código ASCII del carácter H');
gettext('Convierte una entrada de 10 bits binaria a 3 bytes ASCII.');
gettext('Agregador de 2 buses de 4-bits a bus de 8-bits');
gettext('Sumador de un operando de 8 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Contador BDC');
gettext('En la entrada de 10 bits ponemos la cantidad de pulsos que emitir.');
gettext('Máquina de contar, de 10 bits. Se introduce en el paso máximo (si N pasos, el paso máximo es N-1)');
gettext('Registro de 10 bits con entrada de reset');
gettext('Sumador de un operando de 10 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 10 bits. Se compara si el operando es igual al parámetro');
gettext('Comparador de un operando de 10 bits. Se compara si el operando es igual al parámetro');
gettext('Conversor binario a ASCII de la temperatura.');
gettext('Código ASCII del carácter C');
gettext('**Info: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg/EABhMgGiDgAJ**');
gettext('Tiempo de muestreo siempre >= 2 segundos.');
gettext('Este pin se ha de conectar al pin 2 del DHT11.');
gettext('**Para comprobar si el dato es válido hemos de sumar: h1+h0+t1+t0, si el resultado\ncoincide con el valor de chk (checksum), entonces el dato es válido, de lo contrario\nsignificaría que ha habido un error.**');
gettext('Para cumplir con las **normas de diseño síncrono** hemos de poner\nregistros en las entradas y en las salidas cuando cuando existe\nlógica combinacional en medio, en este caso son las operaciones\nsumas e igualdad.');
gettext('***Retrasa la señal varios ciclos del reloj (CLK).***');
gettext('## Existen 4 ciclos:\n\n### Ciclo 0:\nNo hacer nada. Espera a que ocurra un tic del reloj de segundos (corazón).\n\n### Ciclo 1:\nConvertimos \"pin\" en salida y obliga a \"pin\" a ponerse a 0 [entre 18(min.) a 20 milisegundos (max.)]; sólo actuará como salida en este ciclo, en los demás ciclos siempre será de entrada (de escucha). Esta señal a 0 lo interpretará el DHTxx como señal de que ha de enviar los datos que tenga el sensor en ese momento.\n\n### Ciclo 2:\nPonemos \"pin\" en modo escucha (como entrada) y esperará leer dos flancos de bajada.\n\n### Ciclo 3:\nEn esta fase se interpreta las anchuras de pulsos recibidos como 0s y 1s, en total 40 bits. Una vez recopilados esos 40 bits se pondrán en paralelo para que otros circuitos dispongan de los datos extraídos.\n\nEl primer ciclo es provocado por un reloj que emite un pulso cada 2 (o más) segundos. Nunca ha de ser menor de 2 segundos.\n\nCada vez que termina un ciclo se emite un tic a un contador unido a un decoder, avisa al módulo correspondiente para que se ponga en marcha y cumpla su función específica. Pues cada vez que termina de realizar la función designada emitirá un tic para pasar al siguiente ciclo.');
gettext('# Driver DHTxx');
gettext('Pin I/O. Se ha de conectar al pin 2 del DHTxx');
gettext('Tiempo de muestreo');
gettext('Primero hace un tic de reset y luego un tic de poner en marcha los ciclos.');
gettext('### Etapa de demultiplexación:\n\nSegún el número que tenga el contador (fuera de este circuito) activará el ciclo correspondiente.');
gettext('Sólo en el ciclo 1 \"pin\" será una salida que pondrá a cero dicha salida.\nen los demás ciclos se pondrá como entrada.');
gettext('Cuando \"ena\" se pone a 1, comienza una temporización que ha de ser de entre 18ms y 20ms y la línea de datos estará a 0 (en otra parte del circuito se hace eso).\nTranscurrido ese tiempo la línea de datos pasará a 1.');
gettext('**Arranque del**  \n**temporizador**');
gettext('**Salida de pulso**');
gettext('**Salida de tic**');
gettext('**Parametro del timer**  \nmicroseundos a esperar');
gettext('\"Escucha\" la entrada de la línea y cuando\ndetecta que ha habido dos flancos\nde bajada significa que puede pasar\nal siguiente ciclo, que será leer la información\ndel DHT.');
gettext('0 = Disable.\n\n1 = Enable.');
gettext('**Parámetro**: Módulo del contador');
gettext('### Por la entrada \"rd\" entra un tipo de onda donde un periodo alto de 70us significa que es un 1 lógico y si dicho periodo alto fuese de 26us significaría que es un cero.\n\n### Debido a que tanto en los ciclos altos como bajos a veces contiene señales espúreas, hay que limpiar dicha señal y de ello se encarga un filtro digital. Dicho filtro modifica un poco los periodos de las señales (las enlonga ligeramente), entonces se han ampliado el periodo de las señales. Es por ello que toda señal que dure menos de 100us se considera un 0, de lo contrario un 1.\n\n### En cada flanco de bajada memoriza dicho bit, cocatenándolo en un registro de desplazamiento de 40bits.\n\n### Finalmente, cuando el contador cuenta 40 flancos de bajada es cuando los 40bits son memorizados y puestos a la salida. Debido al pequeño retraso del filtro hay que retardar un poco el tic de salida de la patilla \"end\" que avisa que se ha finalizado todo este proceso y ya se puede validar los datos. ');
gettext('# Filter');
gettext('# Periods ---> bits');
gettext('# Bits concatenation');
gettext('# Parallel data output');
gettext('## Detector doble: flancos de subida y bajada\n\nSe detectan tanto los flancos de subida como de bajada y se emite los  \ntics por sus salidas correspondientes');
gettext('Señal de  \nentrada');
gettext('Reloj del  \nsistema');
gettext('# Filtro digital para eliminar señales espúreas que se puedan producir mientras la señal está en \"alto\" o en \"bajo\" durante la comunicación de datos.');
gettext('# Los flip-flops puestos como registros de desplazamiento trocean la señal en el tiempo. Cada trocito de ese tiempo hemos de comprobar si en los 18 flip-flops todos esos trocitos son 1, o bien, si todos son 0. Sólo cuando todos los flip-flops sean 1 consideraremos que realmente la señal  es 1; y sólo cuando todos los flip-flops sean 0 consideraremos que realmente la señal es 0. La báscula RS se encarga de poner dicho 0 ó 1 a la salida.');
gettext('**Reloj del sistema**');
gettext('**Estado de**  \n**la máquina**');
gettext('Máquina encendida');
gettext('Máquina apagada  \n(rst = 1)');
gettext('Tic de arranque');
gettext('Tic de fin');
gettext('**Contador de ciclos**');
gettext('Número de ciclos  \ncontados');
gettext('Valor  \nincrementado');
gettext('### Salidas');
gettext('Estado de la máquina');
gettext('Ciclo actual');
gettext('Cuenta finalizada');
gettext('Ejecutar el ciclo');
gettext('Número de ciclos  \na contar');
gettext('¿Estamos en el  \nciclo k-1?');
gettext('Solo se hace caso a la  \nentrada next si la  \nmáquina está encendida');
gettext('Nuevo ciclo');
gettext('Si es el ciclo k-1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Apagar la  \nmáquina');
gettext('Ciclo nuevo:  \nincrementar la cuenta');
gettext('El tic de start se saca  \npor exec para que se ejecute  \nel primer ciclo');
gettext('Si la máquina está  \napagada, las señales  \nde ejecución no pueden  \nsalir!');
gettext('Retrasar la señal un ciclo  \nmientras que se detecta si  \nla máquina ha finalizado o no');
gettext('**Tic de apagado**');
gettext('**Tic de encendido**');
gettext('**Inicializar**');
gettext('**Estado de la máquina**');
gettext('Para el DHT11 los datos están en la entrada i1. En i0 siempre habrá ceros.\nPor esta razón se enrocan las entradas, para leer correctamente el\nvalor que queremos convertir en BCD.');
gettext('No se usa la centena, por eso aparece como un cable suelto.\nLa baja resolución de este integrado (y que sólo nos dará números enteros) sólo usa\nunidades y decenas.');
gettext('El DHT11 nos dará valores brutos donde por ejemplo, si en la entrada recibimos\nun 23, significa que eso mismo se ha de representar. Lo único que hay\nque hacer es convertir ese 23 binario a BCD y posteriormente a ASCII.');
gettext('**Conversor Binario a ASCII de 10 bits.**\n\nUn contador binario cuenta normal, pero esos mismos pulsos son compartidos por otro contador BCD. El resultado es convertir de binario a BCD.\nLo siguiente es convertir BCD a ASCII, para poder ser enviado por el puerto serie. Para ello lo único que hay que hacer es sumar 48 (es el número 0 en ASCII) a cada dígito BCD.\nEste método es lento, porque cuanto más pulsos más tiempo necesitará para la conversión, sin embargo es sencillo de comprender\ny si el tiempo de conversión no es un problema el resultado es igual de bueno que otros conversores.');
gettext('Contador BCD.');
gettext('Si hay N pasos, max = N - 1');
gettext('Para el DHT11 los datos están en la entrada i1. En i0 siempre habrá ceros.\nPor esta razón se enrocan las entradas, para leer correctamente el\nvalor que queremos convertir en BCD y luego a ASCII.');
gettext('El código ASCII de grado (º) es el 167, pero no sale\ncorrectamente cuando lo enviamos por el serial, entonces\nlo he sustituido por el asterisco (*) que es el 42.');
gettext('DHT22_MAX7912');
gettext('DHT22 se comunica con el MAX7912 y representa en el display la humedad y temperatura.');
gettext('Conversor de datos binarios procedentes del DHT22 a SPI para el MAX7912.');
gettext('Multiplexor de 8 a 1, de 16 bits.');
gettext('Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)');
gettext('Registro de 3 bits con entrada de reset');
gettext('Comparador de dos operandos de 3 bits');
gettext('Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Inicializa el MAX7212 a modo displays BCD.');
gettext('SPI Master de 16 bits mode=0');
gettext('Registro de desplazamiento (izquierda) de 8 bits');
gettext('Registro de 16 bits');
gettext('Sincronizar las entradas de datos con el reloj del sistema');
gettext('Señal de reloj de 16 pulsos, a 2MHZ / DIV (con divisor) ');
gettext('Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado');
gettext('Detector de flancos de subida y bajada. Emite tics por las salidas correspondientes al detecta los flancos. Versión bloques');
gettext('Temporizador en tics. La señal p está activa durante los tics indicados. ov se emite un tic al finalizar');
gettext('Sumador de un operando de 5 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Registro de 5 bits.');
gettext('Comparador de dos operandos de 5 bits');
gettext('Emite un solo tic al iniciarse la FPGA.');
gettext('Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Circuito combinacional de 4 entradas y 16 salidas');
gettext('Convierte una entrada de 10 bits binaria a 3 bytes BCD.');
gettext('En la entrada de 10 bits ponemos la cantidad de pulsos a emitir.');
gettext('Constante 0 BCD');
gettext('Constante BCD 8.');
gettext('Multiplexa 2 bytes');
gettext('Espacio vacío para el MAX7912.');
gettext('Cableado y configuración de datos y posición para el MAX7912.');
gettext('Agregador de 2 buses de 8-bits a bus de 16-bits');
gettext('Posición 1 del MAX7912.');
gettext('Posición 2 del MAX7912.');
gettext('Posición 3 del MAX7912.');
gettext('Posición 4 del MAX7912.');
gettext('Posición 5 del MAX7912.');
gettext('Posición 6 del MAX7912.');
gettext('Posición 7 del MAX7912.');
gettext('Posición 8 del MAX7912.');
gettext('**INFO: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg/8r91dFi_DgAJ**');
gettext('Este pin se ha de conectar al pin 2 del DHTxx.');
gettext('El circuito inicializa el MAX7912 para prepararlo como periférico para displays. Una vez que ha inicializado, por la patilla\n\"iniTic\" saldrá un tic para avisar de que ya puede aceptar datos como un SPI convencional, pero adaptado para el MAX7912.\nEsto significa que hasta que no tengamos un tic por la salida \"iniTic\" no se debe enviar datos.');
gettext('Tiempo mínimo para\nque el MAX7912 se\ninicialice antes\nde enviar datos.');
gettext('Número máximo +1 que\nhaya en la tabla CMD.');
gettext('Secuencia para configurar el MAX7912\ncomo displays de 8 dígitos. Por defecto\ntodo estará apagado.');
gettext('Maestro SPI de 16 bits en Modo 0.');
gettext('Con cada flanco se cambia  \nla salida del reloj');
gettext('Generador de la  \nonda cuadrada');
gettext('Máquina que genera una señal de  \nreloj de 2MHZ / DIV . Solo se emiten  \n8 pulsos con cada activación\n\n| DIV |  Frecuencia |\n|-----|-------------|\n| 1   |  2MHz       |\n| 2   |  1MHz       |\n| 4   |  500Khz     |\n| 8   |  250Khz     |\n| 16  |  125Khz     |\n');
gettext('Tic de flanco  \nde subida');
gettext('Tic de flanco  \nde bajada');
gettext('Retrasar done un periodo porque  \ncoincide con down');
gettext('Metemos un ciclo de  \nretraso para que arranque con  \nun ciclo más de retraso con  \nrespecto a la señal ss');
gettext('Retrasar busy para que cuadre  \ncon done');
gettext('Señal de entrada  \nactual');
gettext('Estado de la señal  \nen el instante anterior');
gettext('Si señal actual es 1  \nY la señal anterior  \nes 0, es que ha llegado  \nun flanco');
gettext('**Retraso**: 0  \nEl retraso es cero porque hay un  \ncamino de retraso 0 desde la entrada  \na cada una de las salidas');
gettext('Si la señal actual es 0  \npero la anterior era 1,  \nha llegado un flanco  \nde bajada');
gettext('**Divisor**');
gettext('Este circuito emite un solo \"tic\" después de transcurrir\n500ms de iniciarse la FPGA.');
gettext('**Parametro del timer**  \nmilisegundos a esperar');
gettext('Un contador binario cuenta normal, pero esos mismos pulsos son compartidos por otros contadores BCD (uno por cada dígito).\n\nUna vez que tenemos los dígitos BCD le añadimos otros 4bits. Si estos últimos 4 bits es cero, representa\nel número de forma normal. Y si esos últimos 4 bits es un 8 significa que además del número hay de encenderse\nel punto en ese display.');
gettext('**Convierte una cifra binaria en dígitos BCD de 8 bits cada uno, con formato especial para ser representado por el MAX7912.**');
gettext('En la entrada de 10 bits ponemos la cifra que queremos convertir en pulsos y al dar un tic al \"start\" comenzará a hacerlo. En la salida \"pls\" saldrá dichos pulsos en forma de tic. Una vez terminado saldrá un tic por \"done\".');
gettext('**En este módulo cableamos los datos y las posiciones para dejarlo\npreparado para el MAX7912.**');
gettext('DHT22_Serial');
gettext('Conversor de datos binarios a datos seriales para el DH22.');
gettext('Conversor binario a Humedad DHT.');
gettext('dot = ascii(46)');
gettext('Código ASCII del carácter guión');
gettext('**INFO: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg/X3NzhG4WDgAJ**');
gettext('Este pin se ha de conectar al pin 2 del DHT22.');
gettext('Tiempo de muestreo >= 2 segundos.');
gettext('**Conversor Binario a ASCII de 10 bits.**\n\nUn contador binario cuenta normal, pero esos mismos pulsos son compartidos por otro contador BCD. El resultado es convertir de binario a BCD.\nLo siguiente es convertir BCD a ASCII, para poder ser enviado por el puerto serie. Para ello lo único que hay que hacer es sumar 48 (es el número 0 en ASCII) a cada dígito BCD.\nEste método es lento, porque cuanto más pulsos más tiempo necesitará para la conversión, sin embargo es sencillo de comprender\ny si el tiempo de conversión no es un problema el resultado es igual de bueno que en otros conversores.');
gettext('DHTxx_Driver');
gettext('Info: https://groups.google.com/forum/#!topic/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg');
gettext('COM-1129-SparkFun');
gettext('MAX7912');
gettext('char-4');
gettext('Char_4++: Controlador para display SPI de 4 digitos, modelo COM-1129 de SparkFun. Puntos y control del Brillo');
gettext('SPI master. Realiza una transacción');
gettext('Señal de reloj de 8 pulsos, a 2MHZ / DIV (con divisor) ');
gettext('Agregador de 2 buses de 2 y 6-bits a bus de 8-bits');
gettext('### Controlador para display SPI de 4 dígitos 7 segmentos\n\nModelo: COM-1129-SPARKFUN\n\nCada vez que se recibe un tic por load se muestran los dígitos en el  \ndisplay');
gettext('**Máquina de contar**');
gettext('La máquina  \nejecuta 9 pasos');
gettext('Ejecutar paso i  \n(i = 0..8)');
gettext('Fin del paso i: hacer que  \nla máquina vaya al paso i+1');
gettext('**Multiplexor 16 a 1**');
gettext('Comando para borrar el display  \ny llevar el cursor a la posición  \noriginal');
gettext('Control de la señal SS:  \nAl cargar un nuevo valor se activa (0)  \nCuando se termina se desactiva  ');
gettext('Tic de visualización  \nCada vez que se recibe se  \nactualizan los dígitos');
gettext('Comando POINT');
gettext('Argumento  \ncomando POINT');
gettext('Comando BRIGHT');
gettext('Argumento  \ncomando BRIGHT');
gettext('**Temporizacion del SPI**');
gettext('**Registro de**   \ndesplazamiento');
gettext('Se generan 8 pulsos de  \nreloj, a 2MHZ / DIV');
gettext('**Dato recibido**');
gettext('Activar esclavo  \n(a nivel bajo)');
gettext('Captura del dato que  \nllega del esclavo');
gettext('En el modo 0 (CPOL=0, CPHA=0)  \nSe captura en flanco de subida');
gettext('Los datos se sacan por  \nMOSI en el flanco de  \nbajada');
gettext('En el tic de arranque  \nse carga el registro  \ncon los datos a enviar');
gettext('## SPI Maestro. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ / DIV\n\nBloque maestro de SPI');
gettext('Retrasar la señal done un ciclo  \npara sincronizarlo con data');
gettext('En el último pulso se  \ncaputra el dato, y se emite  \nel tic de done');
gettext('Sacar la señal de  \nreloj maestra');
gettext('Generación del Slave-select  \npor defecto: Al comenzar (start) se pone a 0 y  \nse vuelve a poner a al finalizar (done)');
gettext('digitos-4');
gettext('Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun');
gettext('Registro de 4 bits');
gettext('La máquina  \nejecuta 5 pasos');
gettext('Ejecutar paso i  \n(i = 0, 1, 2, 3 y 4)');
gettext('**Multiplexor 8 a 1**');
gettext('Poner a 0 los 4 bits  \nde mayor peso del digito');
gettext('Entradas  \nNO usadas');
gettext('digitos4++');
gettext('Digitos_4++: Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun. Puntos y control del Brillo');
gettext('segment-4');
gettext('Segment-4: Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun. Puntos y control del Brillo');
gettext('Registro de 7 bits');
gettext('Agregador de 1 cable y un bus de 7-bits a bus de 8-bits');
gettext('La máquina  \nejecuta 13 pasos');
gettext('Ejecutar paso i  \n(i = 0...12)');
gettext('Poner el bit de mayor  \npeso a 0');
gettext('time-4');
gettext('Time-4: Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun');
gettext('Inyectar el valor de un cable por el bit indicado de un bus');
gettext('La máquina  \nejecuta 7 pasos');
gettext('Los dos puntos se  \ninsertan en el bit 4');
gettext('Construir el argumento para el  \ncomando POINT: todos los bits  \na cero salvo el 4, que contiene  \nel estado de los dos puntos');
gettext('Argumento comando POINT');
gettext('MAX7912_driver');
gettext('Inicializa el MAX7212 a modo displays.');
gettext('El circuito inicializa el MAX7912 para prepararlo como periférico para displays. Una vez que ha inicializado, por la patilla\n\"iniTic\" saldrá un tic para avisar de que ya puede aceptar datos como un SPI convencional, pero adaptado para el MAX7912.\nEsto significa que hasta que no tengamos un tic por la salida \"iniTic\" no se debe enviar datos al SPI master.');
gettext('Secuencia para configurar el MAX7912\ncomo displays de 8 dígitos. Por defecto\nse encendrán todos los puntos de dichos\ndígitos.');
gettext('Maestro SPI de 16 bits Mode 0.');
gettext('Info: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/paT6PNjgmnE/60Ob5vREAAAJ');
gettext('SerialMAX7912');
gettext('Circuito combinacional de 3 entradas y 16 salidas');
gettext('Corazón de bombeo de tics a con periodo paramétrico de microsegundos');
gettext('Receptor UART de 16bits');
gettext('Receptor serie asíncrono. Velocidad por defecto: 115200 baudios');
gettext('El circuito inicializa el MAX7912 para prepararlo como periférico para displays. Una vez que ha inicializado, por la patilla\n\"iniTic\" saldrá un tic para avisar de que ya puede aceptar datos como un SPI convencional, pero adaptado al MAX7912.\nEsto significa que hasta que no tengamos un tic por la salida \"iniTic\" no se debe enviar datos al SPI master.');
gettext('Este circuito emite un solo \"tic\" al iniciarse la FPGA.');
gettext('Cuenta dos pulsos.');
gettext('Dos memorias tipo D (de 8 bits cada una) están puestas como registro de\ndesplazamiento. Cada vez que reciba un byte del puerto serie se memorizará\ny el contenido de la anterior pasa a la siguiente. Cada dos bytes recibidos\nformará una palabra de 16 bits.\n');
gettext('In-out-right');
gettext('In-out');
gettext('Bloque para entrada-salida (PIO)');
gettext('Comp');
gettext('Componente genérico');
gettext('Const');
gettext('Doc');
gettext('Bloque con documentación');
gettext('Documentación genérica');
gettext('ADC');
gettext('Accesorios');
gettext('Aritmetica');
gettext('Biestables');
gettext('Bombeo');
gettext('Bus');
gettext('Comparadores');
gettext('Contadores');
gettext('Flancos');
gettext('I2C');
gettext('IR');
gettext('Input');
gettext('LED');
gettext('Maquinas');
gettext('Motor');
gettext('PWM');
gettext('Particulas');
gettext('Pegatinas');
gettext('Prescaler');
gettext('Pulsador');
gettext('Registros');
gettext('Retardo');
gettext('SPI');
gettext('Serial');
gettext('Servos');
gettext('Sonido');
gettext('Syntax');
gettext('Timers');
gettext('VGA');
gettext('icebot');
gettext('memory');
gettext('01-bit');
gettext('Boot');
gettext('Bytes');
gettext('Dual');
gettext('Memory-16KB');
gettext('Memoria de 16KB. Lectura síncrona');
gettext('Memory-8KB');
gettext('Memoria de datos');
gettext('Memory-2x1-bits-parallel');
gettext('2x1 bits RAM memory with parallel output');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('## Synchronous 2x1-bit RAM (Parallel)\n\n* Both the read and write operation are  \n  synchronous\n* The memory has parallel output');
gettext('Address (0/1)');
gettext('Data input');
gettext('Write tic');
gettext('Depending on the address,  \nsend the tic write to the  \ncorresponding flip-flop');
gettext('Demux-2-1');
gettext('Flip-Flop 0');
gettext('Flip-Flop 1');
gettext('Flip-flops are loaded with  \nthe data input when the  \nwrite tic is received');
gettext('Read operation:  \nOutput the selected  \nflip-flop');
gettext('The read data will be available  \non the next cycle');
gettext('Paralell output');
gettext('Memory-2x1-bits');
gettext('2x1 bits RAM memory');
gettext('## Synchronous 2x1-bit RAM\n\n* Both the read and write operation are  \n  synchronous');
gettext('memory-16KB-boot');
gettext('Memoria de 16KB, con Bootloader');
gettext('Memoria dual de 16KB bytes');
gettext('Máquina de contar, de 14 bits, con entrada de stop');
gettext('Registro de 14 bits con entrada de reset');
gettext('Sumador de un operando de 14 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 14 bits. Se compara si el operando es igual al parámetro');
gettext('Máquina contadora de gestión del  \nBootloader. Al arrancar se pone a uno Boot_on  \ny por a1 sale 0, para acceder al primer byte  \nde la memoria a cargar');
gettext('## Entradas');
gettext('### Modo BOOTloader');
gettext('### Modo memoria normal');
gettext('## Salidas');
gettext('Dato a cargar en memoria, en Bootloader');
gettext('Tic de dato recibido, en bootloader');
gettext('Abortar el Bootloader. Se vuelve  \na modo normal');
gettext('Entrar en modo BOOTLOADER');
gettext('Estamos en modo BOOTLOADDER');
gettext('Dato leido de la memoria (Modo normal)');
gettext('Tic de Modo booloader finalizado  \n(Carga completada)');
gettext('Seleccionar canal 1 en  \nmodo Bootloader. De lo  \ncontrario seleccionar modo normal');
gettext('Los datos recibidos sólo se  \ndejan pasar si estamos en  \nel modo bootloader');
gettext('Escribir dato recibido en  \nla posicion actual de  \nla memoria');
gettext('Pasar a la siguiente  \ndirección');
gettext('Cuando se llega al final  \nboot_on se pone a 0 y  \nse envia un tic por done');
gettext('## ENTRADAS');
gettext('### MEMORIA 1');
gettext('### MEMORIA 0');
gettext('**Selección de memoria**');
gettext('Apagado automática,  \ncuando la máquina  \ntermina');
gettext('Apagado manual');
gettext('strings');
gettext('memory-128B');
gettext('128 bytes memory');
gettext('memory-16B');
gettext('16 bytes memory');
gettext('memory-256B');
gettext('256 bytes memory');
gettext('memory-2B');
gettext('Memoria de dos bytes');
gettext('memory-32B');
gettext('32 bytes memory');
gettext('memory-4B');
gettext('4 bytes memory');
gettext('memory-64B');
gettext('64 bytes memory');
gettext('memory-8B');
gettext('8 bytes memory');
gettext('memory-128B-str');
gettext('128-bytes memory, initilized with a string');
gettext('memory-16B-str');
gettext('16-bytes memory, initilized with a string');
gettext('memory-256B-str');
gettext('256-bytes memory, initilized with a string');
gettext('memory-2B-str');
gettext('2-bytes memory, initilized with a string');
gettext('memory-32B-str');
gettext('32-bytes memory, initilized with a string');
gettext('memory-4B-str');
gettext('4-bytes memory, initilized with a string');
gettext('memory-64B-str');
gettext('64-bytes memory, initilized with a string');
gettext('memory-8B-str');
gettext('8-bytes memory, initilized with a string');
gettext('memory-dual-16B');
gettext('Memoria dual de 8 bytes');
gettext('Memoria de 16 bytes');
gettext('memory-dual-16KB');
gettext('memory-dual-256B');
gettext('Memoria dual de 256 bytes');
gettext('Memoria de 256 bytes');
gettext('memory-dual-2x8B');
gettext('Memoria dual de dos bytes');
gettext('memory-dual-4B');
gettext('Memoria dual de 4 bytes');
gettext('Memoria de 4 bytes');
gettext('memory-dual-8B');
gettext('Memoria de 8 bytes');
gettext('adc');
gettext('Analog-to-digital-converter');
gettext('Circuito combinacional de 3 entradas y 18 salidas');
gettext('Contador módulo M, ascendente, de 3 bits, con reset ');
gettext('Controlador i2c que permite 3 transacciones: escritura, lectura y selección');
gettext('Tri-state logic block');
gettext('Generar la condición de start en el bus I2C');
gettext('Detección de los ACKs del esclavo. Si no se recibe, se activa la salida NAK');
gettext('Gestion de la entrada/salida en el bus i2c');
gettext('Contador módulo M, ascendente, de 8 bits, con reset ');
gettext('Generar una condición de parada en el bus i2c');
gettext('Inyectar un byte en el bus i2c');
gettext('Corazón  finito de tics. Emitir num tics cuando se recibe un tic de start');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en tics también');
gettext('Contador módulo M, ascendente, de 5 bits, con reset ');
gettext('Máquina para hacer repeticiones');
gettext('Comparador de igualdad, de un operando de 3 bits');
gettext('**SDA**\n(INOUT)  ');
gettext('Decoddificador');
gettext('Configuracion pin inout:  \n1: Salida  \n0: Entrada');
gettext('Señal para lectura  \n(W=1)');
gettext('Señal para escritura  \n(W=0)');
gettext('**I2C: Condicion de start**\n\nSDA y SCL están inicialmente en reposo (1). Al llegar un  \ntic por start, se genera la condición de start, que consiste  \nen poner SDA a 0 y trancurrido un tiempo T1, el reloj SCL  \ntambién se pone a 0');
gettext('**Estado de SDA**  \n(datos)   \nInicialmente a 1');
gettext('**Línea de datos**');
gettext('La señal SCL está  \nretrasada T1 con  \nrespecto a SDA');
gettext('Detectar cuando SDA  \nha bajado a 0');
gettext('**Estado de SCL** (Reloj)    \nInicialmente a 1');
gettext('Al activarse start, SDA  \nbaja a 0');
gettext('Volver al estado de  \nreposo (SDA=1, SCL=1)');
gettext('Emitir un tic para indicar  \nque la condición de estar  \nse ha ejecutado');
gettext('rs bit  \n(receive/send)  \n0: receive  \n1: send  ');
gettext('Receive-send bit');
gettext('ack window  \nThis output is 1 only  \nwhen the 9th bit is being  \nsent');
gettext('Generar una condición de Stop en el Bus I2C  \nCuando está en reposo, las entradas sda y scl atraviesan el  \nbloque sin modificación. Cuando se activa start, comienza la  \ngeneración de la condición de parada, y SCL se pone a 1.  \nTranscurrido un tiempo T2, SDA se pone a 1 también  \nSe señalliza en done que se ha completado');
gettext('Espera previa al stop');
gettext('121 tics son 10us');
gettext('Arrancar el módulo  \nde gestión del pin io');
gettext('CircuitScramble');
gettext('Baliza-1');
gettext('Baliza luminosa de 1 led. Parpadea a 2Hz cuando se activa');
gettext('Bombear 2 bits por segundo');
gettext('Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)');
gettext('**Baliza luminosa**\n\nParpadeo del LED a 2Hz');
gettext('Creado a partir de un **corazón  \ngenérico**, dando el valor adecuado  \na su parámetro frecuencia');
gettext('Baliza-2');
gettext('Baliza luminosa de 2 leds. Parpadean alternativamente a 2Hz cuando se activa');
gettext('**Baliza luminosa**\n\nParpadeo de los LEDs alternativamente a 2Hz, cuando están habilitados ');
gettext('Beep-kbd');
gettext('Emitir un pitido corto (20ms) de sonido de tecla pulsada');
gettext('Beep');
gettext('Emitir un pitido de duración (ms) y frecuencia (hz) indicada en los parámetros, al recibir un tic');
gettext('Init-tic-32');
gettext('Emitir un tic inicial al arrancar, y nunca más. Se esperan 32 tics antes de emitir el tic de inicialización');
gettext('Separador de bus de 6-bits en 1 bit y bus de 5 bits');
gettext('Contador del sistema, ascendente, de 6 bits, con enable ');
gettext('Init-tic');
gettext('Emitir un tic inicial al arrancar, y nunca más');
gettext('KITT');
gettext('Secuencia del coche fantástico, con entrada de enable');
gettext('Corazón de bombeo de tics con periodo paramétrico de milisegundos y entrada de enable');
gettext('Contador módulo M, ascendente, de 4 bits, con reset ');
gettext('Sirena');
gettext('Cuando se activa su entrada (por nivel) suena la sirena');
gettext('Bombear 1000 bits por segundo');
gettext('Bombear 4 bits por segundo');
gettext('Bombear 2000 bits por segundo');
gettext('**Sirena acústica**\n\nSe alternan pitidos de 1Khz y 2Khz a la frecuencia de 4Hz');
gettext('Cuando esta señal se pone a 1  \nempieza a sonar la sirena');
gettext('Conectar la salida  \ndirectamente a un  \nzumbador');
gettext('beep-flash');
gettext('Emitir un flash en el LED y un pitido en el zumbador al recibir el tic');
gettext('Emitir un pulso de anchura determinada para encender un LED durante un tiempo. 50ms por defecto');
gettext('comecocos');
gettext('Bloque de prueba para explicar conceptos. No hace nada');
gettext('Bloque de documentación, para explicar los  \nconceptos de puertos, parámeros, pines, cables  \ny buses en el tutorial 21');
gettext('flash');
gettext('Button-off');
gettext('Pulsador de cambio con icono de Circuit Scramble. Cada vez que se aprieta cambia de estado');
gettext('Valor inicial del pulsador\n');
gettext('and');
gettext('Bin2BCD');
gettext('CRC');
gettext('Shifts');
gettext('Sumadores');
gettext('04-bits');
gettext('parts');
gettext('Bin2BCD-comb');
gettext('Conversor de binario a BCD, para números de 4 bits');
gettext('Cálculo combinacional parcial para la conversion de Binario a BCD');
gettext('Comparador menor que, de un operando de 4 bits');
gettext('Separador de bus de 4-bits en 4 cables');
gettext('Desplazamiento combincional de 1 bit hacia la izquierda (x2)');
gettext('Agregador de 4 cables en un bus de 4-bits');
gettext('Esta céluca combinacional realiza una parte del cálculo del  \nalgoritmo para convertir de **binario a BCD**:\n\nSi la entrada a es mayor o igual a 5, se devuelve a+5,  \nde lo contrario se devuelve a (se deja como estaba)');
gettext('¿Es a >= 5?');
gettext('**Si**  \na es >= que 5');
gettext('Calcular a+3');
gettext('**No**  \na NO es >= 5');
gettext('Desplazamiento combinacional  \nde un bit hacia la derecha  \n(Multiplicación x2)');
gettext('Bin2BCD-seq');
gettext('Máuina de conversion Binario - BCD de 4 bits');
gettext('Registro de desplazamiento (izquierda) de 4 bits');
gettext('Registro de 2 bits con reset');
gettext('Sumador de un operando de 2 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 2 bits');
gettext('**Reloj**');
gettext('**Número a convertir**');
gettext('**Arranque**');
gettext('Estado de la  \nmáquina');
gettext('Dígito 0');
gettext('Dígito 1');
gettext('**Máquina de contar**  \nLa conversión se realiza en  \n4 iteraciones');
gettext('Cargar el numero a convertir  \nen el arranque de la máquina');
gettext('Actualizar registro  \nen cada etapa');
gettext('**Calculos para el digito 0**');
gettext('**Calculos para el digito 1**');
gettext('comb-unit');
gettext('CRC-16-CCITT');
gettext('Calculo del CRC-16-CCITT de un mensaje serie');
gettext('Agregador de buses de 3 y 1-bits a a bus de 4-bits');
gettext('Agregador de 4 buses en un bus de 16-bits');
gettext('Registro de desplazamiento (izquierda) de 4 bits con reset');
gettext('Registro de desplazamiento (izquierda) de 3 bits');
gettext('**1**');
gettext('Bit 0');
gettext('Bit 3');
gettext('Bit 4');
gettext('Bit 5');
gettext('**X^5**');
gettext('Bit 7');
gettext('Bit 8');
gettext('Bit 11');
gettext('Bit 12');
gettext('**X^12**');
gettext('Bit 15');
gettext('**X^16**');
gettext('Mensaje de entrada');
gettext('Polinomio Generador:\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/png/bd8dba2898cd0de4ef69e454d9c8f45efdfcedb2)');
gettext('### Calculo del CRC-16-CCITT\n\nEl mensaje entra bit a bit, en serie por msg  \nPor cada bit nuevo que llega entra un tic por shift  ');
gettext('**Resultado**  \n(parcial)');
gettext('01-bits');
gettext('Shift-left');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('05-bits');
gettext('06-bits');
gettext('07-bits');
gettext('08-bits');
gettext('09-bits');
gettext('10-bits');
gettext('14-bits');
gettext('16-bits');
gettext('sum-1op');
gettext('sum-2op');
gettext('Sumador  de 3 bits (sin acarreo)');
gettext('sum-1op');
gettext('sum-2op');
gettext('sum-1op');
gettext('sum-2op');
gettext('Sumador  de 4 bits (sin acarreo)');
gettext('sum-1op');
gettext('5-bits adder. One operand is a constant (no carry)');
gettext('sum-2op');
gettext('Sumador  de 5 bits (sin acarreo)');
gettext('sum-1op');
gettext('6-bits adder. One operand is a constant (no carry)');
gettext('sum-2op-carry');
gettext('Sumador  de 6 bits (sin acarreo)');
gettext('sum-2op');
gettext('sum-1op');
gettext('7-bits adder. One operand is a constant (no carry)');
gettext('sum-2op-carry');
gettext('Sumador  de 7 bits, con acarreo');
gettext('sum-2op');
gettext('Sumador  de 7 bits (sin acarreo)');
gettext('sum-1op');
gettext('sum-2op-carry');
gettext('Sumador  de 8 bits, con acarreo');
gettext('sum-2op');
gettext('sum-1op');
gettext('Sumador de un operando de 9 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('sum-2op');
gettext('Sumador  de 9 bits (sin acarreo)');
gettext('sum-1op');
gettext('sum-1op');
gettext('sum-2op');
gettext('Sumador de dos operandos de 14 bits');
gettext('sum-1op');
gettext('Sumador de un operando de 16 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('sum-2op');
gettext('Sumador de dos operandos de 16 bits');
gettext('D-Flip-flops');
gettext('T-Flip-flops');
gettext('system');
gettext('Cambio-rst');
gettext('Biestable de cambio (Tipo T) con reset. Cuando se recibe un tic cambia de estado');
gettext('Cambio');
gettext('Dato');
gettext('Set-Reset');
gettext('D-rst-load');
gettext('T');
gettext('T-Flip-Flop with reset. It toggles when the T input is 1');
gettext('Dato');
gettext('Datox2');
gettext('Dos Biestables de datos (Tipo D) encadenados');
gettext('Fijos');
gettext('Tics');
gettext('Corazon_Hz');
gettext('Corazon_Seg');
gettext('Bombear 1 bit con el periodo especificado en el parámetro. Por defecto el periodo es de 1 segundos');
gettext('Corazon_ms');
gettext('Bombear 1 bit con el periodo especificado en el parámetro (en ms). Por defecto el periodo es de 100 ms');
gettext('Corazon_10Hz');
gettext('Bombear 10 bits por segundo');
gettext('Corazon_1Hz');
gettext('Bombear 1 bit por segundo');
gettext('Corazon_1KHz');
gettext('Corazon_2Hz');
gettext('Corazon_2KHz');
gettext('Corazon_3Hz');
gettext('Bombear 3 bits por segundo');
gettext('Corazon_4Hz');
gettext('Corazon_5Hz');
gettext('Bombear 5 bits por segundo');
gettext('Corazon_7Hz');
gettext('Bombear 7 bits por segundo');
gettext('Corazon_DO4');
gettext('Bombear bits a la frecuencia del DO de la cuarta octava');
gettext('Corazon_MI4');
gettext('Bombear bits a la frecuencia del MI de la cuarta octava');
gettext('Corazon_RE4');
gettext('Bombear bits a la frecuencia del RE de la cuarta octava');
gettext('Fijos');
gettext('Heart-Hz');
gettext('Corazón de bombeo de tics a un frecuencia parametrica en Hz');
gettext('Heart-Sec-ena');
gettext('Corazón de bombeo de tics con periodo paramétrico de segundos y entrada de enable');
gettext('Heart-Sec');
gettext('Heart-baud-rx');
gettext('Corazon de tics para generar velocidades de recepción serie en baudios. La velocidad por defecto es 115200');
gettext('Heart-baud');
gettext('Corazón de tics para generar las velocidades de transmisión serie en baudios (Por defecto emite tics a 11500 baudios)');
gettext('Heart-ms-ena');
gettext('Heart-ms');
gettext('Corazón de bombeo de tics a con periodo paramétrico de milisegundos');
gettext('Heart-tics-ena');
gettext('Heart-tics-num');
gettext('Heart-tics');
gettext('Heart-us-ena');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en micro-segundos. Solo se hace el bombeo cuando está habilitado');
gettext('Heart-us');
gettext('heart-N-tics');
gettext('Emits a train of N unitary pulses (tics) when started. A tic is outputed at done when finished');
gettext('**State Flip-flop**  \n0: Idle  \n1: Working...');
gettext('**System clock**');
gettext('The busy output is the  \nstate flip-flop');
gettext('This machine ends when the  \nstate flip-flops goes from  \n1 to 0');
gettext('**Parameter**: Number of  \ntics to emit');
gettext('Generate a train of \"tics\"  when  \nthe machine is on');
gettext('Count the number of  \ntics generated');
gettext('The number of tics requested   \nhave been produced');
gettext('Stop generating  \ntics right now');
gettext('Turn off the machine');
gettext('**Output**  ');
gettext('Heart-1Hz');
gettext('Corazón de bombeo de tics a la frecuencia de 1Hz');
gettext('01_bits');
gettext('02_bits');
gettext('03_bits');
gettext('04_bits');
gettext('05_bits');
gettext('06_bits');
gettext('07_bits');
gettext('08_bits');
gettext('09_bits');
gettext('10_bits');
gettext('12_bits');
gettext('13-bits');
gettext('14_bits');
gettext('16_bits');
gettext('17_bits');
gettext('24_bits');
gettext('32_bits');
gettext('wire-1-1');
gettext('Un simple cable');
gettext('Agregador');
gettext('Separador');
gettext('mult-1-2');
gettext('Multiplicador de cables. Genera un bus de 2 bits, con la entrada duplicada');
gettext('Acoplador-3-8');
gettext('Acoplador de buses de 3 a 8 bits. Se rellena con ceros');
gettext('Agregador-1-2');
gettext('Agregador de buses de 1 y 2 bits en un bus de 3-bits');
gettext('Agregador');
gettext('Agregador de 3 cables en un bus de 3-bits');
gettext('Separador-1-2');
gettext('Separador de bus de 3-bits, en dos de 1 y 2 bits');
gettext('Separador');
gettext('Separador de bus de 3-bits');
gettext('Agregador-1-3');
gettext('Agregador de buses de 1 y 3-bits a a bus de 4-bits');
gettext('Agregador-3-1');
gettext('Agregador');
gettext('Agregador de buses de 2-bits a bus de 4-bits');
gettext('Agregador4');
gettext('Separador-1-3');
gettext('Separador de bus de 4-bits en buses de 1 bits y 3 bits');
gettext('Separador-3-1');
gettext('Separador de bus de 4-bits en bus de 3 bits y cable');
gettext('Separador');
gettext('Separador de bus de 4-bits en buses de 2 bits');
gettext('Separador4');
gettext('mult-1-4-bus');
gettext('Multiplicador de cables. Genera un bus de 4 bits, a patir del bit de entrada');
gettext('Agregador-3-2');
gettext('Agregador de buses de 3 y 2 bits a bus de 5-bits');
gettext('Agregador-5');
gettext('Agregador de bus de 5-bits');
gettext('Join-4-1');
gettext('Join a 4-bit bus and 1 one into a 5-bits bus');
gettext('Separador-1-4');
gettext('Separador de bus de 5-bits en 1 bit y bus de 4 bits');
gettext('Separador-3-2');
gettext('Separador de bus de 5-bits en buses de 3 y 2 bits');
gettext('Separador5');
gettext('Separador de bus de 5-bits en 5 cables');
gettext('Split-4-1');
gettext('Split a 5-bits-buts into two: 4-bits and 1 wire');
gettext('Agregador-1-5');
gettext('Agregador de 2 buses de 1 y 4-bits a bus de 6-bits');
gettext('Agregador-6x1');
gettext('Agregador de 6 cables a bus de 6-bits');
gettext('Agregador');
gettext('Agregador de 2 buses de 3-bits a bus de 6-bits');
gettext('Join-5-1');
gettext('Split a 6-bits-buts into two: 5-bits and 1 wire');
gettext('Separador-1-5');
gettext('Separador-4-2');
gettext('Separador de bus de 6-bits en uno de 4 y otro d2 2bits');
gettext('Separador-6x1');
gettext('Separador de bus de 6-bits en 6 cables');
gettext('Separador');
gettext('Separador de bus de 6-bits en dos de 3bits');
gettext('Split-5-1');
gettext('Join a 5-bit bus and 1 one into a 6-bits bus');
gettext('Agregador-1-7');
gettext('Agregador de 1 cable y un bus de 6 bits a bus de 7-bits');
gettext('Agregador-7x1');
gettext('Agregador de 7 cables de 1-bit a bus de 7-bits');
gettext('Agregador');
gettext('Agregador de 2 buses de 1 y 6bits a bus de 7-bits');
gettext('Separador-3-4');
gettext('Separador de bus de 7-bits en dos buses de 3 y 4 bits');
gettext('Separador-7x1');
gettext('Separador de bus de 7-bits en 7 cables');
gettext('join-6-1');
gettext('Join a 6-bit bus and 1 one into a 7-bits bus');
gettext('mult-1-7-bus');
gettext('Multiplicador de cables. Genera un bus de 7 bits, a patir del bit de entrada');
gettext('split-6-1');
gettext('Split a 7-bits-buts into two: 6-bits and 1 wire');
gettext('Agregador-1-7');
gettext('Agregador-2-6');
gettext('Agregador-6-2');
gettext('Agregador de 2 buses de 6 y 2-bits a bus de 8-bits');
gettext('Agregador-7-1');
gettext('Agregador de un bus de 7 bits y un cable a bus de 8-bits');
gettext('Agregador-8x1');
gettext('Agregador de 8 cables de 1-bit a bus de 8-bits');
gettext('Agregador');
gettext('Extract-bit');
gettext('Extractor de 1 bit de un bus de 8 bits');
gettext('Inject-bit');
gettext('Separador-1-7');
gettext('Separador de bus de 8-bits en 2 buses de 1 y 7 bits');
gettext('Separador-2-6');
gettext('Separador de bus de 8-bits en 2 buses de 2 y 6 bits');
gettext('Separador-3-4');
gettext('Separador de bus de 8-bits en 2 buses de 3 y 4 bits');
gettext('Separador-3-5');
gettext('Separador de bus de 8-bits en 2 buses de 3 y 5 bits');
gettext('Separador-5-3');
gettext('Separador de bus de 8-bits en 2 buses de 5 y 3 bits');
gettext('Separador-6-1-1');
gettext('Separador de bus de 8-bits en 1 buses de 6 bits y dos cables sueltos');
gettext('Separador-8x1');
gettext('Separador de bus de 8-bits en 8 cables');
gettext('Separador');
gettext('Separador de bus de 8-bits en buses de 4 bits');
gettext('mult-1-8-bus');
gettext('Multiplicador de cables. Genera un bus de 8 bits, a patir del bit de entrada');
gettext('mult-1-8');
gettext('Extract-bit');
gettext('Extractor de 1 bit de un bus de 9 bits');
gettext('Join-8-1');
gettext('Agregador de buses de 8 y 2 bits a uno de 9bits');
gettext('split-1-8');
gettext('Separador de bus de 9-bits en uno de 1bit y otro de 8bits');
gettext('Join-8-2');
gettext('Agregador de buses de 8 y 2 bits a uno de 10bits');
gettext('Separador-12x1');
gettext('Separador de bus de 12-bits en 12 cables');
gettext('Join-5-8');
gettext('Agregador de buses de 5 y 8 bits a uno de 13bits');
gettext('split-5-8');
gettext('Separador de bus de 13-bits en uno de 5bit y otro de 8bits');
gettext('Join-10-4');
gettext('Agregador de buses de 10 y 4 bits a uno de 14bits');
gettext('Join-6-8');
gettext('Agregador de buses de 8 y 8 bits a uno de 14bits');
gettext('split-6-8');
gettext('Separador de bus de 14-bits en uno de 6bit y otro de 8bits');
gettext('Agregador');
gettext('Agregador4');
gettext('Separador-2-14');
gettext('Separador de bus de 16-bits en buses de 2 y 14 bits');
gettext('Separador-3-13');
gettext('Separador de bus de 16-bits en buses de 3 y 13 bits');
gettext('Separador');
gettext('Separador de bus de 16-bits en buses de 8 bits');
gettext('Separador4');
gettext('Extractor-bus-1bit');
gettext('Extractor de bus de 1bit de uno de 17bits');
gettext('Extractor-bus-2bits');
gettext('Extractor de bus de 2 bits de uno de 17bits');
gettext('Extractor-bus-4bits');
gettext('Extractor de bus de 4 bits de uno de 17bits');
gettext('Extractor-bus-8bits');
gettext('Extractor de bus de 8 bits de uno de 17bits');
gettext('Separador-22-2');
gettext('Separador de bus de 24-bits en dos buses de 22 y 2 bits');
gettext('soc-test-25');
gettext('Risc-v de 32Bits. Numeros enteros');
gettext('Acceso a la memoria flash spi');
gettext('Separador de bus de 32-bits en 4 buses de 8 bits');
gettext('Separador de bus de 32-bits en buses de 8 y 24 bits');
gettext('Uart para comunicaciones serie con el pico-riscv');
gettext('Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro');
gettext('Comparador de un operando de 32 bits. Se compara si el operando es igual al parámetro');
gettext('Agregador de 4 buses en un bus de 32-bits');
gettext('Memoria ram de 1KB (256x32bits)');
gettext('Comparador menor que, de un operando de 32 bits');
gettext('rEGISTROS');
gettext('## SALIDAS');
gettext('spimemio.v');
gettext('spimemio_xfer.v');
gettext('RAM');
gettext('Agregador4');
gettext('Separador-8-24');
gettext('Separador');
gettext('Separador de bus de 32-bits en buses de 16 bits');
gettext('Separador4');
gettext('05-bits');
gettext('06-bits');
gettext('07-bits');
gettext('09-bits');
gettext('1-bit');
gettext('10-bits');
gettext('12-bits');
gettext('14-bits');
gettext('16-bits');
gettext('2-bits');
gettext('3-bits');
gettext('32-bits');
gettext('4-bits');
gettext('8-bits');
gettext('Comp-1');
gettext('Comparador de un operando de 4 bits. Se compara si el operando es igual al parámetro');
gettext('Comp-2');
gettext('two operand 5-bits comparator');
gettext('Menor-1');
gettext('Comparador menor que, de un operando de 5 bits');
gettext('Comp-1');
gettext('Comparador de un operando de 6 bits. Se compara si el operando es igual al parámetro');
gettext('Comp-2');
gettext('two operand 6-bits comparator');
gettext('Menor-1');
gettext('Comparador menor que, de un operando de 6 bits');
gettext('comp-1');
gettext('Comparador de un operando de 7 bits. Se compara si el operando es igual al parámetro');
gettext('comp-2');
gettext('two operand 7-bits comparator');
gettext('Less-1');
gettext('Comparador menor que, de un operando de 9 bits');
gettext('Less-eq-1');
gettext('Comparador menor o igual que, de un operando de 9 bits');
gettext('grt-eq-1');
gettext('Comparador mayor o igual que, de un operando de 9 bits');
gettext('Comp-1');
gettext('Comparador de igualdad, de un operando de 1 bit');
gettext('Comp-2');
gettext('Comparador de dos operandos de 1 bit');
gettext('Menor-1');
gettext('Comparador menor que, de un operando de 1 bit');
gettext('Menor-2');
gettext('Comparador menor que, de dos operandos de 1 bit');
gettext('Comp-1');
gettext('Comp-2');
gettext('Less-1');
gettext('Comparador menor que, de un operando de 10 bits');
gettext('Less-eq-1');
gettext('Comparador menor o igual que, de un operando de 10 bits');
gettext('grt-eq-1');
gettext('Comparador mayor o igual que, de un operando de 10 bits');
gettext('Comp-1');
gettext('Comparador de un operando de 11 bits. Se compara si el operando es igual al parámetro');
gettext('Comp-1');
gettext('Comparador de un operando de 14 bits. Se compara si el operando es igual al parámetro');
gettext('Comp-2');
gettext('Comp-1');
gettext('Comparador de un operando de 16 bits. Se compara si el operando es igual al parámetro');
gettext('Greather-equal-1');
gettext('Comparador mayor o igual que, de un operando de 16 bits');
gettext('Greather-equal-2');
gettext('Comparador mayor o igual que, de dos operandos de 16 bits');
gettext('Less-1');
gettext('Comparador menor que, de un operando de 16 bits');
gettext('Less-2');
gettext('Comparador menor que, de dos operandos de 16 bits');
gettext('Comp-1');
gettext('Comparador de igualdad, de un operando de 2 bits');
gettext('Comp-2');
gettext('Menor-1');
gettext('Comparador menor que, de un operando de 2 bits');
gettext('Menor-2');
gettext('Comparador menor que, de dos operandos de 2 bits');
gettext('Comp-1');
gettext('Comp-2');
gettext('Menor-1');
gettext('Comparador menor que, de un operando de 3 bits');
gettext('Menor-2');
gettext('Comparador menor que, de dos operandos de 3 bits');
gettext('Comp-1');
gettext('Greather-1');
gettext('Comparador mayor que, de un operando de 32 bits');
gettext('Greather-equal-1');
gettext('Comparador mayor o igual que, de un operando de 32 bits');
gettext('Less-1');
gettext('Comp-1');
gettext('Comp-2');
gettext('Mayor-igual-1');
gettext('Menor-1');
gettext('Menor-2');
gettext('Comparador menor que, de dos operandos de 4 bits');
gettext('Comp-1');
gettext('Comp-2');
gettext('Greather-1');
gettext('Comparador mayor que, de un operando de 8 bits');
gettext('Menor-1');
gettext('Comparador menor que, de un operando de 8 bits');
gettext('Menor-2');
gettext('Comparador menor que, de dos operandos de 8 bits');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('05-bits');
gettext('06-bits');
gettext('07-bits');
gettext('08-bits');
gettext('09-bits');
gettext('10-bits');
gettext('11-bits');
gettext('12-bits');
gettext('13-bits');
gettext('14-bits');
gettext('16-bits');
gettext('17-bits');
gettext('system');
gettext('cont-basic-+1-ini0');
gettext('Contador básico, de 2 bits, inicializado a 0 e incremento de 1');
gettext('**Contador básico**');
gettext('**Valor inicial**');
gettext('**Incremento**');
gettext('cont-basic');
gettext('Contador básico, de 2 bits');
gettext('cont-up-down');
gettext('Contador ascendente/descendente de 2 bits');
gettext('cont-up-mod-M');
gettext('cont-up-system');
gettext('Contador del sistema, módulo M, ascendente, de 2 bits, con reset ');
gettext('cont-up');
gettext('cont-basic');
gettext('Contador del sistema, de 2 bits');
gettext('cont-max');
gettext('Contador del sistema, de 2 bits, con salida de valor máximo alcanzado');
gettext('blocks');
gettext('system');
gettext('cont-basic');
gettext('Contador básico, de 3 bits');
gettext('cont-up-down');
gettext('Contador ascendente/descendente de 3 bits');
gettext('cont-up-rst');
gettext('cont-up-system');
gettext('Contador del sistema, módulo M, ascendente, de 3 bits, con reset ');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 3 bits');
gettext('cont-up-down');
gettext('Registro de 3 bits');
gettext('cont-basic');
gettext('Contador del sistema, de 3 bits');
gettext('system');
gettext('cont-basic-+1-ini0');
gettext('Contador básico, de 4 bits, inicializado a 0 e incremento de 1');
gettext('cont-basic');
gettext('Contador básico, de 4 bits');
gettext('cont-up-down-2');
gettext('Contador ascendente/descendente de 4 bits. Dir=1 cuenta ascendente. Dir=0 descendente');
gettext('cont-up-down');
gettext('Contador ascendente/descendente de 4 bits');
gettext('cont-up-system');
gettext('Contador del sistema, módulo M, ascendente, de 4 bits, con reset ');
gettext('cont-up');
gettext('cont-basic');
gettext('Contador del sistema, de 4 bits');
gettext('cont-up');
gettext('cont-up-system-ena');
gettext('cont-up-system');
gettext('cont-up');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 7 bits, con reset ');
gettext('blocks');
gettext('system');
gettext('cont-basic');
gettext('Contador básico, de 8 bits');
gettext('cont-up-down-limit');
gettext('Contador ascendente/descendente con límites');
gettext('| Top | Bot | dir | enable | Descripción |\n|-----|-----|-----|--------|------|\n|  0  |  0  |  x  |  1     | Limites no alcanzados |\n|  0  |  1  |  0  |  0     | Limite inferior. No dec |\n|  0  |  1  |  1  |  1     | Limite inferior, pero inc |\n|  1  |  0  |  0  |  1     | Limite sup, pero dec |\n|  1  |  0  |  1  |  0     | Limite sup. No inc   |\n|  1  |  1  |  x  |  0     | Imposible |');
gettext('Registro  \nprincipal');
gettext('Incremento');
gettext('Decremento');
gettext('Siguiente valor');
gettext('Según la dirección,  \nel se toma como sigueinte  \nvalor el incrementado o  \ndecrementado');
gettext('top = 1 cuando se  \nha llegado al límite  \nsuperior');
gettext('¿Contador = Max?');
gettext('¿Contador = Min?');
gettext('bott = 1 cuando se  \nha llegado al límite  \ninferior');
gettext('Circuito combinacional para habilitar o no  \nla cuenta. Si estamos en el límite inferior y  \nla dirección es descendente --> NO decrementar  \n\nSi estamos en el límite superior y la dirección es  \nascendente --> NO incrementar');
gettext('**Dirección**:  \n0 : Descendente  \n1 : Ascencente');
gettext('**Tic de cuenta**');
gettext('Dejar pasar el tic de  \ncuenta, o no');
gettext('Registro inicializado  \ncon el valor mínimo');
gettext('cont-up-down');
gettext('Contador ascendente o descendente');
gettext('cont-up');
gettext('counter-down-limit');
gettext('Contador descendente con limite inferior. Cuando dir=1 se inicializa al valor máximo');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco de subida. Versión bloques');
gettext('tic');
gettext('Si contador es 0 y  \nla direccion es  \ndecremento, bloquear tic');
gettext('Si llega un tic  \nllevar el contador  \nal máximo');
gettext('## Detector de flancos de subida\n\nSe genera un tic cuando llega un flanco de subida por la entrada');
gettext('En el resto de casos  \nla salida siempre es 0');
gettext('**Retraso**: 0  \nEl retraso es cero porque el flanco  \nde subida llega desde la entrada  \na la salida sin pasar por biestables');
gettext('cont-basic');
gettext('cont-basic');
gettext('Contador del sistema, de 8 bits');
gettext('cont-max');
gettext('Contador del sistema, de 9 bits, con salida de valor máximo alcanzado');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 9 bits, con reset ');
gettext('system');
gettext('cont-up-rst');
gettext('Contador módulo M, ascendente, de 10 bits, con reset ');
gettext('cont-up-system');
gettext('Contador del sistema, módulo M, ascendente, de 10 bits, con reset ');
gettext('cont-up');
gettext('cont-max');
gettext('Contador del sistema, de 10 bits, con salida de valor máximo alcanzado');
gettext('cont-up');
gettext('Contador del sistema, módulo M, ascendente, de 10 bits');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 11 bits, con reset ');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 12 bits, con reset ');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 13 bits, con reset ');
gettext('cont-up-down');
gettext('Registro de 14 bits');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 14 bits, con reset ');
gettext('cont-up');
gettext('Contador módulo M, ascendente, de 16 bits, con reset ');
gettext('system');
gettext('cont-basic');
gettext('Contador del sistema, de 17 bits');
gettext('blocks');
gettext('Bajada');
gettext('Detector-2');
gettext('Subida');
gettext('change-detector');
gettext('Detect changed on the input signal ');
gettext('## Change detector  \n\nIt emits the followings tics:\n\n* When there is a rising edge on the input signal\n* When there is a falling edge\n* When there is either a rising or falling edge');
gettext('Bajada');
gettext('## Detector de flancos de bajada\n\nSe genera un tic cuando llega un flanco de **bajada** por la entrada');
gettext('**Retraso**: 0  \nEl retraso es cero porque el flanco  \nde bajada llega desde la entrada  \na la salida sin pasar por biestables');
gettext('Detector-2');
gettext('Subida');
gettext('I2C_only_write');
gettext('I2C_write');
gettext('Maestro I2C de un byte de dato. Sólo escritura.');
gettext('La frecuencia de entrada siempre comienza en el ciclo bajo una vez que hacemos ');
gettext('La salida sólo da 0 o flotante. Una resistencia externa al circuito en pull-up a la salida ha de crear el 1.');
gettext('Tics2 son 2 tics de la primera onda y no vuele a hacer nada. A partir del siguiente ciclo saldrán los tics por Shift.');
gettext('registros de desplazamientos: address(7bits)+rw(1bit)+ack(1bit)');
gettext('Registro de desplazamiento (izquierda) de 7 bits');
gettext('Registro de desplazamiento (izquierda) de 2 bits');
gettext('registros de desplazamientos: data(8bits)+ack(1bit).');
gettext('Complemento que junto a resto de los elementos crean la señal Stop.');
gettext('# I2C Maestro. Sólo escritura.');
gettext('INFO: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/QZqGqehCvuk/L9yCuXW_BwAJ');
gettext('Al darle al \"set\" permitirá que pase la frecuencia \"fi\" hacia \"fo\" pero comenzando siempre con un flanco de bajada de dicha señal. Al darle a \"rst\" impide que pase la frecuencia de entrada. Se trata de que la frecuencia de salida siempre-siempre comience con el ciclo bajo.');
gettext('IR-tic-sound');
gettext('Detección de objeto con sensor de infrarrojos (IR). Emite un tic cada vez detecta un objeto, y un sonido');
gettext('Detección de objeto con sensor de infrarrojos (IR). Emite un tic cada vez detecta un objeto');
gettext('**IRr-tic-sound**');
gettext('**IRr-tic**');
gettext('IR-tic');
gettext('Debouncer');
gettext('Remove the rebound on a mechanical switch');
gettext('Pull-up-5');
gettext('FPGA internal pull-up configuration on the connected input port');
gettext('Pull-up');
gettext('Tri-state-8');
gettext('Puerta tri-estado de 8 bits, para configurar pines como entrada/salida');
gettext('Tri-state');
gettext('jelly-kbd');
gettext('Controlador para teclado matricial Jelly');
gettext('Registro de 5 bits');
gettext('Sincronizar las entradas de datos con el reloj del sistema, en un bus de 5');
gettext('![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-03.png)');
gettext('**Fila 0**');
gettext('**Col 3**');
gettext('**Col 0**');
gettext('**Fila 1**');
gettext('**Col 4**');
gettext('**Col 1**');
gettext('**Col 2**');
gettext('**Fila 2**');
gettext('**Fila 3**');
gettext('**Fila 4**');
gettext('**Fila 5**');
gettext('Tiempo de muestreo de  \ncada fila');
gettext('Recorrer las  \nfilas');
gettext('Enviar un 0 por la fila a  \nescanear. Por el resto se  \nenvían 1s');
gettext('**R0**');
gettext('**R1**');
gettext('**R2**');
gettext('**R3**');
gettext('**R4**');
gettext('**R5**');
gettext('Lectura de las 5 columnas de  \nla fila actual');
gettext('Activar  \nPull-ups');
gettext('0: Tecla NO pulsada  \n1: Tecla pulsada');
gettext('Estado actual de la fila  \nescaneada');
gettext('Muestrear la fila  \n(capturar valor)');
gettext('En el siguiente ciclo  \nse graba en la memoria');
gettext('En la memoria se guarda el  \nestado de la fila en el  \nciclo anterior');
gettext('Hay tecla pulsada en  \nla fila actual');
gettext('Detectar si habia tecla pulsada  \nen el escaneo anterior');
gettext('Detecar flanco de subida  \nen tecla');
gettext('Obtener el número de columna  \nsegún la tecla activa');
gettext('Numero de FILA  \nde la tecla pulsada');
gettext('Cuando hay tecla pulsada  \nse resetea el registro  \nen el ciclo siguiente');
gettext('Numero de COLUMNA  \nde la tecla pulsada');
gettext('Tabla para calcular el  \ncódigo de cada tecla  \nen función de su número  \nde fila y columna');
gettext('**KEYCODE**');
gettext('Evento:\n**KEYPRESSED**');
gettext('**KEYPRESSED**');
gettext('Evento:\n**KEYRELEASED**');
gettext('Los eventos son validos si  \nhan ocurrido un tic después  \nde capturar la fila actual  ');
gettext('**KEYRELEASED**');
gettext('**KEY-STATE**');
gettext('Estado de la tecla:  \n1: Pulsada  \n0: No pulsada');
gettext('El estado de la tecla se calcula a partir de los  \neventos Key-pressed y key-released. Cuando  \nse pulsa, se cambia el estado a 1. Al liberarse  \nse cambio a 0');
gettext('![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-usb-25.png)');
gettext('Mapa de los códigos de teclas implementados  \nen el controlador (**KEYCODES**)');
gettext('**COL 4** (C19)');
gettext('**COL 3** (C18)');
gettext('**COL 2** (C17)');
gettext('**COL 1** (C9)');
gettext('**COL 0** (C8)');
gettext('key-beep');
gettext('Lectura de una tecla externa. Pull-up interno activo');
gettext('**Pull-up**');
gettext('**Sincronización**');
gettext('Eliminar los problemas  \nde metaestabilidad');
gettext('**Lógica positiva**');
gettext('0: Tecla NO pulsada  \n1: Tecla pulsada   ');
gettext('**Antirrebotes**');
gettext('Estado de la tecla');
gettext('Detectar **Flanco de subida**  \ny **Flanco de bajada**');
gettext('Tic al apretar');
gettext('Tic al soldar');
gettext('Emitir pitido en la  \npulsacion');
gettext('key');
gettext('sync-bus5');
gettext('sync');
gettext('07-bits');
gettext('08-bits');
gettext('Brillo-control');
gettext('Control del brillo con pulsadores up/down');
gettext('Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador');
gettext('Registro inicializado  \ncon el valor máximo');
gettext('**Brillo**');
gettext('**Incrementos**  \n**del brillo**');
gettext('**Casos en los que NO se incrementa el brillo:**  \n\nEn esos casos se deshabilita el corazón');
gettext('El brillo está al máximo y se está  \napretando el botón de UP');
gettext('El brillo está al mínimo y se está  \napretando el botón de DOWN');
gettext('Deshabilitar  \ncorazón');
gettext('**Las entradas deben**  \n**ser los pulsadores**');
gettext('**Pulsador-tic**');
gettext('brillo-gradual');
gettext('Brillo gradual entre los dos extremos (Máx y Min). La entrada indica el brillo objetivo (1=Máximo, 0=Mínimo)');
gettext('Fijar el brillo constante para el LED');
gettext('Registro del sistema de 8 bits');
gettext('**Unidad de PWM**  \n\n* Frecuencia: 91.53 Hz  \n* Resolución: prescaler de 9 bits: 42.67us  \n* Aplicación: Control intensidad en LEDs');
gettext('**Registro W**');
gettext('**Registro buffer**');
gettext('**Contador de 8 bits**');
gettext('Señal de ov: el contador  \nvuelve a comenzar desde 0  \n');
gettext('Comienza un nuevo  \nperiodo de PWM');
gettext('Valores desde 0 hasta 255');
gettext('Mientras que CONT < W (Anchura pulso)  \nPWM es 1. Cuando CONT >= w, PWM es 0');
gettext('**Señal PWM**');
gettext('Salida registrada  \n(Para cumplir normas  \ndel diseño síncrono)');
gettext('Registro que contiene la  \nanchura (8 bits) del pulso');
gettext('Almacena el valor de la anchura del pulso  \ninntroducida por el usuario. Se guarda en un  \nregistro temporal hasta que al comenzar el  \nsiguiente ciclo de PWM se carga en el registro W');
gettext('El valor del registro sólo se puede actualizar al  \ncomienzo del periodo de PWM para garantizar que  \nel pulso tiene anchura fija en ese periodo');
gettext('Desde fuera se escribir en este registro  \na la velocidad que se quiera, pero se  \ngarantiza que el registro W sólo se  \nactualiza al comienzo de cada ciclo de PWM');
gettext('Sacar el bit de mayor  \npeso del contador');
gettext('brillo');
gettext('fade-out');
gettext('brillo-7');
gettext('Establecimiento del brillo en un bus de 7 bits');
gettext('brillo-gradual-7');
gettext('Transición gradual de brillo entre dos números de 7 bits');
gettext('fade-out-7');
gettext('Desvanecimiento de los bits a 0 de números de 7 bits ');
gettext('brillo-8');
gettext('Establecimiento del brillo en un bus de 8 bits');
gettext('brillo-gradual-8');
gettext('Transición gradual de brillo entre dos números de 8 bits');
gettext('fade-out-8');
gettext('Desvanecimiento de los bits a 0 de números de 8 bits ');
gettext('Basicas');
gettext('Boot');
gettext('Componentes');
gettext('Count');
gettext('data');
gettext('serialize-2-16bits');
gettext('Secuencializar el envío de 2 comandos (de 16 bits) que llegan en paralelo');
gettext('Maquina serializadora:  \nRecibe 2 comandos en paralelo y los envía  \npor su salida uno detrás de otro');
gettext('serialize-2');
gettext('Secuencializar el envío de 2 comandos que llegan en paralelo');
gettext('Cycle');
gettext('Wait-ms-10bits');
gettext('Máquina de wait');
gettext('Máquina de  \ncontar');
gettext('Número max de  \nms. Ej. para esperar 10ms  \nse debe introducir 9');
gettext('Esperar 1ms');
gettext('Wait-ms-2');
gettext('Wait-ms-rst-10bits');
gettext('Wait-ms-stop');
gettext('Timer in ms, with start and stop');
gettext('Biestable de estado  \nde la máquina');
gettext('Mientras la máquina  \nesté apagada el  \ncontador está a 0');
gettext('Contador de tiempo  \nen unidades de  \nmilisegundos');
gettext('El tiempo ha expirado:  \napagar la máquina');
gettext('Unidades de tiempo:  \n1000 microsec = 1ms');
gettext('Al arrancar la máquina,  \neste corazón emite un  \ntic cada 1 ms');
gettext('**Parámetro**:  \nms de espera');
gettext('Sacar el tic de apagado de  \nla máquina por abort o done  \nsegún cómo haya sido');
gettext('Si es por stop: El timer ha abortado  \nSi no, es una terminación normal (timeout)');
gettext('Wait-ms');
gettext('Apagado de la máquina');
gettext('timeout-ms');
gettext('Test if a tic is received within time');
gettext('## Timer-ms\n\nWhen the machine is active, it detects if  \nan input tic arrive within the specified time  \nIf so, another tic is sent to done. If no tic is  \nreceived within time (timeout), a tic is sent  \nto tout');
gettext('Start the machine');
gettext('Tic to detect within time');
gettext('Main timer');
gettext('Start the timer');
gettext('If a tic is received when  \nthe timer is still on,  \nlet it pass...');
gettext('The tic is delayed one unit  \nto prevent reache the timer  \nin the same cycle than start  \n(it can happens if the same tic is  \nconnect both to start and tic inputs)  ');
gettext('Stop the timer:  the tic  \nhas arrived in time');
gettext('The tic arrived in time  \nTic detected!');
gettext('No tic detected  \nwithin time');
gettext('The machine is on');
gettext('tic: No input tic detected');
gettext('tic: input tic detected!');
gettext('cycle-ms');
gettext('Emitir un ciclo cuadrado, de periodo en ms. Empieza en 0');
gettext('Máquina de contar, de 1 bit');
gettext('Calcular el  \nsemi-periodo');
gettext('**Máquina**  \n**de espera**');
gettext('**Máquina**  \n**de contar 2**');
gettext('Señal de salida  \n(cyclo)');
gettext('Comenzar el semi-ciclo i  \n(i = 0,1)');
gettext('Siguiente semi-ciclo');
gettext('¡Que comience un  \nciclo nuevo!');
gettext('¿Estamos en el  \nciclo 1?');
gettext('Si es el ciclo 1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('cycle-rst-ms');
gettext('01-bits');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('08-bits');
gettext('14-bits');
gettext('Serial-bootloader');
gettext('Máquina de contar, de 1 bit, con entrada de Stop');
gettext('**Receptor Serie**');
gettext('Byte a cargar  \nen la memoria');
gettext('El tic de dato recibido sólo  \npasa si la máquina está  \nencendida. De lo contrario se  \nignora');
gettext('Máquina contadora  \nde 2 estados');
gettext('El estado de esta máquina  \ndetermina el canal de acceso:  \n0: Modo normal (ch0)  \n1: Modo Bootloader (ch1)');
gettext('Dirección de  \nescritura');
gettext('Escribir el dato  \nen la memoria');
gettext('## Máquina de carga serie');
gettext('Carga completada!');
gettext('Para automático de la  \nmáquina cuando ha terminado  ');
gettext('Paro externo');
gettext('Serial-bootloader');
gettext('Máquina de cargar por el puerto serie. Contador de 2 bits');
gettext('Máquina contadora ');
gettext('Serial-bootloader');
gettext('Máquina de cargar por el puerto serie. Contador de 3 bits');
gettext('Máquina de contar, de 3 bits, con stop');
gettext('Serial-bootloader');
gettext('Máquina de cargar por el puerto serie. Contador de 4 bits');
gettext('Máquina de contar, de 4 bits, con entrada de stop');
gettext('Serial-bootloader');
gettext('Máquina de cargar por el puerto serie. Contador de 8 bits');
gettext('Máquina de contar, de 8 bits, con entrada de stop');
gettext('Registro de 8 bits con reset');
gettext('Serial-bootloader');
gettext('Máquina de cargar por el puerto serie. Contador de 14 bits');
gettext('Machine-state');
gettext('01-bits');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('05-bits');
gettext('06-bits');
gettext('07-bits');
gettext('08-bits');
gettext('10-bits');
gettext('14-bits');
gettext('count-stop');
gettext('count');
gettext('count-stop');
gettext('count');
gettext('count-rst');
gettext('count-stop');
gettext('count');
gettext('count-max');
gettext('Máquina de contar, de 4 bits. Se introduce en el paso máximo (si N pasos, el paso máximo es N-1)');
gettext('count-stop');
gettext('count');
gettext('count-stop');
gettext('Máquina de contar, de 5 bits, con entrada de stop');
gettext('count');
gettext('Máquina de contar, de 5 bits');
gettext('count-stop');
gettext('Máquina de contar, de 6 bits, con entrada de stop');
gettext('Registro de 6 bits con reset');
gettext('count');
gettext('Máquina de contar, de 6 bits');
gettext('count-stop');
gettext('Máquina de contar, de 7 bits, con entrada de stop');
gettext('Registro de 7 bits con reset');
gettext('count');
gettext('Máquina de contar, de 7 bits');
gettext('count-stop');
gettext('count');
gettext('Máquina de contar, de 8 bits');
gettext('count-max-rst');
gettext('count-max');
gettext('count-stop');
gettext('04-bits');
gettext('data');
gettext('Máquina de envío de Num datos de 8 bits (max 16)');
gettext('SM-S4303R');
gettext('MotorBit');
gettext('Controlador para servo de rotacion continua SprintRC SM-S4303R. Con on=1, el motor avanza. Dir=1 sentido agujas reloj/ 0 el contrario. V1 y V2 son los pulsos para las velocidades horaria y antihoraria (en micro-sec). V0 para que esté parado');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Multiplexor 2:1 de 1-bit');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('**Velocidad 1**: Velocidad para el  \nsentido de giro horario\n');
gettext('**Velocidad 2**: Velocidad para el \nsentido de giro antirhorario');
gettext('**Entrada on/off**: Motor en  \nmovimiento o parado');
gettext('**Motorbit paramétrico** para los **SM-S4303R** o compatibles\n\nTiene 3 parámetros, especificados en micro-segundos. **V1** y **V2** son las posiciones (ancho del pulso)  \npara las velocidades de giro en sentido horario y antihorario respectivamente\n\n**V0** es la posición en la que el servo está parado (velocidad 0)\n\nPor defecto se asignan los valores para las velocidades máximas, tanto en sentido horario como antihorario\n\n* V1max = 1900\n* V2max = 1100\n* V0 = 1500');
gettext('**Velocidad en sentido horario**\n\n* Si V1 >= 1900, la velocidad es máxima\n* Si 1900 > V1 > 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**Velocidad en sentido antihorario**\n\n* Si V2 <= 1100, la velocidad es máxima\n* Si 1100 < V2 < 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**dir**: Sentido de giro  \n1: horario / 0: antihorario');
gettext('**Velocidad 0**: Posición para que  \nel servo esté parado');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('02-bits');
gettext('04-bits');
gettext('08-bits');
gettext('pwm');
gettext('Señal pwm de 2 bits (4 niveles)');
gettext('Parámetro: Número de bits para el prescalado  \n0 para no usar prescalado');
gettext('blocks');
gettext('pwm');
gettext('Señal pwm de 4 bits (16 niveles) y frecuencia de 92Hz');
gettext('pwm-92Hz');
gettext('**Contador principal**');
gettext('**PWM**');
gettext('**Comparador**');
gettext('Extraer los 4 bits  \nde mayor peso');
gettext('Comienza un ciclo  \nde PWM nuevo');
gettext('Extraer el bit de  \nmayor peso');
gettext('El registro se carga  \nen cada comienzo de  \nciclo del PWM');
gettext('Se almacena el nivel  \nintroducido por el user  \nhasta que llegue el  \ncomienzo de ciclo');
gettext('Registrar la salida  \npara cumplir con las  \nreglas de diseño síncrono');
gettext('blocks');
gettext('pwm-100Hz');
gettext('Unidad de pwm de 8-bits. Frecuencia 100Hz (Real 91.53Hz)');
gettext('pwm');
gettext('Señal pwm de 8 bits (256 niveles)');
gettext('pwm-100Hz');
gettext('Unidad de pwm de 8-bit. Frecuenica 100Hz (Real 91.53Hz)');
gettext('Prescaler básico de N bits');
gettext('**Prescaler de 9 bits**');
gettext('**Prescaler básico**');
gettext('Señal de reloj de salida  \nCiclo de trabajo 50%');
gettext('tic de overflow  \nComienza un nuevo periodo');
gettext('**Parámetro**: Bits del prescaler');
gettext('pwm-92Hz');
gettext('Señal pwm de 8 bits (256 niveles) y frecuencia de 92Hz');
gettext('Extraer los 8 bits  \nde mayor peso');
gettext('caida-libre-8bits');
gettext('Calculo de la caida libre de una particula');
gettext('Registro de 8 bits con reset y set');
gettext('## POSICION DEL OBJETO\n\npos(n) = pos(n-1) + vel(n-1)\n\nLa posición varia de 0 a 255 (8 bits)  \nCuando supera ese rango (overflow) se  \nda por terminada la caida');
gettext('Caida libre finalizada');
gettext('Posición inicial');
gettext('Posición actual');
gettext('Tic que indica que hay  \nuna nueva posición');
gettext('## VELOCIDAD DEL OBJETO\n\nVel(n) = vel(n-1) + acc(n-1)\n\n');
gettext('Salida de   \ndesbordamiento');
gettext('## ACELERACIÓN\n\nInicialmente la aceleración es 0.  \nCuando se carga el registro con \nun valor, comienza el movimiento  \nde la partícula');
gettext('Velocidad inicial');
gettext('Acceleración de la particula');
gettext('Estado de la partícula:  \n0: Reposo (estado inicial)  \n1: En caida libre');
gettext('Assignar aceleración  \n¡Que comience la caida!');
gettext('Los cálculos sólo se realizan  \nsi la partícula ha empezado a  \ncaer');
gettext('¡Que comience la fiesta!');
gettext('Academia-Jedi');
gettext('Emojis');
gettext('Agujero-negro');
gettext('First image of a Black Hole');
gettext('**Black Hole!**');
gettext('Jedi-collection');
gettext('Sticker con el logo de la Jedi Collection');
gettext('[Jedi Collection](https://github.com/FPGAwars/Collection-Jedi)  \n\n![](https://github.com/Obijuan/digital-electronics-with-open-FPGAs-tutorial/raw/master/wiki/Tutorial-31/jedi-collection-01.png)');
gettext('00-Pre');
gettext('01-Primero');
gettext('02-Segundo');
gettext('03-Tercero');
gettext('22-Caballero-Jedi');
gettext('Rango de Caballero Jedi. Tutorial I completado con máximos honores');
gettext('00-Observador');
gettext('Rango de Observador. Pre-academia Jedi');
gettext('01-Aspirante-a-Cadete');
gettext('Rango de Aspirante a Cadete. Pre-academia Jedi');
gettext('02-Cadete');
gettext('Rango de Cadete. Primer curso');
gettext('03-Cadete-N1');
gettext('Rango de Cadete Nivel 1. Primer curso');
gettext('04-Cadete-N2');
gettext('Rango de Cadete Nivel 2. Primer curso');
gettext('05-Cadete-N3');
gettext('Rango de Cadete Nivel 3. Primer curso');
gettext('06-Aspirante-Padawan');
gettext('Rango de Aspirante a Padawan. Primer curso');
gettext('07-Aspirante-Padawan-N1');
gettext('Rango de Aspirante a Padawan Nivel 1. Primer curso');
gettext('08-Aspirante-Padawan-N2');
gettext('Rango de Aspirante a Padawan Nivel 2. Primer curso');
gettext('09-Aspirante-Padawan-N3');
gettext('Rango de Aspirante a Padawan Nivel 3. Primer curso');
gettext('10-Padawan');
gettext('Rango de Padawan. Segundo curso');
gettext('11-Padawan-N1');
gettext('Rango de Padawan Nivel 1. Segundo curso');
gettext('12-Padawan-N2');
gettext('Rango de Padawan Nivel 2. Segundo curso');
gettext('13-Padawan-N3');
gettext('Rango de Padawan Nivel 3. Segundo curso');
gettext('14-Aspirante-Jedi');
gettext('Rango de Aspirante a Jedi. Segundo curso');
gettext('15-Aspirante-Jedi-N1');
gettext('Rango de Aspirante a Jedi Nivel 1. Segundo curso');
gettext('16-Aspirante-Jedi-N2');
gettext('Rango de Aspirante a Jedi Nivel 2. Segundo curso');
gettext('17-Aspirante-Jedi-N3');
gettext('Rango de Aspirante a Jedi Nivel 3. Segundo curso');
gettext('18-Jedi');
gettext('Rango de Jedi. Tercer curso');
gettext('19-Jedi-N1');
gettext('Rango de Jedi Nivel 1. Tercer curso');
gettext('20-Jedi-N2');
gettext('Rango de Jedi Nivel 2. Tercer curso');
gettext('21-Jedi-N3');
gettext('Rango de Jedi Nivel 3. Tercer curso');
gettext('Smiley');
gettext('Stickers de Smiley');
gettext('caca');
gettext('Caca sonriente');
gettext('like');
gettext('Like');
gettext('blocks');
gettext('pres-basic');
gettext('09-bits');
gettext('pres-basic');
gettext('Prescaler básico de 9 bits, implementado con bloques');
gettext('Registro del sistema de 9 bits');
gettext('Extrar el bit de  \nmayor peso');
gettext('Registro que almacena  \nla cuenta actual (CONT)');
gettext('Incrementar la cuenta');
gettext('CONT = CONT + 1  \nSe actualiza en el  \nsiguiente tic del sistema');
gettext('button-click-3');
gettext('Detect different clicks on the button: normal click, doble click or long click');
gettext('Pulsador con tic de cambio, pulsación y liberación de tecla');
gettext('## Button-click-3  \n\nDetect three different types of clicks in the Button:\n\n* Normal click  \n* Doble click  \n* Long click');
gettext('When the button is pressed  \nthe timer 1 is started');
gettext('If the button is pressed again  \nwithin the time, it is  \na doble click');
gettext('Timeout: It was  \nnot a doble click');
gettext('Check the current  \nbutton state: pressed  \nor not pressed');
gettext('Button state');
gettext('Button state:  \n1: Pressed  \n2: Not pressed');
gettext('Button is released:  \nwe have a click  \nIt is NOT a long click');
gettext('Button is still  \npressed: we do not know yet  \nif it is a click or long click');
gettext('Timeout for detecting a \ndoble click  \nAfter this time is not considered a  \ndoble click but two clicks in a row');
gettext('Wait for the release  \ntic');
gettext('Release tic has arrived  \nwithin time: it was a  \nnormal click  ');
gettext('In both cases it is  \nconsider a normal click');
gettext('The button has not been  \nreleased after the specified  \ntime: it is a long click');
gettext('**Outputs**');
gettext('pulsador-cambio');
gettext('Pulsador de cambio. Cada vez que se aprieta cambia de estado');
gettext('pulsador-changed');
gettext('pulsador-tic-sound');
gettext('Pulsador de tics con sonido');
gettext('pulsador-tic');
gettext('02-bits');
gettext('03-bits');
gettext('04-bits');
gettext('05-bits');
gettext('06-bits');
gettext('07-bits');
gettext('08-bits');
gettext('09-bits');
gettext('10-bits');
gettext('14-bits');
gettext('16-bits');
gettext('32-bits');
gettext('01-bit');
gettext('reg-rst');
gettext('reg');
gettext('Registro de 2 bits');
gettext('sp');
gettext('2-bits stack pointer');
gettext('2-bit register  \nCurrent posicion');
gettext('Value 3 is used when  \nthe stack is empty');
gettext('## 2-bits Stack Pointer\n\nIt only have 3 position for storing information:  \n0,1 and 2. The 3 is used for indicaning empty stack\n\nIt is it initial value (3 = -1)\n\nWhen the up tic is received, the sp is incremented (but it will never  \nbe higher than its maximum value of 2) and the push tic is emitted  \n(on the next cycle) for being synchronyzed with the sp value\n\n');
gettext('When the down tic is received, the pop tic is emitted and then the sp is decremented  \n(but it cannot be lower than -1). Therefore the pop tic comes before the sp is  \ndecrement. The external circuit has one cycle to read the current value at the top. In  \nthe next cycle the sp is decremented. This approach makes it very easy to implement the  \npop operation on a memory\n\nThe changed tic is emitted whenever the sp has changed  \n(either increased or decreased)');
gettext('Incremented value of  \nthe sp');
gettext('Decremented value  \nof the sp');
gettext('Current sp value');
gettext('Select the value  \nfor updating the  \ncurrent sp');
gettext('valid Change in the  \ninput tics');
gettext('There was a change  \nin the sp register');
gettext('2-1 coder');
gettext('The sp is NOT at TOP  \nand up-tic is received');
gettext('It is ok to  \nincrement the sp');
gettext('The sp is NOT EMPTY  \nand down-tic is received');
gettext('It is ok to  \ndecrement the sp');
gettext('sreg-load');
gettext('reg-rst');
gettext('reg-system');
gettext('Registro de 3 bits del sistema');
gettext('reg');
gettext('sreg-load');
gettext('sreg-rst');
gettext('sreg');
gettext('reg-rst');
gettext('reg-system');
gettext('Registro de 4 bits del sistema');
gettext('reg');
gettext('sreg-load-rst');
gettext('Registro de desplazamiento (izquierda) de 4 bits con carga y reset');
gettext('sreg-load');
gettext('sreg-rst');
gettext('sreg');
gettext('reg-rst');
gettext('reg');
gettext('sreg-load');
gettext('Registro de desplazamiento (izquierda) de 5 bits');
gettext('reg-rst-set');
gettext('reg-rst');
gettext('reg');
gettext('Registro de 6 bits');
gettext('sreg-load');
gettext('Registro de desplazamiento (izquierda) de 6 bits');
gettext('sreg');
gettext('reg-rst-set');
gettext('Registro de 7 bits con reset y set');
gettext('reg-rst');
gettext('reg');
gettext('sreg-load');
gettext('sreg-rst');
gettext('Registro de desplazamiento (izquierda) de 7 bits, con reset');
gettext('sreg');
gettext('reg-addr');
gettext('Registro mapeado en una dirección de memoria');
gettext('### Registro en direccion ADDR');
gettext('Dirección del  \nregistro');
gettext('Valor por  \ndefecto');
gettext('Bus de direcciones');
gettext('Valor a guardar en  \nel registro');
gettext('Tic de escritura');
gettext('Registro seleccionado');
gettext('Valor actual del  \nregistro');
gettext('reg-rst-set');
gettext('reg-rst');
gettext('reg-system');
gettext('reg');
gettext('sreg-load');
gettext('sreg-r-load');
gettext('Registro de desplazamiento (derecha) de 8 bits');
gettext('sreg-rst');
gettext('8-bit shift register with reset');
gettext('sreg');
gettext('reg-system');
gettext('sreg-r-load');
gettext('Registro de desplazamiento (derecha) de 9 bits');
gettext('reg-rst');
gettext('sreg-load');
gettext('Registro de desplazamiento (izquierda) de 10 bits');
gettext('sreg-r-load');
gettext('Registro de desplazamiento (derecha) de 10 bits');
gettext('reg-rst');
gettext('reg');
gettext('reg');
gettext('sreg');
gettext('Registro de desplazamiento (izquierda) de 16 bits');
gettext('sreg');
gettext('Tortuga-2');
gettext('Divisor entre dos');
gettext('Biestable T síncrono, inicializado a 0');
gettext('Biestable T síncrono, inicializado por parametro INI');
gettext('Biestable tipo D con entrada de enable, inicializado al parámetro INI');
gettext('Biestable D con inicialización paramétrica');
gettext('Generar un pulso de reloj al recibir un flanco por la entrada');
gettext('Biestable D inicializado a 0');
gettext('Delay flip-flop');
gettext('Tortuga: Divisor entre 2\n\nImplementado a partir de un\nbiestable T síncrono');
gettext('Hacer que solo responda a los flancos\nde subida de la señal de entrada');
gettext('SPI-master');
gettext('SPI-slave');
gettext('SPI_Master_16bits');
gettext('parts');
gettext('serial-SPI-mode0-2MHz');
gettext('Pasarela serie-SPI-master. Acceso a periféricos SPI desde el PC');
gettext('Datos recibidos  \ndesde el PC');
gettext('**Gestion de la señal SS:**  \nCuando se recibe un caracter por el puerto  \nserie se pone a 0 (si ya estaba se deja a 0)  \nSi transcurren 200µs desde que se envió por  \nel SPI el último byte se lleva ss a reposo (1)');
gettext('**Transmisor serie**');
gettext('Datos enviados \nhacia el PC');
gettext('spi-master-mode0-2MHZ');
gettext('spi-master-reg');
gettext('SPI máster con interfaz de acceso a registros mapeados');
gettext('Señal de reloj de 8 pulsos, a 2MHZ');
gettext('Se generan 8 pulsos de  \nreloj, a 2MHZ');
gettext('Esta estructura en anillo genera  \nexactamente una señal de 2Mhz, cuando  \nel reloj del sistema es de 12Mhz');
gettext('Contador de flancos');
gettext('En total llegan 16 flancos');
gettext('Solo se permite el paso  \nde tics mientras la  \nmáquina esté encendida');
gettext('Cada 3 tics llega un  \nflanco');
gettext('Tic de arranca o  \nde siguiente. Se dejan  \npasar');
gettext('Máquina que genera una señal de  \nreloj de 2MHZ. Solo se emiten  \n8 pulsos con cada activación');
gettext('SPI-heart-2MHZ-DIV');
gettext('SPI-heart-2MHZ');
gettext('En total llegan 16 flancos  \n8 de subida y 8 de bajada');
gettext('timer-system-spi');
gettext('Test');
gettext('SPI-cmd-regs');
gettext('Implementación de los 3 comandos para acceder a los registros mapeados');
gettext('Detectar el comando, y devolver los valores que llegan tras el comando');
gettext('## SPI-cmd-regs\n\nImplementacion de los comandos de acceso a registros:  \n* Establecer la dirección del registro (SAP)  \n* Lectura de registro (RD)  \n* Escritura en registro (WR)  \n');
gettext('### Comando SET ADDRESS POINTER');
gettext('**Registro**  \n**de dirección**  ');
gettext('### Comando Escritura en Registro');
gettext('### Comando Lectura de Registro');
gettext('Tic de lectura');
gettext('**ENTRADAS**');
gettext('**SALIDAS**');
gettext('Reset de los bloques  \nsintácticos');
gettext('Se hace reset de los bloques sintáticos cuando se ha  \ndetectado alguno de los comandos, o bien llega un reset  \ndesde el exterior');
gettext('**Comando detectado**');
gettext('Habilitar la salida del tic  \ndel proximo dato: es un valor');
gettext('Solo se comprueba  \nel comando cuando  \nllega un tic');
gettext('SPI-slave-mode0-2MHZ');
gettext('Unidad SPI sclava. Transmisor y receptor');
gettext('**Dato de entrada**  \nSincronizados con el  \nreloj del sistema');
gettext('Todos los pines de entrada del SPI  \nse sincronizan con el reloj del sistema');
gettext('Flanco de subida del  \nreloj sclk');
gettext('Captura de los datos  \nen flanco de subida  \nde la señal SCLK');
gettext('Solo se hace caso a SCLK si  \nel esclavo está seleccionado  \n(SS debe estar a 0)');
gettext('**Registro de**\n**Desplazamiento**');
gettext('### Transmisión de los datos');
gettext('Bit de salida,  \nhacia el Maestro');
gettext('Registro de datos  \nAquí se guarda el  \ndato que se quiere  \ntransmitir');
gettext('Se transmite un bit cada  \nvez que se recibe un  \nflanco de bajada de SCLK');
gettext('Al comienzo de una transaccion  \n(Flanco de bajada en SS) o  \ndespues de terminar la transacción  \nanterior, se carga el registro  \nde desplazamiento con el siguiente valor');
gettext('Contador de bits de  \nla transacción actual  \nCuando es 0, significa que  \nestá en reposo. Cuando es  \n!=0 es que hay una transacción  \nen curso');
gettext('El overflow indica que  \nque la transacción  \nha finalizado');
gettext('Cuando el esclavo NO está  \nseleccionado, el contador  \nestá en RESET');
gettext('**Registro de**  \n**desplazamiento**');
gettext('Recepción de datos  \ndel Maestro');
gettext('Almacenar el dato  \nrecibido');
gettext('### Recepción de datos');
gettext('Retrasamos la captura 2 ciclos para  \ndejar ese tiempo al circuito para que  \nhaga calculos, si necesita. Debe cargar  \nel nuevo valor antes de que concluyan los  \ndos ciclos de reloj posteriores a la finalización  \nde la transacción anterior');
gettext('Cuaando el esclavo NO está seleccionado  \nla salida MISO está en alta impedancia  \nEsto permite conectar varios módulos esclavos');
gettext('Flanco de bajada\ndel reloj sclk');
gettext('Los datos que llegan se  \ncapturan en flanco de  \nsubida de SCLK');
gettext('Los datos se depositan en MISO en el flanco de bajada de SCLK  \nComo la señal es de 2MHZ, hay 3 tics por periodo. Cuando llega un  \nflanco de subida, en el esclavo está retrasada 2 tics por la  \nsincronizacion. Un ciclo despues llega el flanco de bajada  \nEsa es la razón de que tics_down esté retrasasa un ciclo con  \nrespecto a tics-up');
gettext('## SPI Esclavo. MODO 0. CPOL=0, CPHA=0, 2MHZ');
gettext('SPI-slave-unit');
gettext('**BIT**: Tic que indica que  \nhay un bit que ha llegado');
gettext('Se transmite un bit cada  \nvez que se recibe un  \nflanco de subida de SCLK');
gettext('spi-slave-test-cmd');
gettext('Unidad spi esclavo de prueba. Implementa los comandos write_led y read_buttons. ');
gettext('**Pines BUS SPI**');
gettext('**Pin BUS SPI**');
gettext('**Bloque SPI-esclavo**');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **READ_BUTTONS**      | 0x60       | Lectura de los pulsadores          |');
gettext('### Comando WRITE_LEDs');
gettext('**Registro**  \n**de LEDs**');
gettext('Valor inicial para  \nlos LEDs');
gettext('Estado  \npulsador 1');
gettext('Estado  \npulsador 2');
gettext('Construir el byte a transmitir  \nal maestro: Todos los bits a 0  \nsalvo los dos de menos peso, que  \ncontienen Sw1 y SW2');
gettext('### Comando READ_BUTTONS');
gettext('Tic de lectura de  \nlos pulsadores');
gettext('Este comando no tiene argumentos adicionales:  \nen cuanto se recibe el código de comando,  \nse usa el tic recibido para cargar el estado  \nde los pulsadores en el registro de transmisión  \ndel SPI para que se envíe en la próxima transacción  ');
gettext('Bloque SPI esclavo de test: Implementa dos comandos, uno para escribir en los LEDs y otro para leer los pulsadores');
gettext('## SPI esclavo completo. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ');
gettext('spi-slave-test-echo');
gettext('Unidad spi esclavo de prueba. Todo lo recibido se saca por los LEDs y se devuelve en la siguiente transacción (eco)');
gettext('Bloque SPI esclavo de test: Todo lo que recibe en un transacción lo saca por los leds y lo almacena\npara devolverlo en la siguiente (Eco). Justo después del reset devuelve un 0 en la primera transacción');
gettext('Todo lo recibido se vuelve a  \nenviar en la siguiente transacción');
gettext('spi-slave-test-id');
gettext('Unidad spi esclavo de prueba. En cada transacción obtiene el dato recibido y envía la constante ID. Es para hacer pruebas con los maestros');
gettext('Bloque SPI esclavo de test: Devuelve siempre la misma constante al leer, y todo lo recibido lo saca por los LEDS');
gettext('Constante a devolver al maestro  \nen todas las transacciones');
gettext('Flanco de baja en ss:  \ncomienza una nuestra transacción  \n');
gettext('Cargar el identificador  \nal comienzo de la transacción  \npara devolverlo como dato de  \nsalida');
gettext('spi-slave-test-regs');
gettext('Unidad spi esclavo de prueba. Implementa 3 registros mapeados en memoria: leds, buttons e id');
gettext('## COMANDOS\n\n| Comando | Abrev. | Código | Descripción |\n|---------|-------------|----------------|-------------|\n| **SET ADDRES POINTER ** *val* | SAP  | 0x7D       | Establecer el valor del registro de dirección |\n| **WRITE REGISTER** *val*      | WR   | 0x7E       | Escribir en el registro apuntado por el registro de dirección |\n| **READ REGISTER**             | RD   | 0x7F       | Leer el registro apuntado por el registro de dirección |\n\n');
gettext('### Registro de LEDs');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| 12h  | R     |  PULSADORES | Estado de los pulsadores SW1 y SW2 | 00h |\n| FDh  | R     |  ID | Código de identificación del periférico | 50h |\n');
gettext('**Lectura de registros**:  \nDevolver el contenido del registro seleccionado  \nSi no hay ninguno seleccionado se devuelve  \nel valor 0x00');
gettext('Valor a enviar al  \nmaestro, en la  \nlectura');
gettext('Se pone a 1 cuando NO hay  \nningún registro seleccionado');
gettext('Valor por defecto');
gettext('**Código de los comandos**');
gettext('**BUS de direcciones**');
gettext('**BUS de datos** de entrada');
gettext('**BUS de datos**  \nde salida');
gettext('**Bloque cmd-reg**');
gettext('**Bloque Reg-addr**');
gettext('**BUS de control** ');
gettext('Valor a devolver cuando  \nno hay ningun registro  \nseleccionado');
gettext('### Registro de Identificacion');
gettext('### Registro de pulsadores');
gettext('Selección del  \nregistro');
gettext('Codificador 4 a 2');
gettext('Número que identifica  \na este periférico');
gettext('Detectar accesos a su dirección');
gettext('Dirección donde está  \nmapeada la constante');
gettext('Dirección de  \nmapeo');
gettext('## SPI esclavo completo. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ\n\nBloque SPI esclavo de test: Implementa el acceso a 3 registros mapeados en memoria:  \nUno para acceso a los LEDs, otro para leer los pulsadores y otro para leer el  \nidentificadoor del periférico');
gettext('SPI16master');
gettext('SerialSPI16master');
gettext('Convierte 2 bytes del puerto serie en una palabra de 16 bits para el SPI master de 16 bits.');
gettext('SPI Master 16 bits.');
gettext('blocks');
gettext('Serial-rx');
gettext('Serial-tx-dual');
gettext('Transmisor serie dual, multiplexado');
gettext('### Transmisor 1');
gettext('### Transmisor 2');
gettext('Selección de transmisor');
gettext('Serial-tx');
gettext('Serial-tx16');
gettext('Transmisor serie de 16 bits');
gettext('## Transmisor de 16 bits\n\nTransmitir un dato de 16 bits por el puerto serie. Primero el byte de mayor peso, y luego el menor  \n');
gettext('**Tic de star**');
gettext('**done**  \n(tic de fin)');
gettext('**BAUDIOS**');
gettext('**Dato**');
gettext('serial-tx-str');
gettext('Envío de una cadena por puerto serie');
gettext('**Transmisor**');
gettext('Serial-tx');
gettext('Transmisor serie (hecho a partir de bloques)');
gettext('Un simple cable pasivo, para organizar las conexiones complicadas');
gettext('Biestable De del sistema que hay que  \nañadir para cumplir las reglas de diseño  \nsíncrono: toda señal sacada al exterior,  \nespecialmente si es un cable de comunicaciones  \nasíncronas, debe pasar por un biestable');
gettext('Este Biestable desde  \nestar inicialmente  \na 1, ya que es el  \nvalor de reposo de la  \nlínea serie');
gettext('Conversión de los datos serie a  \nparalelo, mediante un registro  \nde 9 bits. Inicialmente tiene todos  \nsus bits a 1, porque la línea está  \nen reposo');
gettext('**Biestable D**');
gettext('Evento: Comienzo de \ntransmisión');
gettext('Cargar el registro con  \nel dato a enviar en el  \narranque (0 -> 1)');
gettext('**Biestable RS**  \nEstado del transmisor');
gettext('0: Parado. Sin transmitir  \n1: Ocupado. Transmitiendo dato');
gettext('**Generador de**\n**Baudios**');
gettext('Contador de bits  \ntransmitidos');
gettext('El registro de desplazamiento  \nes de 9 bits, para almacenar  \nlos 8 bits de datos y  \nel bit de comienzo (start)');
gettext('Evento: Ultimo  \nbit enviado');
gettext('Al enviarse el último  \nbit, se cambia el estado  \na parado (reset)');
gettext('**Cable pasivo**  \nPara organizar el  \ncableado del reloj');
gettext('**Dato a transmitir**');
gettext('**Bit de Stop**');
gettext('**Bit de start**');
gettext('**Tic de transmisión**  \n¡Que comience la  \ntransmisión!');
gettext('**Línea serie**');
gettext('**Tic de terminación (done)**');
gettext('**BAUDIOS**\n');
gettext('El tic de terminación está un  \nperiodo de reloj retrasado para  \nque el transmisor pase al estado  \nParado, y que todo se reinicie  \nantes de que se pueda volve a  \nenviar el siguiente caracter');
gettext('El estado del transmisor  \nse saca por la señal  \nbusy');
gettext('Arrancar el generar de baudios  \nal activarse el transmisor');
gettext('Serial-tx16');
gettext('**Estado del transmisor**  \n0: Apagado  \n1: Funcionando');
gettext('Transmistor activado');
gettext('Generar tic  \ninicial');
gettext('**Biestable de**  \n**cambio**');
gettext('Indica qué byte  \nse envía');
gettext('Solo se deja pasar  \nel tic si el transmisor  \nestá habilitado');
gettext('Tic de transmisión');
gettext('Mux de selección  \ndel dato a enviar:  \nel de mayor peso o  \nel de menor');
gettext('**Dato de mayor peso**  \nSe envía el primero\n');
gettext('**Dato de menor peso**  \nSe envía el segundo');
gettext('Tic de siguiente carácter');
gettext('Se ha enviado el byte 2  \nTerminar: apagar el transmisor');
gettext('Al pasar de 0 a 1 es cuando  \nhemos enviado el segundo  \nbyte');
gettext('Enviar dato  \nde 16 bits');
gettext('serial-rx');
gettext('Receptor serie asíncrono. Implementación en bloques');
gettext('Bits series entrantes');
gettext('**Cable**  \nUn simple ccable, para  \norganizar mejor las  \nconexiones del reloj  ');
gettext('**Condición de arranque:**  \nLlega el bit de start  \nque es 0. Detectamos  \nel flanco de bajada');
gettext('**Estado receptor**  \n');
gettext('0: Esperando (apagado)  \n1: Recibiendo dato  ');
gettext('La recepción solo se habilita  \ncuando el receptor está  \nencendido');
gettext('**Generador de baudios**\nSe generan los tics  \npara leer los bits serie  \nque van llegando, a la  \nvelocidad configurada');
gettext('Cuando receptor apagado  \nel contador se deja en 0  ');
gettext('Evento:  \nleer un bit');
gettext('**Registro de desplazamiento**  \nRecibe los 8 bits del dato más  \nel bit de stop final en serie  \ny los saca en paralelo');
gettext('**Conntador de bits recibidos**  \nUna vez que llega el bit de start,  \nque es el que lo inicia todo,  se  \nespera recibir 8 bits de datos +  \nel bit de stop final: 9 bits ');
gettext('Bits a recibir');
gettext('Evento: se han recibido  \nlos 9 bits: FIN');
gettext('**Registro de datos**  \nContiene el dato final  \nrecibido, de 8 bits');
gettext('Capturar el dato  \nfinal');
gettext('Retrar el tic de dato  \nrecibido un periodo,  \npara que la señal de  \nbusy se ponga a 0');
gettext('**Tic de dato recibido**  \nNos indica que ha llegado  \nel dato y lo podemos leer');
gettext('**Línea serie**  \nPor aquí llegan los  \ndatos en serie');
gettext('Sincronizador: evitar los  \nproblemas de metaestabilidad');
gettext('Hemos terminado  \nApagar el receptor  \n(volver al estado inicial)');
gettext('serial-tx-srt32');
gettext('Envío de una cadena por puerto serie (max 32 caracteres)');
gettext('Seleccionar siguiente  \nbyte a enviar');
gettext('Tamaño de la  \ncadena');
gettext('Apuntar al siguiente  \ncaracter a enviar');
gettext('Condición de terminación  \nSe ha enviado el último carácter');
gettext('Meter la cadena a enviar,  \nen ASCII hexadecimal');
gettext('Emax-ES08A');
gettext('Futaba-3003');
gettext('TowerPro-SG90');
gettext('blocks');
gettext('ServoPWM-8bits');
gettext('Controlador de servos, de 8 bits. El periodo del PWM por defecto es de 20ms (Futaba 3003)');
gettext('**Salida PWM**');
gettext('Conectar directamente  \nal servo');
gettext('Posición del servo. Indica el  \nancho del pulso en unidades de  \n10 usec. Así, un valor de 60  \nindica una anchura de 600 usec');
gettext('Tic de escritura de  \nuna nueva posición');
gettext('Habilitación del servo');
gettext('ServoBit-90');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a las 2 posiciones POS0 y POS1');
gettext('**Posición 1**: Posición del servo cuando  \nse introduce un 1\n\nEl valor por defecto es de 135 grados\n');
gettext('**Posición 0**: Posición del servo cuando  \nse introduce un 0\n\nEl valor por defecto es de 45 grados');
gettext('**Entrada**: posición a donde llevar  \nel servo (posición 0 ó 1)');
gettext('**Servobit paramétrico** para los microservos **EMAX-ES08A** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **580 usec**  \n* Extremo izquierdo **2550 usec**\n');
gettext('ServoBit');
gettext('Servobit-90');
gettext('ServoBit para Futaba 3003. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit paramétrico para Futaba 3003. Controlador de 1 bit para mover el servo a las 2 posiciones P0 y P1');
gettext('**Servobit** para Servos Futaba 3003 o comaptibles\nLas dos posiciones están distanciadas **90 grados**  \n\n* **Posicion 0**: 45 grados  \n* **Posicion 1**: 135 grados  ');
gettext('**Servobit paramétrico** para los microservos **Futaba 3003** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **380 usec**  \n* Extremo izquierdo **2410 usec**\n');
gettext('Servobit');
gettext('Servobit-90');
gettext('ServoBit para micrservo TowerPro-SG90. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('**Servobit paramétrico** para los microservos **TowerPro SG-90** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **500 usec**  \n* Extremo izquierdo **2350 usec**\n');
gettext('Servobit');
gettext('ServoPWM-8bits');
gettext('Temporizador en unidades de 10 usec');
gettext('Temporizador  \nTiempo en unidades  \nde 10us');
gettext('Genera el ancho del  \npulso según el  \nvalor de delay que  \nindique el usuario');
gettext('**Registro posición**');
gettext('Almacena la posición actual  \ndel servo');
gettext('**Registro de**  \n**estado**');
gettext('0: Servo deshabilitado  \n1: Servo activado');
gettext('**Periodo del PWM**');
gettext('Por cada periodo nuevo se  \ngenera un pulso nuevo, de anchura  \nespecificada por su registro  \nde posición');
gettext('note');
gettext('Emitir un tono (onda cuadrada) definido por su divisor');
gettext('cmd8');
gettext('blocks');
gettext('bus-cycle');
gettext('Generar un ciclo de bus');
gettext('timer-10usec');
gettext('timer-msec-rst');
gettext('timer-msec-stop');
gettext('Timer in ms, with stop input');
gettext('timer-msec');
gettext('timer-sec');
gettext('Temporizador en segundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('**Parametro del timer**  \nSegundos a esperar');
gettext('timer-system');
gettext('timer-usec-rst');
gettext('timer-usec');
gettext('timer-10usec');
gettext('Almacenar el tiempo  \nde espera al arrancar');
gettext('**Registro de**  \n**espera**');
gettext('**Contador de**  \n**tiempo**');
gettext('Cada unidad de tiempo  \nson 10 usecs');
gettext('Contador en reset  \ncuando apagado');
gettext('¿Han transcurrido el tiempo  \nindicado por el registro  \nde espera?');
gettext('Ha transcurrido el tiempo indicado');
gettext('**Biestable**  \n**de estado**');
gettext('0: Apagado  \n1: Funcionando');
gettext('VGA-retro');
gettext('Monster-LED-green');
gettext('Convertir la pantalla de la VGA en un LED gigante. Version para la AP-VGA');
gettext('Generador de sencuencias refresco horizontales y verticales para monitor VGA. Resolucion 256x240');
gettext('Si estamos en zona visible,  \nse envía el estado del  \nMonsterLED por el canal verde');
gettext('VS (VERTICAL)  ');
gettext('**VGA**');
gettext('R0');
gettext('R1');
gettext('**ROJO**');
gettext('B0');
gettext('B1');
gettext('**AZUL**');
gettext('G0');
gettext('G1');
gettext('**VERDE**');
gettext('**Estado fondo pantalla**:  \n0: Negro  \n1: Verde  ');
gettext('Actualizar el estado del fondo:  \nSólo se captura cuando ha  \nterminado el frame');
gettext('HS (VERTICAL)  ');
gettext('Tamaño de la línea en píxeles.  \nCada pixel es igual a  un tic  \n');
gettext('Comienzo del pulso de  \nsincronismo horizontal  \n');
gettext('Fin del pulso de sincronismo  \nhorizontal  \n');
gettext('**Calculo de parámetros HORIZONTALES**  \nH_MAX = H_DISPLAY + H_BACK + H_FRONT + H_SYNC - 1  \nHS_START = H_DISPLAY + H_FRONT  \nHS_END = H_DISPLAY + H_FRONT + HSYNC -1  ');
gettext('Tamaño vertical  \nen líneas');
gettext('Comienzo del pulso de  \nsincronismo vertical\n');
gettext('Fin del pulso de  \nsincronismo vertical\n');
gettext('**Calculo de parámetros VERTICALES**  \nV_MAX = V_DISPLAY + V_BOTTOM + V_TOP + V_SYNC - 1  \nVS_START = V_DISPLAY + V_TOP \nVS_END = V_DISPLAY + V_TOP + VSYNC -1  ');
gettext('**Sincronización horizontal**  \n\n* H_DIPLAY = 305 -->  Resolución  \n* H_FRONT = 7  \n* H_SYNC = 46\n* H_BACK = 23  \n');
gettext('**Sincronización vertical**  \n\n* V_DIPLAY = 480 -->  Resolución  \n* V_TOP = 10 \n* V_SYNC = 2\n* V_BOTTOM = 33  \n');
gettext('```\n                         H_MAX (pixeles)  \n<------------------------------------------------------------>  \nH_DISPLAY (visible)      |   H_FRONT   | H_SYNC   |  H_BACK  |\n<------------------------><------------><--------><---------->  \n                                       ^          ^           \n                                       |          |   \n                                   HS_START     HS_END\n```');
gettext('**Generación ventana visibilidad**');
gettext('**Display_on**');
gettext('Funciona con los dos monitores: Fuji y LCDtv  \n\nAunque he tenido que ajustar la posición dentro del propio  \nmonitor  ');
gettext('Señales de sincronía:  \nvhs[1]: VS  \nvhs[0]: HS');
gettext('Sincronismo HORIZONTAL');
gettext('Sincronismo\nVERTICAL');
gettext('Sync');
gettext('Test-FPGAwars');
gettext('Test for the VGA-retro');
gettext('Dibujar un marco que cubre toda la zona visible. Muy util para ajustar el monitor');
gettext('**HS. HORIZONTAL**  ');
gettext('**SINCRONISMO**');
gettext('**Rectángulo ROJO**');
gettext('La señal es visible');
gettext('**Marco azul**');
gettext('**Imagen Verde**');
gettext('La imagen solo se muestra en la primera mitad vertical  \n(En la segunda mitad se activan no hay imagen)');
gettext('v y h son las direcciones de cada pixel');
gettext('Todo se trasa un ciclo de reloj');
gettext('Duplicar el cable');
gettext('**B0**');
gettext('**B1**');
gettext('**G0**');
gettext('**G1**');
gettext('**VS. VERTICAL**  ');
gettext('Modulo for drawing a frame around the visible zone  \n');
gettext('VGA-LED-2v');
gettext('Dos LEDs verticales en la VGA');
gettext('hpos[7]');
gettext('visible');
gettext('Cualquier señal enviada al  \ncanal de color tiene que  \nestar a 0 cuando la señal NO  \nes visible');
gettext('Actualizar el estado de la \nBarra 1 cada vez que se  \nacaba de dibujar un frame');
gettext('Señal vídeo  \nde la Barra 1');
gettext('Combinación de las  \nseñales de Vídeo:  \nBarra1 + Barra0');
gettext('Señal vídeo  \nde la Barra 0');
gettext('Se entra en la zona de la  \nbarra 0 cuando hpos[7]=0');
gettext('**Estado Barra 0**');
gettext('**Estado Barra 1**');
gettext('frame');
gettext('Icemove4');
gettext('Icemove4: Controlador de 4 movimientos para el Icebot');
gettext('# ICEmove4\n\nControlador para el [robot Icebot](https://github.com/Obijuan/icebot/wiki), que genera **4 movimientos**:  \nParado, giro derecha (arco), giro izquierda (arco) y adelante');
gettext('**Código del movimiento**');
gettext('**Motor de la rueda derecha**');
gettext('**Motor de la rueda izquierda**');
gettext('## Tabla de movimientos\n\n| Código de entrada | Movimiento del Robot   |\n|-------------------|------------------------|\n|  0                |  Parado                |\n|  1                |  Giro derecha (arco)   |\n|  2                |  Giro izquierda (arco) |\n|  3                |  Adelante              |');
gettext('**Entrada de reloj**');
gettext('Icemove9');
gettext('Icemove9: Controlador de 9 movimientos para el Icebot');
gettext('# ICEmove9\n\nControlador de 9 movimientos para el robot Icebot  \n(Entrada de 4 bits)');
gettext('## Tabla de movimientos\n\n| Código de entrada | Movimiento del Robot   |\n|-------------------|------------------------|\n|  0, 1, 2, 3       |  Parado                |\n|  4,6              |  Arco derecha          |\n|  5,7              |  Arco izquierda-atrás  |\n|  8,9              |  Arco derecha-atrás    |\n|  10,11            |  Arco izquierda        |\n|  12               |  Giro derecha          |\n|  13               |  Atrás                 |\n|  14               |  Adelante              |\n|  15               |  Giro izquierda        |');
gettext('ADC');
gettext('Displays');
gettext('LEDs');
gettext('Memory');
gettext('PWM');
gettext('Pines-ES');
gettext('Pulsadores');
gettext('SPI');
gettext('Teclado');
gettext('Test');
gettext('VGA');
gettext('01-Potentiometer-LEDs');
gettext('**ADC_SDA** (INOUT)  ');
gettext('**ADC_SCL**');
gettext('**Frecuencia de**  \n**muestreo**');
gettext('**Canal 0**');
gettext('## Ejemplo 1: Lectura de un potenciómetro\n\nSe lee el potenciómetro conectado al canal 0 de la icezum Alhambra  \ny se muestra su valor digital (8 bits) en los LEDs  \nLa lectura se realiza 20 veces por segundo (20Hz)');
gettext('**Conversor A/D**');
gettext('Valor digital del  \npotenciómetro');
gettext('02-Potentiometer-serial');
gettext('## Ejemplo 2: Lectura de un potenciómetro y envío al PC\n\nSe lee el potenciómetro conectado al canal 0 de la icezum Alhambra  \ny se envía su valor digital al PC, además de mostrarse en los LEDs  \nLa lectura se realiza 100 veces por segundo (100Hz)');
gettext('03-Potentiometer-servo');
gettext('## Ejemplo 3: Moviendo un servo con el potenciómetro  \n\nLa salida del conversor A/D se conecta a la entrada de un servo para  \ncambiar su posición con el potenciómetro\n\n');
gettext('04-Potentiometer-BCD-7Seg');
gettext('## Ejemplo 4: Mostrar potenciómetro en un display de 7 segmentos  \n\nEl valor analógico se divide en 16 niveles (4 bits) y se muestra en un  \ndisplay de 7 segmentos como un dígito hexadecimal. Sólo hay que quedarse  \ncon los 4 bits más significativos de la muestra y sacarlos por el  \n7 segmentos\n');
gettext('Mostrar el valor en  \nbinario en los LEDs');
gettext('Mostrar el valor en  \nel display de 7 seg  \nen hexadecimal');
gettext('4 bits de mayor peso  \nde la muestra');
gettext('Se puede ver en funcionamiento en este [vídeo de Youtube](https://www.youtube.com/watch?v=8GTkoyxFUTY):\n\n[![Click to see the youtube video](http://img.youtube.com/vi/8GTkoyxFUTY/0.jpg)](https://www.youtube.com/watch?v=8GTkoyxFUTY)');
gettext('05-Potentiometer-8LEDs');
gettext('## Ejemplo 5: Usar el potenciómetro para seleccionar entre 8 opciones  \n\nEl valor analógico se divide en 8 niveles (3 bits) y se muestra en los  \n8 LEDs, encendiendo un único led por cada nivel. Esto permite usarlo como  \nun selector entre 8 opciones\n');
gettext('Decodificador de  \n3 a 8');
gettext('Se puede ver en funcionamiento en este [vídeo de Youtube](https://www.youtube.com/watch?v=SLV-YsCvrmw):\n\n[![Click to see the youtube video](http://img.youtube.com/vi/SLV-YsCvrmw/0.jpg)](https://www.youtube.com/watch?v=SLV-YsCvrmw)');
gettext('Alhambra II_adc-test-01');
gettext('**Selección de**  \n**Canal analógico**');
gettext('COM-1129-SparkFun');
gettext('SPI');
gettext('01-spi-serial-test');
gettext('### Ejemplo 1: Probando el display desde el PC\n\nEjemplo del usao de la pasarela SERIE-SPI para manejar el display SPI de 4  \ndígitos de 7 segmentos. Es necesario usar un divisor de 8 para que la  \nfrecuencia del reloj sea de 250Khz (por especificaciones del display)');
gettext('Frecuencia de funcionamiento:  \n2Mhz / 8 = 250Khz');
gettext('Datos recibidos desde el PC  \npor el puerto serie para  \nenviarlos al display');
gettext('Del display no se recibe  \nnada. No conectamos MISO');
gettext('No hay que enviar nada  \nal PC de vuelta. No  \nconectamos TX');
gettext('02-Digito-pulsador');
gettext('### Ejemplo 2: Mostrar un dígito constante al apretar el pulsador\n\nSe debe probar después de haber alimentado el display. Cada vez que se aprieta  \nel pulsador sw1, se muestra el dígito 3 en la posición del cursor del display');
gettext('Número constante a  \nsacar por el display');
gettext('03-Digito-aleatorio');
gettext('### Ejemplo 3: Mostrar un dígito \"aleatorio\" al apretar el pulsador\n\nCada vez que se aprieta SW1 se muestra un dígito entre 0 y 9 en el display,  \nque proviene de un contador módulo 10 que está incrementándose a la frecuencia  \nde 1Mhz');
gettext('**Contador**');
gettext('Los 4 bits de mayor  \npeso del dato enviado  \nsiempre están a 0');
gettext('Frecuencia: 1MHz');
gettext('Dígito (0-9)');
gettext('04-Digito-aleatorio-cls');
gettext('### Ejemplo 4: Dígito aleatorio y Borrado de pantalla\n\nCuando se aprieta el pulsador SW1, se muestra un número aleatorio entre  \n0 y 9. Cuando se aprieta SW2 se ejecuta el comando CLS para borrar  \nel display\n\n');
gettext('Número  \n\"aleatorio\"');
gettext('Comando CLS');
gettext('**Codificador**  \n2 a 1');
gettext('Pulsador de CLS');
gettext('1: Botón de CLS  \n0: Botón de datos');
gettext('Pulsador: Sacar  \nun dato');
gettext('Alguno de los dos pulsadores  \nse ha apretado');
gettext('**Multiplexor**');
gettext('08-contador-100-decimas');
gettext('### Ejemplo 8: Contador de 100 décimas\n\nEjemplo de uso del controlador del display de 7 segmentos:  \nContador de 100 décimas, de 0 a 99');
gettext('**Contador de**  \n**décimas**');
gettext('Digitos de mayor peso:  \nlos dos a cero');
gettext('**Contador de**  \n**segundos**');
gettext('**Controlador**  \ndel display SPI');
gettext('Bloque digitos-4');
gettext('Tiempo de una  \ndécima en ms');
gettext('09-minutero-segundero-mm:ss');
gettext('### Ejemplo 9: Minutero y segundero\n\nLlevar la cuenta de los minutos y segundos, empezando desde  \n00:00. Cada medio segundo se cambia el estado de los dos  \npuntos, para mostrar actividad en el reloj. Los segundos se  \nmuestran en los dos dígitos de la derecha, y los minutos en  \nlos dos de la izquierda\n');
gettext('**Unidades**  ');
gettext('**Decenas**');
gettext('Bloque **Time-4**');
gettext('**Unidades**');
gettext('Estado de los  \ndos puntos (:)');
gettext('Cada medio segundo se  \nactualiza el display');
gettext('Cada medio segundo se  \ncambia el estado de  \nlos dos puntos');
gettext('10-contador-hexa-0000-FFFF');
gettext('### Ejemplo 10: Contador hexadecimal con animación\n\nContador de 4 dígitos hexadecimales, que cuenta desde 0000 hasta  \nFFFF. Se incrementa cada décima de segundo. Además se realiza  \nuna animación en los puntos, enviando un valor desplazado un bit  \na la izquierda cada medio segundo\n\nEl brillo del display se controla mediante los pulsadores');
gettext('Bloque **Digitos-4++**');
gettext('Control del brillo del display');
gettext('Animacion de los puntos:  \nDesplazamiento a la izquierda  \ndel bit, cada medio segundo');
gettext('El contador se incrementa  \ncada décima de segundo (100ms)');
gettext('El display se actualiza  \ncada décima de segundo');
gettext('11-secuencia-texto');
gettext('### Ejemplo 11: Texto animado\n\nMostrar una animación con el texto \"HOLA FPGA\"  \nSe usa un contador que recorre una memoria de  \n16 x 32, que contiene en cada posición los  \ncuatro caracteres que se deben mostrar  en  \nel display en cada momento');
gettext('Duración de cada mensaje  \nen la animación');
gettext('Todos los puntos  \ndesactivados');
gettext('12-animacion-segmentos');
gettext('### Ejemplo 12: Animación en los segmentos\n\nEjemplo de una animación usando segmentos individuales  \nSe usan 4 registros de desplazamiento, inicializados con  \ndiferentes valores. Se desplazan hacia la izquierda cada  \n100ms, generando la animación\n');
gettext('Bloque **Segment-4**');
gettext('Desplazar los registros cada 100ms');
gettext('Ejemplo-03-grupo-ocho-leds');
gettext('### Ejemplo 3: Un grupo de 8 LEDs brillando a su máxima intesidad  \n\nSe encienden los ocho leds, del 0 al 7, como si fuesen un único LED  \nSe usa un bloque multiplicador de cables de 8 bits');
gettext('Bit que define el  \nestado del grupo  \nde LEDs');
gettext('**Grupo de 8 LEDs**');
gettext('Bloque multiplicador  \ndel cables:  \n**mult-1-8-bus**');
gettext('Ejemplo-05-grupo-ocho-leds-brillo-bajo');
gettext('### Ejemplo 5: Grupo de 8 LEDs con brillo bajo  \n\nSe enciende un grupo de 8 LEDs con brillo bajo');
gettext('**Niveles de Brillo**  \n0 : Apagado  \n255: Máxima intensidad');
gettext('**Bloque Brillo-LED**');
gettext('Ejemplo-08-degradado-8-LEDs');
gettext('### Ejemplo 8: Degradado en 8 LEDs\n\nColocamos 8 bloques brillo-LED en paralelo para obtener un  \ndegradado de brillo desde 256 hasta 32, en saltos de 32,  \nen los 8 LEDs\n\n');
gettext('Ejemplo-10-Potenciometro-grupo-8-LEDs');
gettext('### Ejemplo 10: Control del brillo con un potenciometro\n\nEl nivel de brillo se establece con un potenciómetro leido a  \ntravés del conversor A/D de la Alhambra-II');
gettext('Brillo-LED');
gettext('Multiplicador  \nde cables');
gettext('Frecuencia de muestreo  \ndel potenciómetro');
gettext('Ejemplo-12-fundido-desvanecimiento-pulsador');
gettext('### Ejemplo 12: Fundido y desvanecimiento con pulsador\n\nMientras el pulsador esté apretado, se realiza un encendido progresivo  \nde los LEDs (fundido). Al cabo de 2 segundo se habrá alcanzado el brillo  \nmáximo. Al soltar el pulsador se realiza un desvanecimiento\n');
gettext('**Transición**');
gettext('Multiplicador de  \ncables');
gettext('**Bloque brillo-gradual**');
gettext('Ejemplo-14-LEDs-pulsantes-grupo-8');
gettext('### Ejemplo 14: Grupo de 8 LEDs pulsantes\n\nEl grupo de 8 LEDs se enciende y apagan progresivamente, con un periodo  \nde 2 segundos. El tiempo de transición es de 500ms');
gettext('**Periodo**');
gettext('Ejemplo-16-LEDs-estela');
gettext('### Ejemplo 16: LEDs con estela\n\nEjemplo del bloque de desvanecimiento (fade-out) para mostrar la estela  \nde dos LEDs. Al apretar los pulsadores, el LED correspondiente se enciende  \ny luego se va desvaneciendo.\n\nEl **primer LED** está conectado al **tic** generado por el **pulsador SW1**. Nos permite  \ncomprobar cómo se visualizan los tics  \n\nEl **segundo LED** está conectado a la **salida de nivel** del pulsador **SW2**. Hasta que  \nno se suelta, no comienza el desvanecimiento\n');
gettext('**tic**');
gettext('**Tiempo de**  \n**desvanecimiento**');
gettext('**Nivel**');
gettext('Bloque fade-out');
gettext('Ejemplo-19-animacion-brillo-ajustable-teclas');
gettext('### Ejemplo 19: Animación con brillo ajustable con pulsadores\n\nSe saca una secuencia por los LEDs, y el brillo se ajusta  \nmediante los dos pulsadores de la Alhambra II\n');
gettext('Envío alternativo de los números  \n0xF0 y 0x0F, a la frecuencia  \nde 2Hz');
gettext('**Bloque Brillo-8**');
gettext('**Bloque Brillo-control**');
gettext('Establecer el nivel de brillo  \ncon dos pulsadores');
gettext('Ejemplo-21-contador-binario-gradual');
gettext('### Ejemplo 21: Contador binarioSegundero con transiciones suaves\n\nSe muestra en los LEDs una cuenta en binario, cada segundo, donde las  \ntransiciones de los bits son suaves');
gettext('**Brillo-gradual-8**');
gettext('Ejemplo-22-segundero-gradual');
gettext('**Display de**  \n**7 segmentos**');
gettext('### Ejemplo 20: Segundero decimal con transiciones suaves\n\nPor el display de 7 segmentos se muestra una cuenta de 0 a 9,  \nincrementándose cada segundo. Las transiciones entre cada dígito son  \nsuaves, apareciendo y desapareciendo segmentos en un tiempo de 400ms');
gettext('**Contador**  ');
gettext('**Decodificador**  \n**BCD a 7 segmentos**');
gettext('**Bloque**  \n**Brillo gradual-7**');
gettext('Ejemplo-23-coche-fantastico');
gettext('### Ejemplo 23: Animación del coche fantástico\n\nAnimación del LED que \"va y viene\", dejando una estela. La longitud  \nde la estela depende de cuánto mayor es el tiempo de desvanecimiento  \ncon respecto al tiempo de paso del LED');
gettext('**Bloque fade-out-8**');
gettext('Animación del  \nLED que va i viene');
gettext('Generación de  \nla estela');
gettext('Ejemplo-24-contador-binario-efimero');
gettext('**fade-out**');
gettext('Retrasar 1 ciclo  \nde reloj el tic');
gettext('Convertir los 8 bits  \ndel número en 8 tics  \nen parlelo');
gettext('Número efímero  \nSólo dura 1 ciclo  \nde reloj');
gettext('### Ejemplo 24: Contador binario de números efímeros\n\nEn los LEDs se muestra una cuenta binaria, que se incrementa cada  \nsegundo. Cada número generado sólo se visualiza durante 400ms y  \nluego se desvanece: es efímero');
gettext('Ejemplo-25-contador-decimal-efimero');
gettext('### Ejemplo 25: Contador decimal efímero\n\nPor el display de 7 segmentos se muestra una cuenta de 0 a 9,  \nincrementándose cada segundo. Cada número mostrado sólo dura 400ms.  \nUna vez que se visualiza se va desvaneciendo poco a poco hasta  \ndesaparecer');
gettext('Convertir los 7 bits  \ndel número en 7 tics  \nen parlelo');
gettext('**fade-out-7**');
gettext('Test');
gettext('test-memory-128B-str');
gettext('Serial transmiter for the stdout bus');
gettext('stdout bus splitter into data and tic signals');
gettext('Convert the 1-bit next signal into a 10-bit stdout bus');
gettext('Transmit one character to the STDOUT bus');
gettext('Extract the next signal from the stdout bus');
gettext('stdout bus joiner (data + tic)');
gettext('## Test Memory-128B-str\n\nThe 64-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('**START HERE**');
gettext('**Count machine**');
gettext('It address the memory,  \nsending the two addresses  \n(0/1)');
gettext('Synchronize the tic  \nwith the data from the  \nmemory (The reading is  \nsynchronous)');
gettext('### STDOUT management');
gettext('**New Line**');
gettext('Send the current byte  \nto the serial port');
gettext('REMEMBER:  \nThe memory changes the last  \ncharacter by '\\0'');
gettext('Show the current  \nvalue on the LEDs');
gettext('## STDOUT serial\n\nSerial transmitter for the STDOUT bus\n');
gettext('**STDOUT Bus**  \n* Data to transmit (8 bits)  \n* tic (1 bit)\n* data sent (done tic, 1 bit)');
gettext('## PUTC: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification    \n\nWhen the machine starts, the char is outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The byte from the  \ninput char is transmited');
gettext('Char to be transmited');
gettext('State of the machine:  \n1: ON: transmitting  \n2: OFF: transparent mode  ');
gettext('If the machine is on  \nand the character has been  \ntransmitted: Turn it off');
gettext('The machine has finished');
gettext('**STDOUT BUS**');
gettext('Not connected');
gettext('**Create the bus**  \nfrom the data and tic signals');
gettext('Transparent mode...  \nor not');
gettext('test-memory-128B');
gettext('## Test Memory-128B\n\nThe 128-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-16B-str');
gettext('## Test Memory-16B-str\n\nThe 16-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-16B');
gettext('## Test Memory-16B\n\nThe 16-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-256B-str');
gettext('## Test Memory-256B-str\n\nThe 256-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-256B');
gettext('## Test Memory-256B\n\nThe 256-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-2B-str');
gettext('## Test Memory-2B-str\n\nThe 2-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-2B');
gettext('## Test Memory-2B\n\nThe 2-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-32B-str');
gettext('## Test Memory-32B-str\n\nThe 32-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-32B');
gettext('## Test Memory-32B\n\nThe 32-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-4B-str');
gettext('## Test Memory-4B-str\n\nThe 2-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-4B');
gettext('## Test Memory-4B\n\nThe 4-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-64B-str');
gettext('## Test Memory-64B-str\n\nThe 64-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-64B');
gettext('## Test Memory-64B\n\nThe 64-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-8B-str');
gettext('## Test Memory-8B-str\n\nThe 8-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-8B');
gettext('## Test Memory-8B\n\nThe 8-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('01-Brillo-LED-pulsador-2bits');
gettext('**Valor de la anchura**  \n');
gettext('## Ejemplo 1. PWM: Cuatro niveles de Brillo en LED, con pulsador\n\nGeneración de una **señal PWM** de **4 niveles**: 0, 25%, 50%, 75% a frecuencia máxima (sin prescalado)  \nCon el pulsador se cambia de un nivel a otro, y se vuelve al comienzo. El nivel actual se muestra  \nen los LEDs 1 y 0\n\nEl contador principal es de **4 bits**, por lo que la **frecuencia** del PWM es de **3MHz**');
gettext('**Incrementar brillo**');
gettext('**Nivel actual**');
gettext('Mostrar el nivel en  \nlos LEDs (en binario)');
gettext('**Unidad de PWM**');
gettext('Incrementar contador con  \ncada pulsación');
gettext('Usar el tic del pulsador  \npara establecer el nuevo nivel  \n(en el siguiente ciclo de reloj)');
gettext('## Montaje\n\n![Esquema del montaje](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-02.png)');
gettext('\n* **Nivel 1**: \n  * 100 muestras\n  * Freq. muestreo: 24MHz\n  * \n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-03.png)');
gettext('## Mediciones\n');
gettext('* **Todos lo niveles**, medidos por separado y agrupados  \ny agrupados en una única figura\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-04.png)');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=SfixjIhfQ2c)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/SfixjIhfQ2c/0.jpg)](https://www.youtube.com/watch?v=SfixjIhfQ2c)');
gettext('02-Brillo-LED-pulsadores-4bits');
gettext('**16 Niveles:**  \n**0**: No hay PWM  \n**15**: 93.75%  \n');
gettext('## Ejemplo 2. PWM: 16 niveles de brillo en LED, con prescalado\n\nSeñal **PWM de 16** niveles: 0, 6.2% ... 93.75% y frecuencia de **91.5 Hz**  \n(Prescalado de 13 bits) para controlar el brillo de un LED con **dos pulsadores**,  \nuno para incrementar el brillo y otro para disminuirlo. El nivel de brillo actual  \nse muestra en los **LEDs 3-0** (4 bits). El LED controlado es el **LED 7**');
gettext('**Decrementar brillo**');
gettext('Contador con  \nincremento/decremento');
gettext('Introducir como parámetro  \nlos bits de prescalado');
gettext('## Montaje\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT1-PWM-LED/ej4-06.png)');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=FaMuqZrrD1Y)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/FaMuqZrrD1Y/0.jpg)](https://www.youtube.com/watch?v=FaMuqZrrD1Y)');
gettext('## Mediciones\n\n');
gettext('* **Medición niveles 4, 10 y 15**: Se han tomado por separado y juntado en esta figura\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-07.png)');
gettext('* **Medición nivel 1:** (PWM 6.25%): 2M muestras. Frecuencia muestreo: 24MHz \n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-06.png)');
gettext('03-Brillo-LEDs-pot-8bits');
gettext('**Frecuencia de lectura**  \n**del potenciómetro**');
gettext('## Ejemplo 3: 256 niveles de brillo en LEDs, con potenciómetro\n\nSe usa una unidad PWM de 46.9KHz y 8bits para variar la intesidad de los  \n8 LEDs de la Icezim Alhambra a la vez. Hay 256 niveles de intesidad');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=ln9it85tJiM)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ln9it85tJiM/0.jpg)](https://www.youtube.com/watch?v=ln9it85tJiM)');
gettext('**Para medir**');
gettext('## Mediciones');
gettext('* **Medición nivel 1**: (PWM 0.39%): 5K muestras. Frecuencia muestreo: 24MHz \n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-10.png)');
gettext('* **Medición de tres anchuras**: Se han medido por separado y juntado en esta figura\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-11.png)');
gettext('## Montaje\n\n* **Elementos**: **Potenciómetro** y **analizador lógico** para hacer las medicicones\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-09.png)');
gettext('04-Brillo-LEDs-serial-8bits');
gettext('**Receptor serie**\n');
gettext('Valor del brillo  \n(0-255)');
gettext('## Ejemplo 4: Servidor hardware de 256 niveles de brillo en LEDs\n\nEjemplo de control del brillo de los 8 LEDs (a la vez) con una unidad  \nde PWM de 46.8Hz a través del puero serie. El valor recibido (0-255)  \ndetermina el nivel de intensidad de brillo.');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=Im8lueRn09U)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/Im8lueRn09U/0.jpg)](https://www.youtube.com/watch?v=Im8lueRn09U)');
gettext('02-pin-entrada-test-2');
gettext('Pin de entrada  \n(Configurado manualmente)');
gettext('**Bloque InOut**');
gettext('Configurar  \ncomo entrada');
gettext('Entrada dout  \nno conectada');
gettext('## Ejemplo: Configuración manual de un pin de entrada\n\nEjemplo de uso del bloque InOut para configurar manualmente el pin D13  \ncomo entrada. El ejemplo simplemente captura un 1 en un biestable y  \nlo muestra en LED0 cuando se aprieta un pulsador externo conectado a D13');
gettext('04-pin-salida-test-2');
gettext('Pin de salida  \n(Configurado manualmente)');
gettext('**LED Externo**');
gettext('No usado');
gettext('Habilitar salida');
gettext('Los bits del corazón  \nsalen por D13');
gettext('**Bloque InOut-right**');
gettext('## Ejemplo: Configuración manual de un pin de salida\n\nEjemplo de uso del bloque InOut para configurar manualmente el pin D13  \ncomo salida. El ejemplo hace parpadear un LED externo conectado a  \nD13');
gettext('05-inout-test-02');
gettext('Circuito de  \nsalida');
gettext('Configuración manual  \ndel pin de entrada/salida  \nmediante un switch externo  \n**0**: Entrada  \n**1**: Salida');
gettext('Circuito de entrada');
gettext('**Pin de entrada/Salida**');
gettext('LED interno para comprobar  \nque la entrada funciona');
gettext('## Ejemplo: Configuración de un pin para entrada/salida\n\nEl pin D13 se configura como entrada o salida mediante un interruptor  \nexterno. Cuando se configura como salida se emite una señal cuadrada  \npara hacer parpadear un LED externo. Cuando se configur como entrada  \nse emite un pulso al apretar el pulsador y se enciende el LED7');
gettext('06-inout-test-03');
gettext('Cuando es un pin de salida  \nse deshabilita la entrada');
gettext('Si el pin es de salida,  \nal circuito de entrada  \nle llega siempre 0  \nSi el pin es de entrada  \nllega lo que haya por  \nla entrada');
gettext('## Ejemplo: Configuración de un pin para entrada/salida. Versión 2\n\nEl pin D13 se configura como entrada o salida mediante un interruptor  \nexterno. Cuando se configura como salida se emite una señal cuadrada  \npara hacer parpadear un LED externo. Cuando se configur como entrada  \nse emite un pulso al apretar el pulsador y se enciende el LED7  \n\nCuando el pin está configurado como salida, al circuito de entrada  \nle llega un 0');
gettext('07-inout-dos-circuitos');
gettext('### CIRCUITO 1  \n\nSegún la configuración del pin D13:\n\n**Entrada**: Saca por LED7 lo recibido  \n**Salida**: Envía señal de 10Hz por pin\n');
gettext('### CIRCUITO 2  \n\nSegún la configuración del pin D13:\n\n**Entrada**: Saca por LED7 lo recibido  \n**Salida**: Envía señal de 4Hz por pin\n');
gettext('**Establecer sentido**  \n**de la comunicación**  \n1: Circuito 1 ---> Circuito 2  \n0: Circuito 2 ---> Circuito 1  ');
gettext('## Ejemplo: Pin bidireccional entre dos circuitos\n\nComunicación entre dos circuitos usando un cable externo.  \nMediante un interruptor externo se configura el sentido de  \nla comunicación: del circuito 1 al 2 ó del 2 al 1\n\n');
gettext('Tres-clicks');
gettext('Cambiar de estado el LED  \nal hacer \"click\" en el pulsador');
gettext('Cambiar de estado el LED  \nal hacer \"doble click\" en el pulsador');
gettext('Cambiar de estado el LED  \nal dejar apretado el pulsador  \nmás de 1 segundo');
gettext('Tiempo máximo para considerarlo  \nuna doble click');
gettext('Tiempo mínimo para considerarlo  \nuna pulsación larga  \n(hay que sumarle el tiempo  \ndel doble click)');
gettext('## Pulsador: Ejemplo de 3 clicks diferentes  \n\nSegún el tipo de click empleado, se cambia de estado  \nel led correspondiente: 0, 4 ó 7\n\n* Click normal\n* Doble click  \n* Pulsación larga');
gettext('SPI-master');
gettext('SPI-slave');
gettext('Icestick');
gettext('Icezum-alhambra');
gettext('01-2-spi-master-constant');
gettext('### Ejemplo 1-2: Enviando una constante por SPI al esclavo\n\nEjemplo de envío de un dato desde el maestro al esclavo. Al apretar el  \npulsador se envía la constante por el spi. Tanto el maestro como el  \nesclavo se encuentra en la misma FPGA, pero son circuitos independientes');
gettext('**Bloque**  \n**spi-master-mode0-2MHz**');
gettext('# MAESTRO');
gettext('# ESCLAVO');
gettext('<-- Cable externo -->');
gettext('<-- Cable externo');
gettext('Cable externo-->');
gettext('### Cables externos necesarios: 4\n\n| Señal SPI | Pin Maestro | Pin Esclavo | Descripción |\n|-----------|-------------|-------------|-------------|\n|  SCLK     |  D13        |   D3        | Reloj       |\n|  MISO     |  D12        |   D2        | Datos Esclavo --> Maestro |\n|  MOSI     |  D11        |   D1        | Datos Maestro --> Esclavo |\n|  SS       |  D0         |   D0        | Selección de esclavo      |');
gettext('## SPI Maestro. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ\n\nBloque maestro de SPI');
gettext('02-spi-master-lectura-id');
gettext('### Ejemplo 2: Enviando una constante por SPI al esclavo\n\nEjemplo de recepción de datos desde el esclavo al maestro. Se realiza la  \nlectura del esclavo cada 100ms. Devuelve el identificador (0xA5)  \n, que el maestro captura en un registro y lo saca por los leds  \nComo es un valor constante, no se aprecia cambio en los LEDs  \n(pero al conectar el analizador se observa el trasiego de datos)\n');
gettext('**Registro**');
gettext('Identificador que  \nse envía al maestro');
gettext('03-spi-master-lectura-escritura');
gettext('## Ejemplo 3: Envío y recepción por el SPI\n\nCada 100ms se realiza una transacción: Se lee el identificador  \ndel periférico del SPI (valor constante 0xA5) y se envía el valor  \nde un contador que se incrementa también cada 100ms\n\nPor los LEDs vemos los valores del contaddor recibidos en el esclavo,  \n(al apretar el botón 1), o bien el identificador recibido en el  \nmaestro (apretar botón 2).\n');
gettext('# MAESTRO\n\nCada 100ms se envía el valor del contador al  \nesclavo y se incrementa');
gettext('Mostrar por los LEDs bien los datos  \nrecibidos por el esclavo (pulsador 1) o  \nbien los datos recibidos por el maestro  \n(pulsador 2)');
gettext('Ver el maestro');
gettext('Ver el esclavo');
gettext('Se realiza una transacción  \ncada 100ms');
gettext('04-spi-master-medidas');
gettext('## Ejemplo 4: Medidas\n\nCircuito para realizar medidas del SPI con el analizador lógico  \nLos 4 primeros canales se conectan a D0, D1, D2 y D3 para mostrar las  \nseñales SS, MOSI, MISO y SCLK\n\nSe usan dos canales adicionales conectados a D4 y D5 para mostrar las  \nseñales de busy y done');
gettext('# MAESTRO\n\nSe envían los valores 0xAA y 0x55 alternativamente  \nal esclavo, para que los muestre en sus LEDs');
gettext('Se realiza una transacción  \ncada 300ms');
gettext('05-2-serial-spi-echo');
gettext('## Ejemplo 5-2: Serial-spi: Prueba de eco y LEDs, con el bloque serial-SPI\n\nPasarela Serie-SPI. Todo lo recibido desde el PC por el puerto serie  \nse envía hacia el SPI, y todo lo recibido del SPI se envía hacia  \nel PC por el puerto serie\n');
gettext('# MAESTRO\n');
gettext('06-serial-spi-cmd');
gettext('## Ejemplo 6: Serial-spi: Prueba de comandos, con el bloque serial-SPI\n\nPasarela Serie-SPI. Todo lo recibido desde el PC por el puerto serie  \nse envía hacia el SPI, y todo lo recibido del SPI se envía hacia  \nel PC por el puerto serie\n');
gettext('07-serial-spi-regs');
gettext('## Ejemplo 7: Serial-spi: Prueba de registros, con el bloque serial-SPI\n\nPasarela Serie-SPI. Todo lo recibido desde el PC por el puerto serie  \nse envía hacia el SPI, y todo lo recibido del SPI se envía hacia  \nel PC por el puerto serie\n');
gettext('08-1-serial-spi-flash-memory');
gettext('## Ejemplo 8-1: Acceso a la memoria flash SPI\n\nEjemplo de prueba de la memoria flash SPI desde la placa **Alhambra II**.  \nUsamos el bloque serial-spi para enviar los comandos desde el PC y  \ncomprobar su funcionamiento\n\n');
gettext('09-serial-spi-cap1188');
gettext('## Ejemplo 9: Pruebas del sensor capacitivo CAP1188 desde el PC\n\nUsamos el bloque Serial-SPI como maestro para envair comandos desde el PC  \nal esclavo CAP1188 situado fuera de la placa, conectado por los pines  \ndel SPI\n\n\n');
gettext('08-3-serial-spi-flash-memory-Icestick');
gettext('## Ejemplo 8-3: Acceso a la memoria flash SPI\n\nEjemplo de prueba de la memoria flash SPI desde la placa **Icestick**.  \nUsamos el bloque serial-spi para enviar los comandos desde el PC y  \ncomprobar su funcionamiento\n\n');
gettext('08-2-serial-spi-flash-memory-Icezum-Alhambra');
gettext('## Ejemplo 8-2: Acceso a la memoria flash SPI\n\nEjemplo de prueba de la memoria flash SPI desde la placa **Icezum Alhambra**.  \nUsamos el bloque serial-spi para enviar los comandos desde el PC y  \ncomprobar su funcionamiento\n\n');
gettext('SPI-test');
gettext('icezum-Alhambra');
gettext('01-SPI-LEDs-mode0');
gettext('### Ejemplo 1: Mostrando en los LEDs el dato recibido\n\nEjemplo de un circuito esclavo por SPI, que simplemente saca por los  \nLEDs los bytes recibidos');
gettext('02-SPI-LEDs-regs');
gettext('### Ejemplo 2: Registrando el dato recibido\n\nEjemplo de un circuito esclavo por SPI, que almacena el dato recibido  \nen un registro. Además se saca por los LEDs usando un efecto de  \ntransición suave');
gettext('Se carga con el dato recibido  \nusando el tic rcv');
gettext('**Brillo gradual**');
gettext('03-SPI-Pulsadores');
gettext('### Ejemplo 3: Transmitiendo al maestro\n\nEl estado de los pulsadores SW1 y SW2 se envía al maestro. Se sitúan  \nen los dos bits de menor peso del byte enviado. El resto de bits se  \nponen a 0');
gettext('Comienza una transacción  \nnueva');
gettext('Cargar el byte a enviar  \ncada vez que hay una  \ntransacción nueva');
gettext('Flanco de bajada');
gettext('04-SPI-send-receive');
gettext('### Ejemplo 4: Envío y recepción\n\nLos bytes recibidos del maestro se muestran por los LEDs  \nCada dato recibido se incrementa en 1 y se devuelve como  \nrespuesta en la siguiente transacción\n');
gettext('Dato recibido');
gettext('Dato recibido  \nincrementado');
gettext('El dato incrementado  \nse carga cuando ha  \nterminar la transacción  \nactual');
gettext('06-2-SPI-WRITE-LEDs');
gettext('### Ejemplo 6-2: Comando WRITE_LEDS\n\nImplementación del comando WRITE_LEDs usando el bloque sintáctico  \ncmd8-value8, que detecta el patron de código del comando write_leds y  \nsu valor');
gettext('**Registro LEDs**  \nContiene el valor que  \nse muestra en los LEDs');
gettext('**Comando**  \n**WRITE_LEDS**');
gettext('Valor recibido tras  \nel código de comando');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |');
gettext('**Bloque cmd8**');
gettext('07-2-SPI-WRITE-Brillo-LEDs');
gettext('### Ejemplo 7: Comandos WRITE_LEDs y Brillo-LEDs\n\nPeriférico por el SPI con dos comandos: WRITE_LEDS para escribir un  \nvalor por los LEDs y BRILLO_LEDS para establecer su brillo. Ambos  \ncomandos se han implementado con el bloque sintáctico cmd8\n');
gettext('**Brillo-8**');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **BRILLO_LEDS** *val* | 0x50       | Establecer el brillo de los LEDs   |');
gettext('### Comando BRILLO_LEDS');
gettext('Valor inicial para  \nel brillo: máximo');
gettext('**Registro**  \n**de Brillo**  ');
gettext('09-SPI-READ_buttons');
gettext('### Ejemplo 9: Comando READ_Buttons\n\nImplementación de 3 comandos: Dos para escribir en los LEDs y  \nmodificar su brillo. Un tercero para leer el estado de los pulsadores');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **BRILLO_LEDS** *val* | 0x50       | Establecer el brillo de los LEDs   |\n| **READ_BUTTONS**      | 0x60       | Lectura de los pulsadores          |');
gettext('10-SPI-READ_ID');
gettext('### Ejemplo 10: Comando READ_ID\n\nImplementación de 4 comandos: Dos de escritura, y dos de lectura');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **BRILLO_LEDS** *val* | 0x50       | Establecer el brillo de los LEDs   |\n| **READ_BUTTONS**      | 0x60       | Lectura de los pulsadores          |\n| **READ_ID**           | 0x70       | Lectura del identificador del chip |');
gettext('### Comando READ_ID');
gettext('Tic de lectura del  \nidentificador del chip');
gettext('**codificador**  \n2 a 1');
gettext('Se activa cuando se ha activado  \nalguno de los dos comandos');
gettext('Código del esclavo');
gettext('Número correspondiente al  \ncomando de lectura recibido:  \n0: READ_ID  \n1: READ_BUTTONs  ');
gettext('11-3-SPI-REG-LEDs');
gettext('# Ejemplo 11-3: Registro de LEDs con bloque reg-addr\n\nPeriférico para el SPI que tiene mapeado un registro de LEDs, de lectura y escritura. \nSe accede al registro a través de la dirección 0x10, que se debe depositar primero en el  \nregistro de dirección con el comando SAP');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |');
gettext('**Lectura del registro**:  \nSi está su dirección en el registro  \nde dirección, se devuelve su valor  \nde lo contrario se devuelve 0');
gettext('Valor a enviar al maestro  \nen la lectura');
gettext('Registro de LEDS  \nseleccioando');
gettext('12-serial-reg-LEDs');
gettext('# Ejemplo 12: Registro de LEDs por puerto serie\n\nEl registro de LEDs está mapeado en memoria, y es accesible a través de los comandos SAP,  \nWrite y RD recibidos por el puerto serie\n\n');
gettext('## COMANDOS\n\n| Comando | Abrev. | Código | Descripción |\n|---------|-------------|----------------|-------------|\n| **SET ADDRES POINTER ** *val* | SAP  | \"S\"       | Establecer el valor del registro de dirección |\n| **WRITE REGISTER** *val*      | WR   | \"W\"       | Escribir en el registro apuntado por el registro de dirección |\n| **READ REGISTER**             | RD   | \"R\"       | Leer el registro apuntado por el registro de dirección |\n\n');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| \"1\"  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |');
gettext('**Lectura del registro**:  \nSi está su dirección en el registro  \nde dirección, se devuelve su valor  \nde lo contrario se devuelve el  \ncarácter \"-\"');
gettext('**Receptor serie**');
gettext('**BUS de**  \n**Direcciones**');
gettext('**BUS de**  \n**Datos**');
gettext('**BUS de**  \n**control**');
gettext('**Bus de datos**  \n**de salida**');
gettext('13-SPI-dos-registros-mapeados');
gettext('# Ejemplo 13: Dos registros mapeados\n\nPeriférico SPI que tiene mapeados dos registros: uno para escribir en los LEDs y otro para cambiar  \nel nivel de brillo. Ambos registros son de lectura y escritura');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| 11h  | R/W   |  BRILLO  | Nivel de brillo de los LEDs | 255 |\n');
gettext('### Registro de BRILLO');
gettext('**Bloque Brillo**');
gettext('Codificador  \nde 2 a 1');
gettext('14-SPI-cuatro-registros-mapeados');
gettext('# Ejemplo 14: Cuatro registros mapeados\n\nPeriférico SPI que tiene mapeados cuatro registros: Dos de lectura/escritura para establecer  \nel valor de los LEDs y su brillo. Y dos de sólo lectura. Uno con el identificador del  \nperiférico y otro con el valor de los pusaldores');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| 11h  | R/W   |  BRILLO  | Nivel de brillo de los LEDs | 255 |\n| 12h  | R     |  PULSADORES | Estado de los pulsadores SW1 y SW2 | 00h |\n| FDh  | R     |  ID | Código de identificación del periférico | 50h |\n');
gettext('15-Serial-cuatro-registros-mapeados');
gettext('# Ejemplo 15: Cuatro registros mapeados. Puerto serie\n\nPeriférico por puerto serie que tiene mapeados cuatro registros: Dos de lectura/escritura para establecer  \nel valor de los LEDs y su brillo. Y dos de sólo lectura. Uno con el identificador del  \nperiférico y otro con el valor de los pusaldores');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| \"1\"  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| \"2\"  | R/W   |  BRILLO  | Nivel de brillo de los LEDs | 255 |\n| \"3\"  | R     |  PULSADORES | Estado de los pulsadores SW1 y SW2 | \"0\" |\n| \"I\"  | R     |  ID | Código de identificación del periférico | \"A\" |\n');
gettext('Construir el byte a transmitir  \nal maestro: 001100xx  \nLos dos de menos peso son\nSW1 y SW2 ');
gettext('16-SPI-mini-VGA');
gettext('**HS**');
gettext('**VS**');
gettext('**Conexión con AP-VGA**');
gettext('**Sincronismo**');
gettext('## Ejemplo 16: Mini-controlador VGA por SPI\n\nEste periférico tiene mapeado un único registro:  \nVGALEDs. Sus dos bits de menor peso representan la  \nmitad izquierda y derecha de la pantalla de la VGA');
gettext('**VGALEDs**');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  VGALED |  Estado de las dos mitades de la pantalla VGA | 03h |');
gettext('### Registro VGALED');
gettext('00-1-spi-slave-test-id');
gettext('# Ejemplo 0-1: Probando el bloque spi-slave-test-id\n\nTodo lo recibido por el spi se saca por los LEDs. En cada transacción se  \ndevuelve el valor constante 0xA5  ');
gettext('### Código de prueba para Arduino');
gettext('00-2-spi-slave-test-eco');
gettext('# Ejemplo 0-2: Probando el bloque spi-slave-test-echo\n\nTodo lo recibido por el spi se saca por los LEDs y se almacena para  \nenviarlo de vuelta en la siguiente transacción (eco)  ');
gettext('00-3-spi-slave-test-cmd');
gettext('# Ejemplo 0-3: Probando el bloque spi-slave-test-cmd\n\nCon el comando Write_LED se saca un valor en los leds.  Con el comando Read_buttons  \nse devuelve el estado de los pulsadores');
gettext('Con los parámetros se establecen los códigos  \nde los comandos. Por defecto son 0x40 y 0x60');
gettext('00-4-spi-slave-test-regs');
gettext('# Ejemplo 0-4: Probando el bloque spi-slave-test-regs\n\nImplementa tres registros mapeados: leds, buttons e id, accesibles mediante los comandos  \nSAP, WR y RD');
gettext('Con los parámetros se establecen los códigos  \nde los comandos, sus direcciones y el ID');
gettext('18-SPI-Icezum-Alhambra-cuatro-registros-mapeados');
gettext('# Ejemplo 18: Icezum Alhambra: Cuatro registros mapeados\n\nPeriférico SPI que tiene mapeados cuatro registros: Dos de lectura/escritura para establecer  \nel valor de los LEDs y su brillo. Y dos de sólo lectura. Uno con el identificador del  \nperiférico y otro con el valor de los pusaldores');
gettext('01-Key-test');
gettext('## Ejemplo 1\n\nLectura de una tecla aislada esando el **bloque key**  \nSe emiten dos pitidos, uno al pulsar y otro al soltar\n\n[Más información](https://github.com/Obijuan/FPGA-keyboard/wiki/Teclado-num%C3%A9rico-USB-Jelly-Comb)');
gettext('Mostrar por el LED  \nel estado de la tecla');
gettext('Pitido grave  \nPulsación');
gettext('Pitido agudo  \nLiberación');
gettext('Lectura de  \nTecla');
gettext('**Conexión de la tecla Backspace**  \nTeclado Jelly\n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-usb-26.png)');
gettext('### Escenario\n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/tecla-backspace-06.png)');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/YQmEWZz1FUs/0.jpg)](https://www.youtube.com/watch?v=YQmEWZz1FUs)');
gettext('02-Jelly-kbd-test1');
gettext('**Ejemplo 2**: Prueba del teclado matricial Jelly  \nCuando se aprieta una tecla se muestra su código de tecla en  \nlos LEDs y se emite un pitido  \nAl soltar la tecla se emite otro pitido más agudo  \nEl estado actual de la tecla (0 sin apretar, 1 pulsada)  \nse muestra en un LED externo\n\n[MÁS INFORMACIÓN](https://github.com/Obijuan/FPGA-keyboard/wiki/Teclado-num%C3%A9rico-USB-Jelly-Comb)');
gettext('Mostrar estado de la  \ntecla en el LED');
gettext('Emitir un **pitido** con la  \npulsación de cada tecla');
gettext('Emitir un **pitido** con la  \nliberación de cada tecla  \n(Pitido más agudo)');
gettext('### CONEXIONADO\n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-Alhambra-II.png)');
gettext('![](https://github.com/Obijuan/FPGA-keyboard/raw/master/wiki/jelly-keyboard/jelly-02.png)');
gettext('**C19**');
gettext('**C18**');
gettext('**C17**');
gettext('**C8**');
gettext('**C9**');
gettext('### ESCENARIO \n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/key-matrix-04.png)');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ns8h2Tpm9Ns/0.jpg)](https://www.youtube.com/watch?v=ns8h2Tpm9Ns)\n');
gettext('03-Jelly-kbd-seleccion');
gettext('**Ejemplo 3**: Selección de canales  \n* Modo 1: Selección del canal apretando la tecla numérica correspondiente (NumLoc no activo)\n* Modo 2: Selección del canal mediante las flechas y la tecla ENTER (Numlock activado)');
gettext('Estado de **Numlock**:  \n0: No activado  \n1: Activado');
gettext('Sacar NumLock  \npor el LED');
gettext('Tecla 8 pulsada');
gettext('Tecla 2 pulsada');
gettext('NumLock');
gettext('Flecha  \narriba');
gettext('Flecha  \nabajo');
gettext('Contador  \nascendente/  \ndescendente');
gettext('Decodificador  \nde 3 a 8');
gettext('Numero seleccionado  \npor las flechas');
gettext('Tecla Enter');
gettext('Es Tecla 0 - 9');
gettext('Numero seleccionado  \npor tecla');
gettext('Canal seleccionado');
gettext('Pitidi agudo emitido  \nal seleccionar canal  \npor cualquier modo');
gettext('Emitir pitido grave  \nal mover alguna de las  \nflechas');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/OSDUV2FAFMs/0.jpg)](https://www.youtube.com/watch?v=OSDUV2FAFMs)');
gettext('04-Jelly-kbd-calculator');
gettext('Suma de operandos');
gettext('RESET');
gettext('Con la tecla de backspace se  \ninicializan todos los registros  \npara volver al estado inicial');
gettext('Los datos llegan  \nen serie');
gettext('Registro de  \ndato');
gettext('Registro de dato');
gettext('Resultado');
gettext('Selección de qué sacar por  \nel display: resultado u operando');
gettext('Display de 7 segmentos');
gettext('kdown');
gettext('Es el primer o segundo  \ndígito tecleado');
gettext('Tecla de sumar');
gettext('Es la tercera tecla  \napretada');
gettext('Tecla valida pulsada');
gettext('Contador');
gettext('Cuando no hay teclas validas  \npulsadas se muestra el resultado');
gettext('Sonido para teclas  \nBackspace y +  \nagudo');
gettext('Sonido para teclas  \nnuméricas: grave');
gettext('La tercera tecla pulsada es +');
gettext('La primera tecla pulsada  \no la segunda son digitos');
gettext('**Aplicación 2**: Calculadora de un dígito. Se hacen sumas de números de un dígito, en notación  \npolaca inversa. Ej: se pulsa 2, después 3 y depués +: se muestra 5 en el display  \nSólo se aceptan las teclas correctas en el momento adecuado Así, al comenzar, sólo se aceptarán dígitos  \nDespues de introducir los dos primeros dígitos, sólo se acepta la tecla +. Si se aprieta cualquier otra  \nse ignora.  \nCon la tecla backspace se hace un reset y se vuelve al estado inicial en cualquier momento');
gettext('### VIDEO 1\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ia5OGJ10mm0/0.jpg)](https://www.youtube.com/watch?v=ia5OGJ10mm0)\n');
gettext('### VIDEO 2: Marcha imperial\n\n[![Click to see the youtube video](http://img.youtube.com/vi/cT7DrgvBubo/0.jpg)](https://www.youtube.com/watch?v=cT7DrgvBubo)\n');
gettext('05-Jelly-kbd-control-acceso');
gettext('**Aplicación 4**: Control de acceso  \nCuando se introduce la contraseña correcta de 4 dígitos, se abre la  \npuerta. Con la tecla Backspace se hace reset y se vuelve a cerrar  \nCuando la puerta está abierta, las teclas se deshabilitan\n');
gettext('Es tecla 0-9  ');
gettext('Mostrar la tecla en el  \ndisplay');
gettext('Estado de la caja:  \n0: Cerrada  \n1: Abierta');
gettext('**RESET**');
gettext('Contador de dígitos');
gettext('Dígito 2');
gettext('Dígito 3');
gettext('Dígito 4');
gettext('úLtimo digito introducido');
gettext('Clave  \ncorrecta');
gettext('Mostrar en el display  \nel último dígito que se  \npulsado');
gettext('Sonido para  \nlos dígitos');
gettext('Sonido para  \nla tecla backspace');
gettext('Dígito apretado  \ny caja cerrada');
gettext('Código de tecla  \nde 4 bits');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/CulgcF5UY2k/0.jpg)](https://www.youtube.com/watch?v=CulgcF5UY2k)');
gettext('06-Jelly-kbd-consola-serie');
gettext('**Aplicación 5**: Consola serie  \nAl apretar las teclas se envían caracteres ASCII por el puerto  \nserie al PC. Con el numlock apretados se obtienen letras\n');
gettext('Display de 7  \nsegmentos');
gettext('Estado del NumLock');
gettext('Según la tecla pulsada y  \nel estado del Numlock se  \nobtiene de la tabla una  \nnota u otra');
gettext('Cualquier tecla apretada  \nsalvo NuLock');
gettext('Envío del carácter  \nASCII por el puerto  \nserie');
gettext('### VIDEO \n\n[![Click to see the youtube video](http://img.youtube.com/vi/xTKSQj8sTTI/0.jpg)](https://www.youtube.com/watch?v=xTKSQj8sTTI)');
gettext('01-Led-on');
gettext('### Prueba Hola-mundo\n\nComprobar que el circuito se carga  \ncorrectamente en la FPGA  \nSe enciende el LED 0');
gettext('02-Serial-eco');
gettext('### Prueba del puerto serie\n\nSe hace ECO de todo lo recibido  \nVelocidad: 115200 baudios  \nLo recibido se saca por los LEDs también');
gettext('VGA-retro');
gettext('Icezum-Alhambra');
gettext('00-Plantilla');
gettext('HS (HORIZONTAL)  ');
gettext('## Plantilla\n\nPlantilla con los elementos necesarios para  \nempezar nuestros proyectos VGA-RETRO  \nConfigurado para la placa **AP-VGA** en una **Alhambra-II**');
gettext('**Bit del canal verde**:  \n0: Pixel negro (apagado)  \n1: Pixel verde (Máxima intensidad)');
gettext('**Canales Azul y Rojo desactivados**');
gettext('01-Test-and-Adjust-VGA');
gettext('## CONEXIONADO (Alhambra-II)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT2-VGA-Retro-I/AP-vga-08.png)');
gettext('## IMAGEN\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/test-vga-03.png)');
gettext('### FUNCIONAMIENTO\n\nPrueba en un monitor real\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT2-VGA-Retro-I/test-vga-02.png)');
gettext('## Ejemplo 1: Prueba de funcionamiento VGA\n\n* Placa Alhmabra-II con la AP-VGA\n* Conectar al monitor VGA\n* Comprobar que se la imagen correcta, con los colores correctos\n* Asegurarse de que el marco azul se ve completo');
gettext('Bloque de prueba:  \nTest-FPGAwars');
gettext('### Señales VGA');
gettext('02-Fondo-verde');
gettext('## Ejemplo 2: Fondo verde\n\nTodos los píxeles de la zona visible se activan, por lo que  \nveremos el fondo de esta zona de **color verde**. Simplemente hay  \nque conectar la salida *visible* del bloque SYNC con el **bit del  \ncanal verde**');
gettext('Mientras el haz esté en la  \nzona visible, activar los  \npixeles del canal verde');
gettext('### ESCENARIO\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT2-VGA-Retro-I/vga-retro-09.jpg)');
gettext('03-Fondo-verde-parpadeo');
gettext('## Ejemplo 3: Fondo verde parpadeante\n\n\nHacer parpadear el fondo de la pantalla (zona visible)  \nConfiguración inicial: Parpadeo a 1Hz  \nSe usa un **biestable** para almacenar el **estado de la pantalla**:  \nencendida o apagada. Según este estado se activa o no el bit  \ndel canal verde. El estado sólo se captura cuando ha terminado  \nde dibujarse el frame actual (Freq de captura de 60Hz)');
gettext('Fondo activo y estamos  \nen zona visible');
gettext('Parpadeo de la pantalla  ');
gettext('04-MonsterLED-blink');
gettext('## Ejemplo 4: MonsterLED parpadeante \n\nHacer parpadear el MonsterLED a 2Hz');
gettext('Salida por  \nnivel');
gettext('**MonsterLED**');
gettext('05-MonsterLED-button');
gettext('## Ejemplo 5: MonsterLED con Pulsador \n\nSe usan dos pulsadores para encender el MonsterLED (y un LED externo)  \n* El pulsado2 no tiene memoria. El monsterLED estará encendido mientras esté pulsado. Al  \nsoltarlo se apagará\n* El pulsador1 tiene memoria. Al apretarlo cambia a un nuevo estado y al soltarlo lo recuerda.   \n  Para recordar está conectado a un biestable de cambio (Tipo T)  \n\nSe emite un pitido corto cada vez que se aprieta uno de los pulsadores');
gettext('Sin memoria');
gettext('Con memoria');
gettext('Biestable T  \n(de cambio)');
gettext('06-MonsterLED-IR');
gettext('## Ejemplo 6: MonsterLED con Infrarrojos \n\nSe usa un sensor de infrarrojos para detectar la aproximación de un objeto  \nCuando se detecta se cambia el estado del MonsterLED  \nSi se pone delante del monitor, permite encenderlo y apagarlo \"con la fuerza\" :-)');
gettext('Sensor de  \ninfrarrojos');
gettext('Objeto  \ndetectado');
gettext('08-Barra-1-ON');
gettext('## Ejemplo 8: Encender la barra 1\n\nEjemplo para poner en Verde la mitad derecha (barra 1) de la zona visible  \nLa mitad izquierda (barra 0) permanece apagada');
gettext('Extraer Bit de mayor  \npeso de hpos  \n');
gettext('**Señal al canal verde VGA**:  \n**0**: Haz está fuera de la barra 1  \n**1**: Haz está en la barra 1\n');
gettext('09-Barra-1-boton');
gettext('## Ejemplo 9: Objeto de vídeo Barra 1\n\nLa pulsación del botón establece el estado de la parte derecha  \nde la zona visible del monitor: encendida o apaga. El efecto es que  \nen vez de la pantalla completa, como sucedía en los ejemplos anteriores  \nsólo se muestra la mitad derecha (Barra 1)');
gettext('**Estado** para el objeto  \nbarra 1:  \n**0**: No visible  \n**1**: Visible');
gettext('Haz en Barra 1 y  \nestá activado');
gettext('**Pulsador** (sin memoria)  \npara establecer el estado  \nde la barra 1');
gettext('Con cada pulsación del  \nbotón se emite un  \npitido  ');
gettext('10-Dos-Barras');
gettext('## Ejemplo 10: Dos barras independientes\n\nSe dibujan dos barras verticales, alternativamente. Inicialmente aparece  \nla barra 1, que es la mitad derecha de la zona visible. Al apretar el  \npulsador se apaga y se enciende la barra 0, que es la mitad izquierda  \nAl soltar el botón se vuelve a la situación inicial    \nLas señales de video de los dos objetos se combinan con una puerta OR\n');
gettext('11-VGALED2-Botones');
gettext('## Ejemplo 11: VGA-LEDs y pulsadores\n\nEncender y apagar los LEDs de la VGA con dos pulsadores  \nCada pulsador controla una mitad de la pantalla. Al apretarlos  \nse enciende el LED correspondiente, y al soltarlo se apaga  \n(pulsadores sin memoria)\n');
gettext('12-VGALED2-Contador');
gettext('## Ejemplo 12: Contador binario en VGA-LEDs\n\nLa salida de un contador de 2 bits se lleva a los LEDs de  \nla VGA para mostrar la cuenta en binario. Mediante un  \nswitch se selecciona la duración: 1 segundo o 1 décima  \nCon cada cuenta se emite un sonido corto');
gettext('Contador de 2 bits');
gettext('Selección de duración:  \n0: una décima de seg  \n1: Un segundo');
gettext('Interruptor de  \nselección');
gettext('Pitido corto,  \nde 20ms');
gettext('13-VGALED2-IR');
gettext('## Ejemplo 13: Sensores de IR en VGALEDs\n\nMostrar el estado de dos sensores de infrarrojos en los  \nVGALEDs. Se emite un pitido corto cuando se activa cada  \nuno de ellos');
gettext('14-VGALED2-Ruleta-IR');
gettext('## Ejemplo 14: Ruleta VGA: Si-NO\n\nNueva versión de la ruleta VGA. Ahora se usan las dos  \nmitades de la pantalla para encontrar la respuesta a  \nnuestras preguntas si-no. Se usa un único sensor de IR  \ncuya salida cambia de estado el biestable T que se  \nconecta al VGALED con una puerta not para que los dos  \n\"LEDs\" se activen alternativamente\n\n');
gettext('**Biestable T**');
gettext('Sólo una de las dos mitades  \nes la que está encendida');
gettext('00-Plantilla');
gettext('## Plantilla\n\nPlantilla con los elementos necesarios para  \nempezar nuestros proyectos VGA-RETRO  \nConfigurado para la placa **AP-VGA** en una **Icezum Alhambra**');
gettext('01-Test-and-Adjust-VGA');
gettext('## CONEXIONADO (Icezum Alhambra)\n\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-01.png)');
gettext('### FUNCIONAMIENTO\n\nPrueba en un monitor real\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-03.jpg)');
gettext('02-Fondo-verde');
gettext('### ESCENARIO\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-01.png)');
gettext('## PRUEBAS DE FUNCIONAMIENTO\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-02.png)');
gettext('03-Fondo-verde-parpadeo');
gettext('04-MonsterLED-blink');
gettext('05-MonsterLED-button');
gettext('06-MonsterLED-IR');
gettext('08-Barra-1-ON');
gettext('09-Barra-1-boton');
gettext('10-Dos-Barras');
gettext('11-VGALED2-Botones');
gettext('12-VGALED2-Contador');
gettext('13-VGALED2-IR');
gettext('14-VGALED2-Ruleta-IR');
