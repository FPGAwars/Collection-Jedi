// Translation document for the collection
// =======================================
// This file contains the texts
// annotated for translation
//
// Instructions:
// 1. Open the PO file with Poedit
// 2. Press "Update" to update from sources

gettext('7Seg');
gettext('ADC');
gettext('Accesorios');
gettext('Accumulators');
gettext('BCD');
gettext('Buffers');
gettext('CRC');
gettext('Encoder');
gettext('I2C');
gettext('IR');
gettext('Keyboard');
gettext('Motor');
gettext('Otros');
gettext('PWM');
gettext('Particulas');
gettext('Pegatinas');
gettext('Perif');
gettext('Prescaler');
gettext('Retardo');
gettext('SPI');
gettext('Servos');
gettext('Sound');
gettext('Syntax');
gettext('Tablas');
gettext('Templates');
gettext('Timers');
gettext('VGA');
gettext('icebot');
gettext('stack');
gettext('Catodo-comun');
gettext('Common-Anode');
gettext('Digitos');
gettext('Letras');
gettext('displayBit');
gettext('DisplayBit. Decodificador de 1 bit a 7 segmentos. Cátodo común');
gettext('displayBit2');
gettext('DisplayBit2. Decodificador de 2 bits a 7 segmentos. Cátodo común');
gettext('displayBit3');
gettext('DisplayBit3. Decodificador de 3 bits a 7 segmentos. Cátodo común');
gettext('displayDEC');
gettext('DisplayDEC. Decodificador BCD a 7 segmentos. Cátodo común');
gettext('displayHEX');
gettext('DisplayHEX. Decodificador de binario a hexadecimal-7 segmentos. Cátodo común');
gettext('0');
gettext('Constante de  7 bits para mostrar el dígito 0 en un display de 7 segmentos');
gettext('Valor genérico constante, de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 1 | 1 | 0 |');
gettext('1');
gettext('Constante de  7 bits para mostrar el dígito 1 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 0 | 0 | 0 | 0 |');
gettext('2');
gettext('Constante de  7 bits para mostrar el dígito 2 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  0| 1 | 1 | 0 | 1 |');
gettext('3');
gettext('Constante de  7 bits para mostrar el dígito 3 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 0 | 0 | 1 |');
gettext('4');
gettext('Constante de  7 bits para mostrar el dígito 4 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 0 | 0 | 1 | 1 |');
gettext('5');
gettext('Constante de  7 bits para mostrar el dígito 5 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  1| 1 | 0 | 1 | 1 |');
gettext('6');
gettext('Constante de  7 bits para mostrar el dígito 6 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  1| 1 | 1 | 1 | 1 |');
gettext('7');
gettext('Constante de  7 bits para mostrar el dígito 7 en un display de 7 segmentos');
gettext('8');
gettext('Constante de  7 bits para mostrar el dígito 8 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 1 | 1 | 1 |');
gettext('9');
gettext('Constante de  7 bits para mostrar el dígito 9 en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 1 | 0 | 1 | 1 |');
gettext('A');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal A en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  1| 0 | 1 | 1 | 1 |');
gettext('B');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal B en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 |  1| 1 | 1 | 1 | 1 |');
gettext('C');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal C en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 1 | 1 | 1 | 0 |');
gettext('D');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal D en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 1 | 1 | 0 | 1 |');
gettext('E');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal E en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 1 | 1 | 1 | 1 |');
gettext('F');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal F en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 0 | 1 | 1 | 1 |');
gettext('G');
gettext('Constante de  7 bits para mostrar la letral G en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 | 1 | 1 | 0 | 1 | 1 |');
gettext('H');
gettext('Constante de  7 bits para mostrar la letra H en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 | 1 | 0 | 1 | 1 | 1 |');
gettext('I');
gettext('Constante de  7 bits para mostrar la letra I en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 0 | 0 | 1 | 1 | 0 |');
gettext('J');
gettext('Constante de  7 bits para mostrar la letra J en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 1 | 1 | 1 | 0 | 0 |');
gettext('L');
gettext('Constante de  7 bits para mostrar la letra L en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 | 1 | 0 |');
gettext('N');
gettext('Constante de  7 bits para mostrar la letra N en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 1 | 0 | 1 | 0 | 1 |');
gettext('NN');
gettext('Constante de  7 bits para mostrar la letra ñ en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 1 | 0 | 1 | 0 | 1 |');
gettext('O');
gettext('Constante de  7 bits para mostrar la letra O en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 1 | 1 | 1 | 0 |');
gettext('P');
gettext('Constante de  7 bits para mostrar la letra P en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 0 | 0 | 1 | 1 | 1 |');
gettext('Q');
gettext('Constante de  7 bits para mostrar la letra Q en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 0 | 0 | 1 | 1 |');
gettext('R');
gettext('Constante de  7 bits para mostrar la letra R en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 0 | 1 | 0 | 1 |');
gettext('S');
gettext('Constante de  7 bits para mostrar la letra S en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 1 | 1 | 0 | 1 | 1 |');
gettext('U');
gettext('Constante de  7 bits para mostrar la letra U en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 1 | 1 | 1 | 1 | 0 |');
gettext('Y');
gettext('Constante de  7 bits para mostrar la letra Y en un display de 7 segmentos');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 1 | 1 | 0 | 1 | 1 |');
gettext('Digitos');
gettext('Letras');
gettext('displayBit');
gettext('DisplayBit. Decodificador de 1 bit a 7 segmentos. Ánodo común');
gettext('displayBit2');
gettext('DisplayBit2. Decodificador de 2 bits a 7 segmentos. Ánodo común');
gettext('displayBit3');
gettext('DisplayBit3. Decodificador de 3 bits a 7 segmentos. Ánodo común');
gettext('displayDEC');
gettext('DisplayDEC. Decodificador BCD a 7 segmentos. Ánodo común');
gettext('displayHEX');
gettext('DisplayHEX. Decodificador de binario a hexadecimal-7 segmentos. Ánodo común');
gettext('0');
gettext('Constante de  7 bits para mostrar el dígito 0 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 0 | 0 | 0 | 0 | 1 |');
gettext('1');
gettext('Constante de  7 bits para mostrar el dígito 1 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 1 | 1 | 1 | 1 |');
gettext('2');
gettext('Constante de  7 bits para mostrar el dígito 2 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 1 | 0 | 0 | 1 | 0 |');
gettext('3');
gettext('Constante de  7 bits para mostrar el dígito 3 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 0 | 1 | 1 | 0 |');
gettext('4');
gettext('Constante de  7 bits para mostrar el dígito 4 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 1 | 1 | 0 | 0 |');
gettext('5');
gettext('Constante de  7 bits para mostrar el dígito 5 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 0 | 0 | 1 | 0 | 0 |');
gettext('6');
gettext('Constante de  7 bits para mostrar el dígito 6 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 0 | 0 | 0 | 0 | 0 |');
gettext('7');
gettext('Constante de  7 bits para mostrar el dígito 7 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 | 1 | 1 |');
gettext('8');
gettext('Constante de  7 bits para mostrar el dígito 8 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 |  0| 0 | 0 | 0 | 0 |');
gettext('9');
gettext('Constante de  7 bits para mostrar el dígito 9 en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 |  0| 0 | 1 | 0 | 0 |');
gettext('A');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal A en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 |  0| 1 | 0 | 0 | 0 |');
gettext('B');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal B en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 |  0| 0 | 0 | 0 | 0 |');
gettext('C');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal C en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 0 | 0 | 0 | 1 |');
gettext('D');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal D en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 |  0| 0 | 0 | 1 | 0 |');
gettext('E');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal E en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 0 | 0 | 0 | 0 |');
gettext('F');
gettext('Constante de  7 bits para mostrar el dígito hexadecimal F en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 1 |  1| 1 | 0 | 0 | 0 |');
gettext('G');
gettext('Constante de  7 bits para mostrar la letral G en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|0  | 0 | 0 | 0 | 1 | 0 | 0 |');
gettext('H');
gettext('Constante de  7 bits para mostrar la letra H en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 0 | 0 | 1 | 0 | 0 | 0 |');
gettext('I');
gettext('Constante de  7 bits para mostrar la letra I en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n|1  | 1 | 1 | 1 | 0 | 0 | 1 |');
gettext('J');
gettext('Constante de  7 bits para mostrar la letra J en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 0 | 0 | 1 | 1 |');
gettext('L');
gettext('Constante de  7 bits para mostrar la letra L en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 0 | 0 | 0 | 1 |');
gettext('N');
gettext('Constante de  7 bits para mostrar la letra N en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 0 | 1 | 0 | 1 | 0 |');
gettext('NN');
gettext('Constante de  7 bits para mostrar la letra ñ en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 1 | 0 | 1 | 0 | 1 | 0 |');
gettext('O');
gettext('Constante de  7 bits para mostrar la letra O en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 0 | 0 | 0 | 1 |');
gettext('P');
gettext('Constante de  7 bits para mostrar la letra P en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 1 | 1 | 0 | 0 | 0 |');
gettext('Q');
gettext('Constante de  7 bits para mostrar la letra Q en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 0 | 0 | 0 | 1 | 1 | 0 | 0 |');
gettext('R');
gettext('Constante de  7 bits para mostrar la letra R en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 1 | 1 | 1 | 0 | 1 | 0 |');
gettext('S');
gettext('Constante de  7 bits para mostrar la letra S en un display de 7 segmentos. Ánodo común');
gettext('U');
gettext('Constante de  7 bits para mostrar la letra U en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 0 | 0 | 0 | 1 |');
gettext('Y');
gettext('Constante de  7 bits para mostrar la letra Y en un display de 7 segmentos. Ánodo común');
gettext('**Segmentos**\n\n| a | b | c | d | e | f | g |\n|---|---|---|---|---|---|---|\n| 1 | 0 | 0 | 0 | 1 | 0 | 0 |');
gettext('adc-12bits');
gettext('Control y lectura I2C del ADS7924');
gettext('adc');
gettext('Analog-to-digital-converter');
gettext('Circuito combinacional de 3 entradas y 18 salidas');
gettext('Contador módulo M, ascendente, de 3 bits, con reset ');
gettext('Puerta NOT');
gettext('Puerta OR');
gettext('Puerta AND');
gettext('Comparador de igualdad, de un operando de 3 bits');
gettext('Circuito combinacional de 2 entradas y 8 salidas');
gettext('RS-FF-set-verilog. RS Flip-flop with priority set. Implementation in verilog');
gettext('Falling-edge detector. It generates a 1-period pulse (tic) when a falling edge is detected on the input');
gettext('Two bits input And gate');
gettext('NOT gate (Verilog implementation)');
gettext('System - D Flip-flop. Capture data every system clock cycle. Verilog implementation');
gettext('Rising-edge detector. It generates a 1-period pulse (tic) when a rising edge is detected on the input. Block implementation');
gettext('2-to-1 Multplexer (8-bit channels). Verilog implementation');
gettext('08-Reg: 8 bits Register. Verilog implementation');
gettext('Controlador i2c que permite 3 transacciones: escritura, lectura y selección');
gettext('Tri-state logic block');
gettext('Separador de bus de 2-bits en dos cables');
gettext('Multiplexor de 2 a 1');
gettext('Un bit constante a 1');
gettext('Multiplexor de 4 a 1 de 8 bits');
gettext('Valor constante 2 para bus de 2 bits');
gettext('Valor genérico constante, de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Valor constante 3 para bus de 2 bits');
gettext('Circuito combinacional de 2 entradas y 2 salidas');
gettext('DFF. D Flip-flop. Verilog implementation');
gettext('08-SL: 8 bits shift left register. Verilog implementation');
gettext('2-to-1 Multplexer (2-bit channels). Verilog implementation');
gettext('Detección de los ACKs del esclavo. Si no se recibe, se activa la salida NAK');
gettext('Generar una condición de parada en el bus i2c');
gettext('Temporizador en microsegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Gestion de la entrada/salida en el bus i2c');
gettext('Contador módulo M, ascendente, de 8 bits, con reset ');
gettext('Constant bit 0');
gettext('Inyectar un byte en el bus i2c');
gettext('Un bit constante a 0');
gettext('DFF-rst. D Flip-Flop with load and reset. Implemented in verilog');
gettext('08-SL-ld: 8 bits shift left register with load. Verilog implementation');
gettext('Corazón  finito de tics. Emitir num tics cuando se recibe un tic de start');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en tics también');
gettext('Contador módulo M, ascendente, de 5 bits, con reset ');
gettext('Generar la condición de start en el bus I2C');
gettext('Máquina para hacer repeticiones');
gettext('Detector de flanco de subida. Emite un tic cuando detecta un flanco ascendente');
gettext('Contador módulo M, ascendente, de 2 bits, con reset ');
gettext('**SDA**\n(INOUT)  ');
gettext('Decoddificador');
gettext('**Parámetro**: Módulo del contador');
gettext('## Falling edge detector\n\nIt generates a 1-period pulse (tic) when a falling edge is detected on the  \ninput signal');
gettext('Input signal');
gettext('System clock');
gettext('Current signal  \nstate');
gettext('Signal state in the previous  \nclock cycle');
gettext('If the current signal is 0 and its value in  \nthe previous clock cycle was 1, it means  \nthat a falling edge has been detected!  \nThe output es 1\n\nIn any other case the output is 0');
gettext('**Delay**: 0 clock cycles \n\nThere is no delay between the arrival of a falling edge  \nand its detection');
gettext('Input');
gettext('Output');
gettext('Parameter: Initial value');
gettext('Input data');
gettext('# D Flip-Flop  (system)\n\nIt stores the input data that arrives at cycle n  \nIts output is shown in the cycle n+1');
gettext('Not connected');
gettext('## Rising edge detector\n\nIt generates a 1-period pulse (tic) when a rising edge is detected on the  \ninput signal');
gettext('If the current signal is 1 and its value in  \nthe previous clock cycle was 0, it means  \nthat a rising edge has been detected!  \nThe output es 1\n\nIn any other case the output is 0');
gettext('**Delay**: 0 clock cycles \n\nThere is no delay between the arrival of a rising edge  \nand its detection');
gettext('Configuracion pin inout:  \n1: Salida  \n0: Entrada');
gettext('Señal para lectura  \n(W=1)');
gettext('Señal para escritura  \n(W=0)');
gettext('Generar una condición de Stop en el Bus I2C  \nCuando está en reposo, las entradas sda y scl atraviesan el  \nbloque sin modificación. Cuando se activa start, comienza la  \ngeneración de la condición de parada, y SCL se pone a 1.  \nTranscurrido un tiempo T2, SDA se pone a 1 también  \nSe señalliza en done que se ha completado');
gettext('Espera previa al stop');
gettext('**Arranque del**  \n**temporizador**');
gettext('**Salida de pulso**');
gettext('**Salida de tic**');
gettext('**Parametro del timer**  \nmicroseundos a esperar');
gettext('rs bit  \n(receive/send)  \n0: receive  \n1: send  ');
gettext('Receive-send bit');
gettext('ack window  \nThis output is 1 only  \nwhen the 9th bit is being  \nsent');
gettext('121 tics son 10us');
gettext('Arrancar el módulo  \nde gestión del pin io');
gettext('**I2C: Condicion de start**\n\nSDA y SCL están inicialmente en reposo (1). Al llegar un  \ntic por start, se genera la condición de start, que consiste  \nen poner SDA a 0 y trancurrido un tiempo T1, el reloj SCL  \ntambién se pone a 0');
gettext('**Estado de SDA**  \n(datos)   \nInicialmente a 1');
gettext('**Línea de datos**');
gettext('La señal SCL está  \nretrasada T1 con  \nrespecto a SDA');
gettext('Detectar cuando SDA  \nha bajado a 0');
gettext('**Estado de SCL** (Reloj)    \nInicialmente a 1');
gettext('Al activarse start, SDA  \nbaja a 0');
gettext('Volver al estado de  \nreposo (SDA=1, SCL=1)');
gettext('Emitir un tic para indicar  \nque la condición de estar  \nse ha ejecutado');
gettext('CircuitScramble');
gettext('Baliza-1');
gettext('Baliza luminosa de 1 led. Parpadea a 2Hz cuando se activa');
gettext('Simplified-Heart-Hz-sys-32bits: periodic signal in Hertz. Duty cicle of 50 percent');
gettext('SR1-32bits: Shift  a 32-bit value one bit right. MSB is filled with the input  in');
gettext('Bus32-Split-31-1: Split the 32-bits bus into two buses of 31 and 1 wires');
gettext('Bus32-Join-1-31: Join the two buses into an 32-bits Bus');
gettext('Unit-hz-32bits: hz to cycles converter');
gettext('Heart-sys-zero-32bits: Generate a periodic signal of period T cycles. It starts at cycle 0. It never stops');
gettext('OR2: Two bits input OR gate');
gettext('Sys-Delay-xN-32bits: The input tic is delayed N cycles');
gettext('Counter-M-x32: 32-bits M module counter with reset');
gettext('Inc1-32bit: Increment a 32-bits number by one');
gettext('AdderK-32bit: Adder of 32-bit operand and 32-bit constant');
gettext('Generic: 32-bits generic constant');
gettext('Adder-32bits: Adder of two operands of 32 bits');
gettext('Adder-8bits: Adder of two operands of 8 bits');
gettext('Bus8-Split-half: Split the 8-bits bus into two buses of the same size');
gettext('Adder-4bits: Adder of two operands of 4 bits');
gettext('Adder-1bit: Adder of two operands of 1 bit');
gettext('AdderC-1bit: Adder of two operands of 1 bit plus the carry in');
gettext('XOR gate: two bits input xor gate');
gettext('Bus4-Split-all: Split the 4-bits bus into its wires');
gettext('Bus4-Join-all: Join all the wires into a 4-bits Bus');
gettext('Bus8-Join-half: Join the two same halves into an 8-bits Bus');
gettext('AdderC-4bits: Adder of two operands of 4 bits and Carry in');
gettext('AdderC-8bits: Adder of two operands of 8 bits and Carry in');
gettext('Bus16-Join-half: Join the two same halves into an 16-bits Bus');
gettext('Bus24-Join-8-16: Join the two buses into an 24-bits Bus');
gettext('Bus32-Split-8-24: Split the 28-bits bus into two buses of 8 and 24 wires');
gettext('Bus24-Split-16-8: Split the 24-bits bus into two buses of 16 and 8 wires');
gettext('Bus16-Split-half: Split the 16-bits bus into two buses of the same size');
gettext('Bus32-Join-8-24: Join the two buses into an 32-bits Bus');
gettext('Geu-32-Bits_v: 32-bit Unsigned Greather than or equal comparator. Verilog implementation');
gettext('32-Reg-rst: 32 bits Register with reset. Verilog implementation');
gettext('start: Start signal: It goes from 1 to 0 when the system clock starts. 1 cycle pulse witch. Block implementation');
gettext('TFF-verilog. System TFF with toggle input: It toogles on every system cycle if the input is active. Verilog implementation');
gettext('**Baliza luminosa**\n\nParpadeo del LED a 2Hz');
gettext('Dividir entre dos el periodo  \n(Multiplicar por 2 la frecuencia)  ');
gettext('Input parameter: Milieconds  ');
gettext('Input parameter:  \nSystem Frequency');
gettext('Delay');
gettext('Start a new period');
gettext('Start at cycle 0!');
gettext('Repeat!');
gettext('Current period ended  \nStart a new one');
gettext('Periodo (in system clock cycles)');
gettext('Current cycle in the period  \n(0-T-1)');
gettext('Cycles to delay');
gettext('Delay finished!');
gettext('Machine state: ON/OFF');
gettext('RS Flip-Flop');
gettext('Circuit state:  \n* ON: working (1)\n* OFF: Not working (0)');
gettext('The counter has reached  \nthe number of cycles  \nto delay');
gettext('Maximum count  \nreached');
gettext('32-bits register');
gettext('If the max count is reached  \nand the cnt tic is received,  \nthe register is reset to 0');
gettext('External reset');
gettext('Initial value: 1');
gettext('Initial value: 0');
gettext('Falling edge');
gettext('Baliza-2');
gettext('Baliza luminosa de 2 leds. Parpadean alternativamente a 2Hz cuando se activa');
gettext('**Baliza luminosa**\n\nParpadeo de los LEDs alternativamente a 2Hz, cuando están habilitados ');
gettext('Beep-flash');
gettext('Emitir un flash en el LED y un pitido en el zumbador al recibir el tic');
gettext('Emitir un pulso de anchura determinada para encender un LED durante un tiempo. 50ms por defecto');
gettext('Temporizador en milisegundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Emitir un pitido de duración (ms) y frecuencia (hz) indicada en los parámetros, al recibir un tic');
gettext('Unit-ms-32bits: ms to cycles converter');
gettext('**Parametro del timer**  \nmilisegundos a esperar');
gettext('Beep');
gettext('Init-tic-32');
gettext('Emitir un tic inicial al arrancar, y nunca más. Se esperan 32 tics antes de emitir el tic de inicialización');
gettext('5-bits Syscounter with reset');
gettext('Inc1-5bit: Increment a 5-bits number by one');
gettext('AdderK-5bit: Adder of 5-bit operand and 5-bit constant');
gettext('Adder-5bits: Adder of two operands of 5 bits');
gettext('Bus5-Split-1-4: Split the 5-bits bus into two buses of 1 and 4 bits');
gettext('Bus5-Join-1-4: Join the two buses of 1 and 4 bits into a 5-bits Bus');
gettext('Generic: 5-bits generic constant (0-31)');
gettext('05-Sys-reg-rst: 5 bits system register with reset. Verilog implementation');
gettext('KITT');
gettext('Secuencia del coche fantástico, con entrada de enable');
gettext('Corazón de bombeo de tics con periodo paramétrico de milisegundos y entrada de enable');
gettext('Contador módulo M, ascendente, de 4 bits, con reset ');
gettext('Circuito combinacional de 4 entradas y 8 salidas');
gettext('Sirena');
gettext('Cuando se activa su entrada (por nivel) suena la sirena');
gettext('Simplified-Heart-KHz-sys-32bits: periodic signal in Kilo-Hertz. 50% of duty cycle');
gettext('Unit-khz-32bits: khz to cycles converter');
gettext('**Sirena acústica**\n\nSe alternan pitidos de 1Khz y 2Khz a la frecuencia de 4Hz');
gettext('Cuando esta señal se pone a 1  \nempieza a sonar la sirena');
gettext('Conectar la salida  \ndirectamente a un  \nzumbador');
gettext('comecocos');
gettext('Bloque de prueba para explicar conceptos. No hace nada');
gettext('Bloque de documentación, para explicar los  \nconceptos de puertos, parámeros, pines, cables  \ny buses en el tutorial 21');
gettext('flash');
gettext('Button-off');
gettext('Pulsador de cambio con icono de Circuit Scramble. Cada vez que se aprieta cambia de estado');
gettext('Valor inicial del pulsador\n');
gettext('and');
gettext('24-bits');
gettext('26-bits');
gettext('accum-sys');
gettext('24-bits accumulator (system)');
gettext('Adder for two operands of 24 and 16 bits. Result in 24 bits');
gettext('Agregador de 2 buses de 8-bits y 16 a uno de 24-bits');
gettext('Valor constante 0 para bus de 8 bits');
gettext('Valor genérico constante, de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Sumador de dos operandos de 24bits');
gettext('24-Sys-reg: 24 bits system register. Verilog implementation');
gettext('accum');
gettext('24-bits accumulator');
gettext('24-Reg: 24 bits Register. Verilog implementation');
gettext('accum');
gettext('26-bits accumulator');
gettext('24-bits adder with two operands');
gettext('26-Sys-reg: 26 bits system register. Verilog implementation');
gettext('Bin2BCD');
gettext('10bitBCD-3charASCII');
gettext('Decodificador de BCD a ASCII');
gettext('BCD-ASCII');
gettext('04-bits');
gettext('08-bits');
gettext('12-bits');
gettext('16-bits');
gettext('parts');
gettext('Bin2BCD-comb');
gettext('Conversor de binario a BCD, para números de 4 bits');
gettext('Separador de bus de 4-bits en 4 cables');
gettext('SL1-4-verilog: Shift  a 4-bit value one bit left. LSB is filled with 'in' and the MSB is written to out . Verilog implementation');
gettext('Cálculo combinacional parcial para la conversion de Binario a BCD');
gettext('Sumador de un operando de 4 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador menor que, de un operando de 4 bits');
gettext('2-to-1 Multplexer (4-bit channels). Verilog implementation');
gettext('4bits constant value: 0');
gettext('Generic: 4-bits generic constant (0-15)');
gettext('Esta céluca combinacional realiza una parte del cálculo del  \nalgoritmo para convertir de **binario a BCD**:\n\nSi la entrada a es mayor o igual a 5, se devuelve a+5,  \nde lo contrario se devuelve a (se deja como estaba)');
gettext('¿Es a >= 5?');
gettext('**Si**  \na es >= que 5');
gettext('Calcular a+3');
gettext('**No**  \na NO es >= 5');
gettext('Bin2BCD-seq');
gettext('Máuina de conversion Binario - BCD de 4 bits');
gettext('Biestable de almacenamiento del estado de la máquina');
gettext('Máquina de contar, de 2 bits (cuenta hasta 4 ciclos)');
gettext('Sumador de un operando de 2 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 2 bits');
gettext('Valor genérico constante (menos 1), de 2 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('02-Reg-rst: 2 bits Register with reset. Verilog implementation');
gettext('04-SL-ld: 4 bits shift left register with load. Verilog implementation');
gettext('04-Reg-rst: 4 bits Register with reset. Verilog implementation');
gettext('04-Reg: 4 bits Register. Verilog implementation');
gettext('**Reloj**');
gettext('**Número a convertir**');
gettext('**Arranque**');
gettext('Estado de la  \nmáquina');
gettext('Dígito 0');
gettext('Dígito 1');
gettext('**Máquina de contar**  \nLa conversión se realiza en  \n4 iteraciones');
gettext('Cargar el numero a convertir  \nen el arranque de la máquina');
gettext('Actualizar registro  \nen cada etapa');
gettext('**Calculos para el digito 0**');
gettext('**Calculos para el digito 1**');
gettext('**Capturar el digito**');
gettext('**Tic de apagado**');
gettext('**Tic de encendido**');
gettext('**Inicializar**');
gettext('**Estado de la máquina**');
gettext('**Reloj del sistema**');
gettext('**Estado de**  \n**la máquina**');
gettext('Máquina encendida');
gettext('Máquina apagada  \n(rst = 1)');
gettext('Tic de arranque');
gettext('Tic de fin');
gettext('**Contador de ciclos**');
gettext('Número de ciclos  \ncontados');
gettext('Valor  \nincrementado');
gettext('### Salidas');
gettext('Estado de la máquina');
gettext('Ciclo actual');
gettext('Cuenta finalizada');
gettext('Ejecutar el ciclo');
gettext('Número de ciclos  \na contar');
gettext('¿Estamos en el  \nciclo k-1?');
gettext('Solo se hace caso a la  \nentrada next si la  \nmáquina está encendida');
gettext('Nuevo ciclo');
gettext('Si es el ciclo k-1 y  \nse pide un ciclo  \nnuevo: Terminar');
gettext('Apagar la  \nmáquina');
gettext('Ciclo nuevo:  \nincrementar la cuenta');
gettext('El tic de start se saca  \npor exec para que se ejecute  \nel primer ciclo');
gettext('Si la máquina está  \napagada, las señales  \nde ejecución no pueden  \nsalir!');
gettext('Retrasar la señal un ciclo  \nmientras que se detecta si  \nla máquina ha finalizado o no');
gettext('Bin2BCD-seq');
gettext('Máuina de conversion Binario - BCD de 8 bits');
gettext('Comparador de dos operandos de 3 bits');
gettext('Valor genérico constante (menos 1), de 3 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Sumador de un operando de 3 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('03-Reg-rst: 3 bits Register with reset. Verilog implementation');
gettext('Dígito 2');
gettext('Bin2BCD-seq');
gettext('Máuina de conversion Binario - BCD de 12 bits');
gettext('Máquina de contar, de 4 bits');
gettext('Comparador de dos operandos de 4 bits');
gettext('Valor genérico constante (menos 1), de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('12-SL-ld: 12 bits shift left register with load. Verilog implementation');
gettext('Dígito 3');
gettext('Bin2BCD-seq');
gettext('Máuina de conversion Binario - BCD de 16 bits');
gettext('16-SL-ld: 16 bits shift left register with load. Verilog implementation');
gettext('Dígito 4');
gettext('Bin2BCD_fix_16bits');
gettext('Convert a binary number into BCD. This module retains the BCD output value (memory) and is arranged in reverse to facilitate connections.');
gettext('### Convert a binary number into BCD. This module retains the BCD output value (memory) and is arranged in reverse to facilitate connections to a multiplexer and, therefore, it can send it to the serial.');
gettext('comb-unit');
gettext('Buffer-4B');
gettext('4Bytes buffer with dump');
gettext('2bits up-down counter with limits. Reset');
gettext('Comparador menor que, de un operando de 2 bits');
gettext('2bits-Greather than comparator');
gettext('Codificador de 2 a 1. La salida zero se activa cuando ninguna entrada está activada');
gettext('4 Bytes Synchronous memory');
gettext('**TOP registers**  \nIt contais the address where  \nthe next byte will be stored');
gettext('Number of caracters  \nin the buffer');
gettext('Insert one byte  \nin the buffer');
gettext('Change in the  \nTOP reggister');
gettext('Byte to store in the buffer');
gettext('Remove the last bytes');
gettext('Start the Dumping of  \nthe buffer');
gettext('Dump the next byte');
gettext('**DUMP machine**');
gettext('In Dumping mode');
gettext('Dump addr');
gettext('Dump finished');
gettext('Condition:  \nCurrent dump addr is  \nequal to the top register?');
gettext('**YES**: The dump is finished!');
gettext('**NO**: Continue  \ndumping the memory');
gettext('Propagate the data_tic in  \nthe dump mode');
gettext('It is synchronized  \nwith the data from memory  \n(should be delayed 1 cycle)');
gettext('Memory for storing  \nthe bytes inserted');
gettext('Select the addr for  \naccesing the memory,  \naddr: If in dumping mode  \ntop: If inserting bytes');
gettext('Data to insert  \ninto the memory');
gettext('Select the accesing mode  \nfor the memory:  \n0: Reading in dumping mode  \n1: Writing in insert mode');
gettext('Data read from the  \nmemory when in dump  \nmode');
gettext('Tic: change in the buffer');
gettext('Data from the buffer');
gettext('Dumping finished!');
gettext('In dumping mode');
gettext('# 4BYTES BUFFER  \n\nBuffer for storing 4 byts, although only 3 can be used (the 4th is  \nused for indicating the buffer is full)  \n\nThe buffer has 3 operations:  \n* insert:  Storing the byte in the last posiition  \n* delete:  Delete the last byte  \n* dump: Dunmp the memory contents, from the first  \n  byte to the last one\n  The dump operation is done by a machine. It needs to  \n  receive the next signal to proceed for dumping the  \n  next value');
gettext('Maximum value');
gettext('Minimum value');
gettext('**Increment tic**  \nup button press and  \ncurrent value < Max');
gettext('**Decrement tic**  \nDown button pressed and  \ncurrent value > Min');
gettext('inc tic: 1  \ndec tic: 0\n');
gettext('Action detected!  \nEither inc or dec');
gettext('The counter  \nhas changed!');
gettext('Current value');
gettext('Value incremented!');
gettext('Value decremented!');
gettext('## Up-down counter with MAX and MIN limits\n\nThe counter is incremented when the up tic is received  \nand it has not already reached its maximum value  \n\nThe counter is decremented then the down tic is received  \nand it is not in its minimum value');
gettext('Para automático de la  \nmáquina cuando ha terminado  ');
gettext('Paro externo');
gettext('CRC-16-CCITT');
gettext('Calculo del CRC-16-CCITT de un mensaje serie');
gettext('Puerta XOR');
gettext('Agregador de buses de 3 y 1-bits a a bus de 4-bits');
gettext('Agregador de 4 buses en un bus de 16-bits');
gettext('04-SL-rst: 4 bits shift left register with reset. Verilog implementation');
gettext('03-SL-rst: 3 bits shift left register with reset. Verilog implementation');
gettext('**1**');
gettext('Bit 0');
gettext('Bit 3');
gettext('Bit 4');
gettext('Bit 5');
gettext('**X^5**');
gettext('Bit 7');
gettext('Bit 8');
gettext('Bit 11');
gettext('Bit 12');
gettext('**X^12**');
gettext('Bit 15');
gettext('**X^16**');
gettext('Mensaje de entrada');
gettext('Polinomio Generador:\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/png/bd8dba2898cd0de4ef69e454d9c8f45efdfcedb2)');
gettext('### Calculo del CRC-16-CCITT\n\nEl mensaje entra bit a bit, en serie por msg  \nPor cada bit nuevo que llega entra un tic por shift  ');
gettext('**Resultado**  \n(parcial)');
gettext('EncoderX4');
gettext('Encoder X4.');
gettext('FPGA internal pull-up configuration on the connected input port');
gettext('I2C_only_write');
gettext('i2c-data');
gettext('i2c-io');
gettext('i2c-nak');
gettext('i2c-start');
gettext('i2c-stop');
gettext('i2c');
gettext('machine-loop');
gettext('I2C_write');
gettext('Maestro I2C de un byte de dato. Sólo escritura.');
gettext('Multiplexor de 4 a 1. Implementado en verilog');
gettext('La salida sólo da 0 o flotante. Una resistencia externa al circuito en pull-up a la salida ha de crear el 1.');
gettext('Bloque inout, con conexión de pin por la derecha');
gettext('Complemento que junto a resto de los elementos crean la señal Stop.');
gettext('Comparador de un operando de 4 bits. Se compara si el operando es igual al parámetro');
gettext('La frecuencia de entrada siempre comienza en el ciclo bajo una vez que hacemos ');
gettext('RS-FF-reset. RS Flip-flop with priority reset. Verilog implementation');
gettext('Tics2 son 2 tics de la primera onda y no vuele a hacer nada. A partir del siguiente ciclo saldrán los tics por Shift.');
gettext('Detect changed on the input signal ');
gettext('registros de desplazamientos: data(8bits)+ack(1bit).');
gettext('Valor genérico constante, de 1 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Sys-DFF-ld-verilog. System - D Flip-flop. Capture data every system clock cycle. from input si. If load is active, the data is captured from the d input. Verilog implementation');
gettext('registros de desplazamientos: address(7bits)+rw(1bit)+ack(1bit)');
gettext('07-SL-ld: 7 bits shift left register with load. Verilog implementation');
gettext('# I2C Maestro. Sólo escritura.');
gettext('INFO: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/QZqGqehCvuk/L9yCuXW_BwAJ');
gettext('Al darle al \"set\" permitirá que pase la frecuencia \"fi\" hacia \"fo\" pero comenzando siempre con un flanco de bajada de dicha señal. Al darle a \"rst\" impide que pase la frecuencia de entrada. Se trata de que la frecuencia de salida siempre-siempre comience con el ciclo bajo.');
gettext('## Change detector  \n\nIt emits the followings tics:\n\n* When there is a rising edge on the input signal\n* When there is a falling edge\n* When there is either a rising or falling edge');
gettext('Input data (serial)');
gettext('# D Flip-Flop  (system) with load\n\nIt stores the input data that arrives at cycle n  \nIts output is shown in the cycle n+1  \nThe data is captured from input si. If load is active the  \ndata is captured from input d');
gettext('Input data (Paralell)');
gettext('Load control');
gettext('IR-tic-sound');
gettext('Detección de objeto con sensor de infrarrojos (IR). Emite un tic cada vez detecta un objeto, y un sonido');
gettext('Detección de objeto con sensor de infrarrojos (IR). Emite un tic cada vez detecta un objeto');
gettext('**IRr-tic-sound**');
gettext('**IRr-tic**');
gettext('IR-tic');
gettext('jelly-kbd');
gettext('Controlador para teclado matricial Jelly');
gettext('Contador módulo M, ascendente, de 3 bits');
gettext('Decodificador de 3 a 6, lógica invertida, con salida en bus');
gettext('Puerta OR de 5 entradas de bus');
gettext('Codificador de 5 a 3, con prioridad. La salida zero se activa cuando ninguna entrada está activada');
gettext('Memoria de datos');
gettext('Agregador de 2 buses de 3-bits a bus de 6-bits');
gettext('Circuito combinacional de 6 entradas y 5 salidas');
gettext('Sincronizar las entradas de datos con el reloj del sistema, en un bus de 5');
gettext('Agregador de bus de 5-bits');
gettext('Sincronizar las entradas de datos con el reloj del sistema');
gettext('Separador de bus de 5-bits en 5 cables');
gettext('Puerta NOT para bus de 5 bits');
gettext('Simplified-Heart-tic-ms-sys-32bits: Nominal periodic signal in mili seconds');
gettext('Sync-x01: 1-bit input with the system clock domain (Verilog implementation)');
gettext('05-Reg: 5 bits Register. Verilog implementation');
gettext('![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-03.png)');
gettext('**Fila 0**');
gettext('**Col 3**');
gettext('**Col 0**');
gettext('**Fila 1**');
gettext('**Col 4**');
gettext('**Col 1**');
gettext('**Col 2**');
gettext('**Fila 2**');
gettext('**Fila 3**');
gettext('**Fila 4**');
gettext('**Fila 5**');
gettext('Tiempo de muestreo de  \ncada fila');
gettext('Recorrer las  \nfilas');
gettext('Enviar un 0 por la fila a  \nescanear. Por el resto se  \nenvían 1s');
gettext('**R0**');
gettext('**R1**');
gettext('**R2**');
gettext('**R3**');
gettext('**R4**');
gettext('**R5**');
gettext('Lectura de las 5 columnas de  \nla fila actual');
gettext('Activar  \nPull-ups');
gettext('0: Tecla NO pulsada  \n1: Tecla pulsada');
gettext('Estado actual de la fila  \nescaneada');
gettext('Muestrear la fila  \n(capturar valor)');
gettext('En el siguiente ciclo  \nse graba en la memoria');
gettext('En la memoria se guarda el  \nestado de la fila en el  \nciclo anterior');
gettext('Hay tecla pulsada en  \nla fila actual');
gettext('Detectar si habia tecla pulsada  \nen el escaneo anterior');
gettext('Detecar flanco de subida  \nen tecla');
gettext('Obtener el número de columna  \nsegún la tecla activa');
gettext('Numero de FILA  \nde la tecla pulsada');
gettext('Cuando hay tecla pulsada  \nse resetea el registro  \nen el ciclo siguiente');
gettext('Numero de COLUMNA  \nde la tecla pulsada');
gettext('Tabla para calcular el  \ncódigo de cada tecla  \nen función de su número  \nde fila y columna');
gettext('**KEYCODE**');
gettext('Evento:\n**KEYPRESSED**');
gettext('**KEYPRESSED**');
gettext('Evento:\n**KEYRELEASED**');
gettext('Los eventos son validos si  \nhan ocurrido un tic después  \nde capturar la fila actual  ');
gettext('**KEYRELEASED**');
gettext('**KEY-STATE**');
gettext('Estado de la tecla:  \n1: Pulsada  \n0: No pulsada');
gettext('El estado de la tecla se calcula a partir de los  \neventos Key-pressed y key-released. Cuando  \nse pulsa, se cambia el estado a 1. Al liberarse  \nse cambio a 0');
gettext('![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-usb-25.png)');
gettext('Mapa de los códigos de teclas implementados  \nen el controlador (**KEYCODES**)');
gettext('**COL 4** (C19)');
gettext('**COL 3** (C18)');
gettext('**COL 2** (C17)');
gettext('**COL 1** (C9)');
gettext('**COL 0** (C8)');
gettext('key-beep');
gettext('Lectura de una tecla externa. Pull-up interno activo. Sonido al pulsarla');
gettext('Pull-up_ICE40:: FPGA internal pull-up configuration on the input port. ICE40 FPGA family');
gettext('Remove the rebound on a mechanical switch');
gettext('Edges detector. It generates a 1-period pulse (tic) when either a rising edge or a falling edge is detected on the input. Block implementation');
gettext('16-bits Syscounter with reset');
gettext('Inc1-16bit: Increment a 16-bits number by one');
gettext('AdderK-16bit: Adder of 16-bit operand and 16-bit constant');
gettext('Generic: 16-bits generic constant');
gettext('Adder-16bits: Adder of two operands of 16 bits');
gettext('16-Sys-reg-rst: 16 bits system register with reset. Verilog implementation');
gettext('**Pull-up**');
gettext('**Sincronización**');
gettext('Eliminar los problemas  \nde metaestabilidad');
gettext('**Lógica positiva**');
gettext('0: Tecla NO pulsada  \n1: Tecla pulsada   ');
gettext('**Antirrebotes**');
gettext('Estado de la tecla');
gettext('Detectar **Flanco de subida**  \ny **Flanco de bajada**');
gettext('Tic al apretar');
gettext('Tic al soldar');
gettext('Emitir pitido en la  \npulsacion');
gettext('### Pull-up parameter:\n\n0: No pull-up  \n1: Pull-up activated');
gettext('Only an FPGA pin can  \nbe connected here!!!');
gettext('The pull-up is connected  \nby default');
gettext('Edge detector');
gettext('Whenever there is a change in  \nthe input, the counter is started');
gettext('If the counter reaches it maximum  \nvalue, the input is considered stable  \nand it is captured');
gettext('### Time calculation\n\nFor CLK=12MHZ, a 16-bit counter reaches its  \nmaximum every 2 ** 16 * 1/F = 5.5ms aprox  \nIF more time is needed for debouncing,  \nuse a counter with more bits (17, 18...)');
gettext('## Debouncer  \n\nA value is considered stable when  \nthere is no changes during 5.5ms  \naprox. When a value is stable it is  \ncaptured on the output flip-flop');
gettext('Stable output');
gettext('Counter');
gettext('## Edges detector\n\nIt generates a 1-period pulse (tic) when an edge (Rising or falling) is detected on the  \ninput signal');
gettext('The output is 1 if the current value is 1 and the  \nprevious 0, or if the current value is 0 and the  \nprevious 1\n');
gettext('In any other case the output is 0');
gettext('key');
gettext('Lectura de una tecla externa. Pull-up interno activo');
gettext('SM-S4303R');
gettext('Stepper');
gettext('MotorBit');
gettext('Controlador para servo de rotacion continua SprintRC SM-S4303R. Con on=1, el motor avanza. Dir=1 sentido agujas reloj/ 0 el contrario. V1 y V2 son los pulsos para las velocidades horaria y antihoraria (en micro-sec). V0 para que esté parado');
gettext('Mux 2:1. Bus de 7 bits. ');
gettext('Mux 2:1. Bus de 4 bits. ');
gettext('Agregador de 4 cables a bus de 4bits');
gettext('Separador de bus de 4bits en 4 cables (1 + 1 + 1 + 1)');
gettext('Multiplexor 2:1 de 1-bit');
gettext('NAND logic gate');
gettext('Transistor');
gettext('Transistor cmos hecho a partir de semiconductores');
gettext('Cristal de Siicio');
gettext('Atomos de silicio');
gettext('Separador de bus de 8bits en 2 (4 + 4)');
gettext('Agregador de 2 buses de 4 a bus de 8bits');
gettext('Controlador PWM para posicionar servos de 20ms. Las unidades de pos son de 10usec');
gettext('**Velocidad 1**: Velocidad para el  \nsentido de giro horario\n');
gettext('**Velocidad 2**: Velocidad para el \nsentido de giro antirhorario');
gettext('**Entrada on/off**: Motor en  \nmovimiento o parado');
gettext('**Motorbit paramétrico** para los **SM-S4303R** o compatibles\n\nTiene 3 parámetros, especificados en micro-segundos. **V1** y **V2** son las posiciones (ancho del pulso)  \npara las velocidades de giro en sentido horario y antihorario respectivamente\n\n**V0** es la posición en la que el servo está parado (velocidad 0)\n\nPor defecto se asignan los valores para las velocidades máximas, tanto en sentido horario como antihorario\n\n* V1max = 1900\n* V2max = 1100\n* V0 = 1500');
gettext('**Velocidad en sentido horario**\n\n* Si V1 >= 1900, la velocidad es máxima\n* Si 1900 > V1 > 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**Velocidad en sentido antihorario**\n\n* Si V2 <= 1100, la velocidad es máxima\n* Si 1100 < V2 < 1500, la velocidad estará  \nentre la máxima y 0');
gettext('**dir**: Sentido de giro  \n1: horario / 0: antihorario');
gettext('**Velocidad 0**: Posición para que  \nel servo esté parado');
gettext('Mux 2:1 with logic gates');
gettext('Entrada 1');
gettext('Entrada 0');
gettext('Selección');
gettext('Implementación en Verilog');
gettext('Las puertas están construidas a\npartir de transistores');
gettext('Pincha en algún transistor para\nbajar de nivel');
gettext('Nivel 3: Semiconductores');
gettext('Los transistores se crean a \npartir de uniones entre \nsemiconductores, de tipo P y N\nEstán integrados en los dados de\nsilicio en los circuitos integrados');
gettext('Pincha en el bloque para bajar de nivel');
gettext('Nivel 2: MATERIALES');
gettext('Cristal de silicio');
gettext('Los semiconductores se crean a partir de cristales\nde Silicio (Si) que se dopans con impurezas\npara darle las propiedades de semiconductores');
gettext('Pincha en los bloques para bajar de nivel');
gettext('Átomos de Silicio');
gettext('Nivel 1: ATOMOS');
gettext('Los cristales de silicio se forman a \npartir del enlace covalente entre los\nátomos de silicio. Cada uno de ellos \nestá rodeado por 4 átomos de silicio\nformando un tetraedro');
gettext('<B>Posicion del servo</B>\n\nSe especifica en unidades de 10micro-segundos\nEj. pos = 100 --> Pulso de achura 1ms');
gettext('<B>Generación de una señal PWM para posicionamiento de Servos</B>\nEl periodo es de 20ms\nEl ancho del pulso varía entre 0 - 255 (0 - 2.5ms)');
gettext('MotorControl');
gettext('Stepper motor control.');
gettext('Circuito combinacional de 2 entradas y 4 salidas');
gettext('Demultiplexor de 1 bit, de 1 a 2');
gettext('Contador Up & Down 2 bits sin limitación de comienzo y fin.');
gettext('Esta tabla está configurada para un motor de pasos bipolar (4 hilos). Es posible que para otros motores haya que cambiar las combinaciones de 1s y 0s de la tabla.');
gettext('Contador bidireccional modificado. Se le eliminó los topes máximo y mínimo.');
gettext('SerialStepper_V5');
gettext('Absolute position control for stepper motors through the serial port, 16bits. With Homing & Shutdown.');
gettext('Temporizador en segundos. La señal p está activa durante el tiempo indicado. Por tic se emite un tic al finalizar');
gettext('Comparison of stepper motor position with desired position. 16bits. With Homing & Shutdown.');
gettext('Less than or equal to. 16 bits');
gettext('Up/Down Counter 16 bits.');
gettext('Sumador de dos operandos de 16 bits');
gettext('Valor genérico constante, de 16 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('2-to-1 Multplexer (16-bit channels). Verilog implementation');
gettext('16-Reg-rst: 16 bits Register with reset. Verilog implementation');
gettext('A standard 2-to-1 encoder with nz (not-zero) output');
gettext('Convierte números (0..65535) introducidos desde el serial a binario de 16 bits.');
gettext('Convierte un número ASCII a binario de 16 bits.');
gettext('Char detect & LF, CR, space & comma.');
gettext('Comparador de un operando de 8 bits. Se compara si el operando es igual al parámetro');
gettext('Puerta OR de 4 entradas');
gettext('Receptor serie asíncrono. Velocidad por defecto: 115200 baudios');
gettext('08-Reg-rst: 8 bits Register with reset. Verilog implementation');
gettext('Simplified-Heart-tic-hz-sys-32bits: Nominal periodic signal in hz');
gettext('### Info: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/v-gzvkIyNoI/toC0ndJpAQAJ');
gettext('### Shutdown:\nWith a 0 the motor is always active (recommended).\nA 1 only activates the motor while it is moving and after a while the motor turns off.');
gettext('Shutdown time (in seconds)');
gettext('Frequency (Hz)');
gettext('Serial baud rate');
gettext('# Full step motor control');
gettext('**Parametro del timer**  \nSegundos a esperar');
gettext('### Step');
gettext('### Direction');
gettext('Div 8');
gettext('Homing');
gettext('Desired position');
gettext('Actual position');
gettext('## Truth table\n\n| i1 | i0 | out | nz |\n|----|----|-----|----|\n| 0  | 0  |  0  | 0  |\n| 0  | 1  |  0  | 1  |\n| 1  | 0  |  1  | 1  |\n| 1  | 1  |  1  | 1  |');
gettext('Estos registros de 8 bits con reset son especiales. Cuando recibe un reset no se pone a 0, sino a 48, que es el '0' ASCII.');
gettext('Estos registros se inician con el valor 48 ('0' en ASCII).');
gettext('Convierte el valor ASCII a binario.');
gettext('Cuando recibe LF o CR produce un pulso en \"rst\" para el resto de caracteres da un pulso por \"tic\".');
gettext('stepeerControl');
gettext('Absolute position control for stepper motors through the serial port.; 16 bits.');
gettext('Comparison of stepper motor position with desired position; 16bits.');
gettext('16-Reg: 16 bits Register. Verilog implementation');
gettext('Step');
gettext('Direction');
gettext('stepperCMPserial');
gettext('NotEna8bits');
gettext('Cable = 0; NOT = 1.');
gettext('Separador de bus de 8-bits en 8 cables');
gettext('Agregador de 8 cables de 1-bit a bus de 8-bits');
gettext('int-division');
gettext('Calculate a new constant value dividing k1 / k2');
gettext('reg-addr-8bits');
gettext('Registro mapeado en una dirección de memoria');
gettext('### Registro en direccion ADDR');
gettext('Dirección del  \nregistro');
gettext('Valor por  \ndefecto');
gettext('Bus de direcciones');
gettext('Valor a guardar en  \nel registro');
gettext('Tic de escritura');
gettext('Registro seleccionado');
gettext('Valor actual del  \nregistro');
gettext('reg-rst-set-8bits');
gettext('Registro de 8 bits con reset y set');
gettext('sp-2bits');
gettext('2-bits stack pointer');
gettext('Comparador de igualdad, de un operando de 2 bits');
gettext('02-Reg: 2 bits Register. Verilog implementation');
gettext('2-bit register  \nCurrent posicion');
gettext('Value 3 is used when  \nthe stack is empty');
gettext('## 2-bits Stack Pointer\n\nIt only have 3 position for storing information:  \n0,1 and 2. The 3 is used for indicaning empty stack\n\nIt is it initial value (3 = -1)\n\nWhen the up tic is received, the sp is incremented (but it will never  \nbe higher than its maximum value of 2) and the push tic is emitted  \n(on the next cycle) for being synchronyzed with the sp value\n\n');
gettext('When the down tic is received, the pop tic is emitted and then the sp is decremented  \n(but it cannot be lower than -1). Therefore the pop tic comes before the sp is  \ndecrement. The external circuit has one cycle to read the current value at the top. In  \nthe next cycle the sp is decremented. This approach makes it very easy to implement the  \npop operation on a memory\n\nThe changed tic is emitted whenever the sp has changed  \n(either increased or decreased)');
gettext('Incremented value of  \nthe sp');
gettext('Decremented value  \nof the sp');
gettext('Current sp value');
gettext('Select the value  \nfor updating the  \ncurrent sp');
gettext('valid Change in the  \ninput tics');
gettext('There was a change  \nin the sp register');
gettext('2-1 coder');
gettext('The sp is NOT at TOP  \nand up-tic is received');
gettext('It is ok to  \nincrement the sp');
gettext('The sp is NOT EMPTY  \nand down-tic is received');
gettext('It is ok to  \ndecrement the sp');
gettext('02-bits');
gettext('04-bits');
gettext('08-bits');
gettext('pwm');
gettext('Señal pwm de 2 bits (4 niveles)');
gettext('Parámetro: Número de bits para el prescalado  \n0 para no usar prescalado');
gettext('blocks');
gettext('pwm');
gettext('Señal pwm de 4 bits (16 niveles) y frecuencia de 92Hz');
gettext('pwm-92Hz');
gettext('Comparador menor que, de dos operandos de 4 bits');
gettext('Extractor de bus de 4 bits de uno de 17bits');
gettext('Extractor de bus de 1bit de uno de 17bits');
gettext('17-bits Syscounter');
gettext('**Contador principal**');
gettext('**PWM**');
gettext('**Comparador**');
gettext('Extraer los 4 bits  \nde mayor peso');
gettext('**Registro W**');
gettext('**Registro buffer**');
gettext('Comienza un ciclo  \nde PWM nuevo');
gettext('Extraer el bit de  \nmayor peso');
gettext('El registro se carga  \nen cada comienzo de  \nciclo del PWM');
gettext('Se almacena el nivel  \nintroducido por el user  \nhasta que llegue el  \ncomienzo de ciclo');
gettext('Registrar la salida  \npara cumplir con las  \nreglas de diseño síncrono');
gettext('blocks');
gettext('pwm-100Hz');
gettext('Unidad de pwm de 8-bits. Frecuencia 100Hz (Real 91.53Hz)');
gettext('**Unidad de PWM**  \n\n* Frecuencia: 91.53 Hz  \n* Resolución: prescaler de 9 bits: 42.67us  \n* Aplicación: Control intensidad en LEDs');
gettext('pwm');
gettext('Señal pwm de 8 bits (256 niveles)');
gettext('pwm-100Hz');
gettext('Unidad de pwm de 8-bit. Frecuenica 100Hz (Real 91.53Hz)');
gettext('Detector de flanco de bajada. Emite un tic cuando detecta un flanco descendente');
gettext('Prescaler básico de N bits');
gettext('Extractor de 1 bit de un bus de 8 bits');
gettext('Comparador menor que, de dos operandos de 8 bits');
gettext('Counter-x08: 8-bits counter');
gettext('Inc1-8bit: Increment a 8-bits number by one');
gettext('AdderK-8bit: Adder of 8-bit operand and 8-bit constant');
gettext('Generic: 8-bits generic constant (0-255)');
gettext('**Prescaler de 9 bits**');
gettext('**Contador de 8 bits**');
gettext('Señal de ov: el contador  \nvuelve a comenzar desde 0  \n');
gettext('Comienza un nuevo  \nperiodo de PWM');
gettext('Valores desde 0 hasta 255');
gettext('Mientras que CONT < W (Anchura pulso)  \nPWM es 1. Cuando CONT >= w, PWM es 0');
gettext('**Señal PWM**');
gettext('Salida registrada  \n(Para cumplir normas  \ndel diseño síncrono)');
gettext('Registro que contiene la  \nanchura (8 bits) del pulso');
gettext('Almacena el valor de la anchura del pulso  \ninntroducida por el usuario. Se guarda en un  \nregistro temporal hasta que al comenzar el  \nsiguiente ciclo de PWM se carga en el registro W');
gettext('El valor del registro sólo se puede actualizar al  \ncomienzo del periodo de PWM para garantizar que  \nel pulso tiene anchura fija en ese periodo');
gettext('Desde fuera se escribir en este registro  \na la velocidad que se quiera, pero se  \ngarantiza que el registro W sólo se  \nactualiza al comienzo de cada ciclo de PWM');
gettext('Sacar el bit de mayor  \npeso del contador');
gettext('**Prescaler básico**');
gettext('Señal de reloj de salida  \nCiclo de trabajo 50%');
gettext('tic de overflow  \nComienza un nuevo periodo');
gettext('**Parámetro**: Bits del prescaler');
gettext('pwm-92Hz');
gettext('Señal pwm de 8 bits (256 niveles) y frecuencia de 92Hz');
gettext('Extractor de bus de 8 bits de uno de 17bits');
gettext('Extraer los 8 bits  \nde mayor peso');
gettext('pwm');
gettext('caida-libre-8bits');
gettext('Calculo de la caida libre de una particula');
gettext('Sumador  de 8 bits, con acarreo');
gettext('Sumador de un dos operandos de 8 bits (sin acarreo)');
gettext('## POSICION DEL OBJETO\n\npos(n) = pos(n-1) + vel(n-1)\n\nLa posición varia de 0 a 255 (8 bits)  \nCuando supera ese rango (overflow) se  \nda por terminada la caida');
gettext('Caida libre finalizada');
gettext('Posición inicial');
gettext('Posición actual');
gettext('Tic que indica que hay  \nuna nueva posición');
gettext('## VELOCIDAD DEL OBJETO\n\nVel(n) = vel(n-1) + acc(n-1)\n\n');
gettext('Salida de   \ndesbordamiento');
gettext('## ACELERACIÓN\n\nInicialmente la aceleración es 0.  \nCuando se carga el registro con \nun valor, comienza el movimiento  \nde la partícula');
gettext('Velocidad inicial');
gettext('Acceleración de la particula');
gettext('Estado de la partícula:  \n0: Reposo (estado inicial)  \n1: En caida libre');
gettext('Assignar aceleración  \n¡Que comience la caida!');
gettext('Los cálculos sólo se realizan  \nsi la partícula ha empezado a  \ncaer');
gettext('¡Que comience la fiesta!');
gettext('Academia-Jedi');
gettext('Emojis');
gettext('Agujero-negro');
gettext('First image of a Black Hole');
gettext('**Black Hole!**');
gettext('Jedi-collection');
gettext('Sticker con el logo de la Jedi Collection');
gettext('[Jedi Collection](https://github.com/FPGAwars/Collection-Jedi)  \n\n![](https://github.com/Obijuan/digital-electronics-with-open-FPGAs-tutorial/raw/master/wiki/Tutorial-31/jedi-collection-01.png)');
gettext('00-Pre');
gettext('01-Primero');
gettext('02-Segundo');
gettext('03-Tercero');
gettext('22-Caballero-Jedi');
gettext('Rango de Caballero Jedi. Tutorial I completado con máximos honores');
gettext('00-Observador');
gettext('Rango de Observador. Pre-academia Jedi');
gettext('01-Aspirante-a-Cadete');
gettext('Rango de Aspirante a Cadete. Pre-academia Jedi');
gettext('02-Cadete');
gettext('Rango de Cadete. Primer curso');
gettext('03-Cadete-N1');
gettext('Rango de Cadete Nivel 1. Primer curso');
gettext('04-Cadete-N2');
gettext('Rango de Cadete Nivel 2. Primer curso');
gettext('05-Cadete-N3');
gettext('Rango de Cadete Nivel 3. Primer curso');
gettext('06-Aspirante-Padawan');
gettext('Rango de Aspirante a Padawan. Primer curso');
gettext('07-Aspirante-Padawan-N1');
gettext('Rango de Aspirante a Padawan Nivel 1. Primer curso');
gettext('08-Aspirante-Padawan-N2');
gettext('Rango de Aspirante a Padawan Nivel 2. Primer curso');
gettext('09-Aspirante-Padawan-N3');
gettext('Rango de Aspirante a Padawan Nivel 3. Primer curso');
gettext('10-Padawan');
gettext('Rango de Padawan. Segundo curso');
gettext('11-Padawan-N1');
gettext('Rango de Padawan Nivel 1. Segundo curso');
gettext('12-Padawan-N2');
gettext('Rango de Padawan Nivel 2. Segundo curso');
gettext('13-Padawan-N3');
gettext('Rango de Padawan Nivel 3. Segundo curso');
gettext('14-Aspirante-Jedi');
gettext('Rango de Aspirante a Jedi. Segundo curso');
gettext('15-Aspirante-Jedi-N1');
gettext('Rango de Aspirante a Jedi Nivel 1. Segundo curso');
gettext('16-Aspirante-Jedi-N2');
gettext('Rango de Aspirante a Jedi Nivel 2. Segundo curso');
gettext('17-Aspirante-Jedi-N3');
gettext('Rango de Aspirante a Jedi Nivel 3. Segundo curso');
gettext('18-Jedi');
gettext('Rango de Jedi. Tercer curso');
gettext('19-Jedi-N1');
gettext('Rango de Jedi Nivel 1. Tercer curso');
gettext('20-Jedi-N2');
gettext('Rango de Jedi Nivel 2. Tercer curso');
gettext('21-Jedi-N3');
gettext('Rango de Jedi Nivel 3. Tercer curso');
gettext('Smiley');
gettext('Stickers de Smiley');
gettext('caca');
gettext('Caca sonriente');
gettext('like');
gettext('Like');
gettext('DHTxx');
gettext('Displays');
gettext('DHTxx_Driver');
gettext('Toma los datos del DHT22 y DHT11 (AM230x).');
gettext('00 = línea a 1; 01 = pone la línea a 0; 10 = esperar dos flancos de bajada del DHT; 11 = leer los 40 bits.');
gettext('Demultiplexor de 1 bit, de 2 a 4');
gettext('Ha de transcurrir 18ms estando la línea baja.');
gettext('Espera el flanco de bajada de la línea, luego de subida y después el de bajada de nuevo.');
gettext('Puerta OR de 3 entradas');
gettext('Detecta los bits que son 0 ó 1 y los va metiendo en un registro de desplazamiento. Cuando llega a los 40 bits los muestra por la salida.');
gettext('Registro de desplazamiento (izquierda) de 32 bits');
gettext('Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos');
gettext('Registro de 8 bits');
gettext('Separador de bus de 40-bits en 5 buses de 8 bits');
gettext('Contador módulo M, ascendente, de 6 bits, con reset ');
gettext('Detector de flancos de subida y bajada. Emite tic por las salidas correspondientes al detecta los flancos');
gettext('Filtro digital para eliminación de señales espúreas.');
gettext('Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato');
gettext('Puerta NOR');
gettext('Corazón de bombeo de tics a con periodo paramétrico de segundos');
gettext('## Existen 4 ciclos:\n\n### Ciclo 0:\nNo hacer nada. Espera a que ocurra un tic del reloj de segundos (corazón).\n\n### Ciclo 1:\nConvertimos \"pin\" en salida y obliga a \"pin\" a ponerse a 0 [entre 18(min.) a 20 milisegundos (max.)]; sólo actuará como salida en este ciclo, en los demás ciclos siempre será de entrada (de escucha). Esta señal a 0 lo interpretará el DHTxx como señal de que ha de enviar los datos que tenga el sensor en ese momento.\n\n### Ciclo 2:\nPonemos \"pin\" en modo escucha (como entrada) y esperará leer dos flancos de bajada.\n\n### Ciclo 3:\nEn esta fase se interpreta las anchuras de pulsos recibidos como 0s y 1s, en total 40 bits. Una vez recopilados esos 40 bits se pondrán en paralelo para que otros circuitos dispongan de los datos extraídos.\n\nEl primer ciclo es provocado por un reloj que emite un pulso cada 2 (o más) segundos. Nunca ha de ser menor de 2 segundos.\n\nCada vez que termina un ciclo se emite un tic a un contador unido a un decoder, avisa al módulo correspondiente para que se ponga en marcha y cumpla su función específica. Pues cada vez que termina de realizar la función designada emitirá un tic para pasar al siguiente ciclo.');
gettext('# Driver DHTxx');
gettext('Pin I/O. Se ha de conectar al pin 2 del DHTxx');
gettext('Tiempo de muestreo');
gettext('Primero hace un tic de reset y luego un tic de poner en marcha los ciclos.');
gettext('Info: https://groups.google.com/forum/#!topic/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg');
gettext('### Etapa de demultiplexación:\n\nSegún el número que tenga el contador (fuera de este circuito) activará el ciclo correspondiente.');
gettext('Sólo en el ciclo 1 \"pin\" será una salida que pondrá a cero dicha salida.\nen los demás ciclos se pondrá como entrada.');
gettext('Cuando \"ena\" se pone a 1, comienza una temporización que ha de ser de entre 18ms y 20ms y la línea de datos estará a 0 (en otra parte del circuito se hace eso).\nTranscurrido ese tiempo la línea de datos pasará a 1.');
gettext('\"Escucha\" la entrada de la línea y cuando\ndetecta que ha habido dos flancos\nde bajada significa que puede pasar\nal siguiente ciclo, que será leer la información\ndel DHT.');
gettext('0 = Disable.\n\n1 = Enable.');
gettext('### Por la entrada \"rd\" entra un tipo de onda donde un periodo alto de 70us significa que es un 1 lógico y si dicho periodo alto fuese de 26us significaría que es un cero.\n\n### Debido a que tanto en los ciclos altos como bajos a veces contiene señales espúreas, hay que limpiar dicha señal y de ello se encarga un filtro digital. Dicho filtro modifica un poco los periodos de las señales (las enlonga ligeramente), entonces se han ampliado el periodo de las señales. Es por ello que toda señal que dure menos de 100us se considera un 0, de lo contrario un 1.\n\n### En cada flanco de bajada memoriza dicho bit, cocatenándolo en un registro de desplazamiento de 40bits.\n\n### Finalmente, cuando el contador cuenta 40 flancos de bajada es cuando los 40bits son memorizados y puestos a la salida. Debido al pequeño retraso del filtro hay que retardar un poco el tic de salida de la patilla \"end\" que avisa que se ha finalizado todo este proceso y ya se puede validar los datos. ');
gettext('# Filter');
gettext('# Periods ---> bits');
gettext('# Bits concatenation');
gettext('# Parallel data output');
gettext('## Detector doble: flancos de subida y bajada\n\nSe detectan tanto los flancos de subida como de bajada y se emite los  \ntics por sus salidas correspondientes');
gettext('Señal de  \nentrada');
gettext('Reloj del  \nsistema');
gettext('# Filtro digital para eliminar señales espúreas que se puedan producir mientras la señal está en \"alto\" o en \"bajo\" durante la comunicación de datos.');
gettext('# Los flip-flops puestos como registros de desplazamiento trocean la señal en el tiempo. Cada trocito de ese tiempo hemos de comprobar si en los 18 flip-flops todos esos trocitos son 1, o bien, si todos son 0. Sólo cuando todos los flip-flops sean 1 consideraremos que realmente la señal  es 1; y sólo cuando todos los flip-flops sean 0 consideraremos que realmente la señal es 0. La báscula RS se encarga de poner dicho 0 ó 1 a la salida.');
gettext('COM-1129-SparkFun');
gettext('MAX7912');
gettext('char-4');
gettext('Char_4++: Controlador para display SPI de 4 digitos, modelo COM-1129 de SparkFun. Puntos y control del Brillo');
gettext('Multiplexor de 16 a 1 de 8 bits');
gettext('Agregador de 2 buses de 2 y 6-bits a bus de 8-bits');
gettext('SPI master. Realiza una transacción');
gettext('Señal de reloj de 8 pulsos, a 2MHZ / DIV (con divisor) ');
gettext('Temporizador en tics. La señal p está activa durante los tics indicados. ov se emite un tic al finalizar');
gettext('2bits constant value: 0');
gettext('Generic: 2-bits generic constant (0,1,2,3)');
gettext('8bits constant value: 0');
gettext('### Controlador para display SPI de 4 dígitos 7 segmentos\n\nModelo: COM-1129-SPARKFUN\n\nCada vez que se recibe un tic por load se muestran los dígitos en el  \ndisplay');
gettext('**Máquina de contar**');
gettext('La máquina  \nejecuta 9 pasos');
gettext('Ejecutar paso i  \n(i = 0..8)');
gettext('Fin del paso i: hacer que  \nla máquina vaya al paso i+1');
gettext('**Multiplexor 16 a 1**');
gettext('Comando para borrar el display  \ny llevar el cursor a la posición  \noriginal');
gettext('Control de la señal SS:  \nAl cargar un nuevo valor se activa (0)  \nCuando se termina se desactiva  ');
gettext('Tic de visualización  \nCada vez que se recibe se  \nactualizan los dígitos');
gettext('Comando POINT');
gettext('Argumento  \ncomando POINT');
gettext('Comando BRIGHT');
gettext('Argumento  \ncomando BRIGHT');
gettext('**Temporizacion del SPI**');
gettext('**Registro de**   \ndesplazamiento');
gettext('Se generan 8 pulsos de  \nreloj, a 2MHZ');
gettext('**Dato recibido**');
gettext('Activar esclavo  \n(a nivel bajo)');
gettext('Captura del dato que  \nllega del esclavo');
gettext('En el modo 0 (CPOL=0, CPHA=0)  \nSe captura en flanco de subida');
gettext('Los datos se sacan por  \nMOSI en el flanco de  \nbajada');
gettext('En el tic de arranque  \nse carga el registro  \ncon los datos a enviar');
gettext('## SPI Maestro. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ\n\nBloque maestro de SPI');
gettext('Retrasar la señal done un ciclo  \npara sincronizarlo con data');
gettext('En el último pulso se  \ncaputra el dato, y se emite  \nel tic de done');
gettext('Sacar la señal de  \nreloj maestra');
gettext('Generación del Slave-select  \npor defecto: Al comenzar (start) se pone a 0 y  \nse vuelve a poner a al finalizar (done)');
gettext('Con cada flanco se cambia  \nla salida del reloj');
gettext('Generador de la  \nonda cuadrada');
gettext('Máquina que genera una señal de  \nreloj de 2MHZ / DIV . Solo se emiten  \n8 pulsos con cada activación\n\n| DIV |  Frecuencia |\n|-----|-------------|\n| 1   |  2MHz       |\n| 2   |  1MHz       |\n| 4   |  500Khz     |\n| 8   |  250Khz     |\n| 16  |  125Khz     |\n');
gettext('Tic de flanco  \nde subida');
gettext('Tic de flanco  \nde bajada');
gettext('Retrasar done un periodo porque  \ncoincide con down');
gettext('Metemos un ciclo de  \nretraso para que arranque con  \nun ciclo más de retraso con  \nrespecto a la señal ss');
gettext('Retrasar busy para que cuadre  \ncon done');
gettext('**Divisor**');
gettext('digitos-4');
gettext('Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun');
gettext('Multiplexor de 8 a 1 de 8 bits');
gettext('Agregador de 2 buses de 4-bits a bus de 8-bits');
gettext('Valor constante 0 para bus de 4 bits');
gettext('Valor genérico constante, de 4 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('La máquina  \nejecuta 5 pasos');
gettext('Ejecutar paso i  \n(i = 0, 1, 2, 3 y 4)');
gettext('**Multiplexor 8 a 1**');
gettext('Poner a 0 los 4 bits  \nde mayor peso del digito');
gettext('Entradas  \nNO usadas');
gettext('digitos4++');
gettext('Digitos_4++: Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun. Puntos y control del Brillo');
gettext('segment-4');
gettext('Segment-4: Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun. Puntos y control del Brillo');
gettext('Agregador de 1 cable y un bus de 7-bits a bus de 8-bits');
gettext('07-Reg: 7 bits Register. Verilog implementation');
gettext('La máquina  \nejecuta 13 pasos');
gettext('Ejecutar paso i  \n(i = 0...12)');
gettext('Poner el bit de mayor  \npeso a 0');
gettext('time-4');
gettext('Time-4: Controlador para display SPI de 4 digitos modelo COM-1129 de SparkFun');
gettext('Inyectar el valor de un cable por el bit indicado de un bus');
gettext('La máquina  \nejecuta 7 pasos');
gettext('Los dos puntos se  \ninsertan en el bit 4');
gettext('Construir el argumento para el  \ncomando POINT: todos los bits  \na cero salvo el 4, que contiene  \nel estado de los dos puntos');
gettext('Argumento comando POINT');
gettext('MAX7912_driver');
gettext('Inicializa el MAX7212 a modo displays.');
gettext('SPI Master de 16 bits mode=0');
gettext('Registro de desplazamiento (izquierda) de 8 bits');
gettext('Registro de 16 bits');
gettext('Señal de reloj de 16 pulsos, a 2MHZ / DIV (con divisor) ');
gettext('Biestable de cambio (Tipo T). Cuando se recibe un tic cambia de estado');
gettext('Detector de flancos de subida y bajada. Emite tics por las salidas correspondientes al detecta los flancos. Versión bloques');
gettext('Sumador de un operando de 5 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Registro de 5 bits.');
gettext('Comparador de dos operandos de 5 bits');
gettext('Valor genérico constante, de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('Multiplexor de 2 a 1 de 16 bits');
gettext('Emite un solo tic al iniciarse la FPGA.');
gettext('DFF ini = 0');
gettext('Circuito combinacional de 4 entradas y 16 salidas');
gettext('Registro de 4 bits con entrada de reset');
gettext('El circuito inicializa el MAX7912 para prepararlo como periférico para displays. Una vez que ha inicializado, por la patilla\n\"iniTic\" saldrá un tic para avisar de que ya puede aceptar datos como un SPI convencional, pero adaptado para el MAX7912.\nEsto significa que hasta que no tengamos un tic por la salida \"iniTic\" no se debe enviar datos al SPI master.');
gettext('Tiempo mínimo para\nque el MAX7912 se\ninicialice antes\nde enviar datos.');
gettext('Número máximo +1 que\nhaya en la tabla CMD.');
gettext('Secuencia para configurar el MAX7912\ncomo displays de 8 dígitos. Por defecto\nse encendrán todos los puntos de dichos\ndígitos.');
gettext('Maestro SPI de 16 bits Mode 0.');
gettext('Info: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/paT6PNjgmnE/60Ob5vREAAAJ');
gettext('Señal de entrada  \nactual');
gettext('Estado de la señal  \nen el instante anterior');
gettext('Si señal actual es 1  \nY la señal anterior  \nes 0, es que ha llegado  \nun flanco');
gettext('**Retraso**: 0  \nEl retraso es cero porque hay un  \ncamino de retraso 0 desde la entrada  \na cada una de las salidas');
gettext('Si la señal actual es 0  \npero la anterior era 1,  \nha llegado un flanco  \nde bajada');
gettext('Este circuito emite un solo \"tic\" después de transcurrir\n500ms de iniciarse la FPGA.');
gettext('blocks');
gettext('pres-basic');
gettext('09-bits');
gettext('pres-basic');
gettext('Prescaler básico de 9 bits, implementado con bloques');
gettext('Sumador de un operando de 9 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Extractor de 1 bit de un bus de 9 bits');
gettext('09-Sys-reg: 9 bits system register. Verilog implementation');
gettext('Extrar el bit de  \nmayor peso');
gettext('Registro que almacena  \nla cuenta actual (CONT)');
gettext('Incrementar la cuenta');
gettext('CONT = CONT + 1  \nSe actualiza en el  \nsiguiente tic del sistema');
gettext('Tortuga-2');
gettext('Divisor entre dos');
gettext('Tortuga: Divisor entre 2\n\nImplementado a partir de un\nbiestable T síncrono');
gettext('Hacer que solo responda a los flancos\nde subida de la señal de entrada');
gettext('SPI-master');
gettext('SPI-slave');
gettext('SPI_Master_16bits');
gettext('parts');
gettext('SPI_Master_Multibytes');
gettext('3 MHz speed SPI master with mode 0, 1, 2 and 3');
gettext('* With \"mode\" set to 0 it supports SPI modes 0 and 1.\n* With \"mode\" set to 1 it supports SPI modes 2 and 3.');
gettext('### Pending to verify the operation of modes 2 and 3.');
gettext('serial-SPI-mode0-2MHz-div');
gettext('Pasarela serie-SPI-master. Acceso a periféricos SPI desde el PC');
gettext('Transmisor serie');
gettext('Datos recibidos  \ndesde el PC');
gettext('**Receptor Serie**');
gettext('**Gestion de la señal SS:**  \nCuando se recibe un caracter por el puerto  \nserie se pone a 0 (si ya estaba se deja a 0)  \nSi transcurren 200µs desde que se envió por  \nel SPI el último byte se lleva ss a reposo (1)');
gettext('**Transmisor serie**');
gettext('Datos enviados \nhacia el PC');
gettext('serial-SPI-mode0-2MHz');
gettext('Señal de reloj de 8 pulsos, a 2MHZ');
gettext('Esta estructura en anillo genera  \nexactamente una señal de 2Mhz, cuando  \nel reloj del sistema es de 12Mhz');
gettext('Contador de flancos');
gettext('En total llegan 16 flancos  \n8 de subida y 8 de bajada');
gettext('Solo se permite el paso  \nde tics mientras la  \nmáquina esté encendida');
gettext('Cada 3 tics llega un  \nflanco');
gettext('Tic de arranca o  \nde siguiente. Se dejan  \npasar');
gettext('Máquina que genera una señal de  \nreloj de 2MHZ. Solo se emiten  \n8 pulsos con cada activación');
gettext('spi-master-mode0-2MHZ');
gettext('spi-master-mode0-2MHz-div');
gettext('Heart-num16-2MHZ');
gettext('Máquina de contar, de 5 bits');
gettext('5-bits adder. One operand is a constant (no carry)');
gettext('two operand 5-bits comparator');
gettext('Valor genérico constante (menos 1), de 5 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('05-Reg-rst: 5 bits Register with reset. Verilog implementation');
gettext('Heart-num8-2MHZ');
gettext('SPI-heart-2MHZ-DIV');
gettext('SPI-heart-2MHZ');
gettext('timer-system-spi');
gettext('Test');
gettext('SPI-cmd-regs');
gettext('Implementación de los 3 comandos para acceder a los registros mapeados');
gettext('Detectar el comando, y devolver los valores que llegan tras el comando');
gettext('Habilitación de bus de 8 bits');
gettext('## SPI-cmd-regs\n\nImplementacion de los comandos de acceso a registros:  \n* Establecer la dirección del registro (SAP)  \n* Lectura de registro (RD)  \n* Escritura en registro (WR)  \n');
gettext('### Comando SET ADDRESS POINTER');
gettext('**Registro**  \n**de dirección**  ');
gettext('### Comando Escritura en Registro');
gettext('### Comando Lectura de Registro');
gettext('Tic de lectura');
gettext('**ENTRADAS**');
gettext('**SALIDAS**');
gettext('Reset de los bloques  \nsintácticos');
gettext('Se hace reset de los bloques sintáticos cuando se ha  \ndetectado alguno de los comandos, o bien llega un reset  \ndesde el exterior');
gettext('**Comando detectado**');
gettext('Habilitar la salida del tic  \ndel proximo dato: es un valor');
gettext('Solo se comprueba  \nel comando cuando  \nllega un tic');
gettext('SPI-slave-mode0-2MHZ');
gettext('Unidad SPI sclava. Transmisor y receptor');
gettext('**Dato de entrada**  \nSincronizados con el  \nreloj del sistema');
gettext('Todos los pines de entrada del SPI  \nse sincronizan con el reloj del sistema');
gettext('Flanco de subida del  \nreloj sclk');
gettext('Captura de los datos  \nen flanco de subida  \nde la señal SCLK');
gettext('Solo se hace caso a SCLK si  \nel esclavo está seleccionado  \n(SS debe estar a 0)');
gettext('**Registro de**\n**Desplazamiento**');
gettext('### Transmisión de los datos');
gettext('Bit de salida,  \nhacia el Maestro');
gettext('Registro de datos  \nAquí se guarda el  \ndato que se quiere  \ntransmitir');
gettext('Se transmite un bit cada  \nvez que se recibe un  \nflanco de bajada de SCLK');
gettext('Al comienzo de una transaccion  \n(Flanco de bajada en SS) o  \ndespues de terminar la transacción  \nanterior, se carga el registro  \nde desplazamiento con el siguiente valor');
gettext('Contador de bits de  \nla transacción actual  \nCuando es 0, significa que  \nestá en reposo. Cuando es  \n!=0 es que hay una transacción  \nen curso');
gettext('El overflow indica que  \nque la transacción  \nha finalizado');
gettext('Cuando el esclavo NO está  \nseleccionado, el contador  \nestá en RESET');
gettext('**Registro de**  \n**desplazamiento**');
gettext('Recepción de datos  \ndel Maestro');
gettext('Almacenar el dato  \nrecibido');
gettext('### Recepción de datos');
gettext('Retrasamos la captura 2 ciclos para  \ndejar ese tiempo al circuito para que  \nhaga calculos, si necesita. Debe cargar  \nel nuevo valor antes de que concluyan los  \ndos ciclos de reloj posteriores a la finalización  \nde la transacción anterior');
gettext('Cuaando el esclavo NO está seleccionado  \nla salida MISO está en alta impedancia  \nEsto permite conectar varios módulos esclavos');
gettext('Flanco de bajada\ndel reloj sclk');
gettext('Los datos que llegan se  \ncapturan en flanco de  \nsubida de SCLK');
gettext('Los datos se depositan en MISO en el flanco de bajada de SCLK  \nComo la señal es de 2MHZ, hay 3 tics por periodo. Cuando llega un  \nflanco de subida, en el esclavo está retrasada 2 tics por la  \nsincronizacion. Un ciclo despues llega el flanco de bajada  \nEsa es la razón de que tics_down esté retrasasa un ciclo con  \nrespecto a tics-up');
gettext('## SPI Esclavo. MODO 0. CPOL=0, CPHA=0, 2MHZ');
gettext('SPI-slave-unit');
gettext('Dos Biestables de datos (Tipo D) encadenados');
gettext('InOut-Right:  InOut block, with the pin on the right side');
gettext('**BIT**: Tic que indica que  \nhay un bit que ha llegado');
gettext('Se transmite un bit cada  \nvez que se recibe un  \nflanco de subida de SCLK');
gettext('spi-slave-test-cmd');
gettext('Unidad spi esclavo de prueba. Implementa los comandos write_led y read_buttons. ');
gettext('Detección de pulsación. Emite un tic cada vez que se aprieta el pulsador');
gettext('**Pines BUS SPI**');
gettext('**Pin BUS SPI**');
gettext('**Bloque SPI-esclavo**');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **READ_BUTTONS**      | 0x60       | Lectura de los pulsadores          |');
gettext('### Comando WRITE_LEDs');
gettext('**Registro**  \n**de LEDs**');
gettext('Valor inicial para  \nlos LEDs');
gettext('Estado  \npulsador 1');
gettext('Estado  \npulsador 2');
gettext('Construir el byte a transmitir  \nal maestro: Todos los bits a 0  \nsalvo los dos de menos peso, que  \ncontienen Sw1 y SW2');
gettext('### Comando READ_BUTTONS');
gettext('Tic de lectura de  \nlos pulsadores');
gettext('Este comando no tiene argumentos adicionales:  \nen cuanto se recibe el código de comando,  \nse usa el tic recibido para cargar el estado  \nde los pulsadores en el registro de transmisión  \ndel SPI para que se envíe en la próxima transacción  ');
gettext('Bloque SPI esclavo de test: Implementa dos comandos, uno para escribir en los LEDs y otro para leer los pulsadores');
gettext('## SPI esclavo completo. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ');
gettext('**Pulsador-tic**');
gettext('spi-slave-test-echo');
gettext('Unidad spi esclavo de prueba. Todo lo recibido se saca por los LEDs y se devuelve en la siguiente transacción (eco)');
gettext('Bloque SPI esclavo de test: Todo lo que recibe en un transacción lo saca por los leds y lo almacena\npara devolverlo en la siguiente (Eco). Justo después del reset devuelve un 0 en la primera transacción');
gettext('Todo lo recibido se vuelve a  \nenviar en la siguiente transacción');
gettext('spi-slave-test-id');
gettext('Unidad spi esclavo de prueba. En cada transacción obtiene el dato recibido y envía la constante ID. Es para hacer pruebas con los maestros');
gettext('Bloque SPI esclavo de test: Devuelve siempre la misma constante al leer, y todo lo recibido lo saca por los LEDS');
gettext('Constante a devolver al maestro  \nen todas las transacciones');
gettext('Flanco de baja en ss:  \ncomienza una nuestra transacción  \n');
gettext('Cargar el identificador  \nal comienzo de la transacción  \npara devolverlo como dato de  \nsalida');
gettext('spi-slave-test-regs');
gettext('Unidad spi esclavo de prueba. Implementa 3 registros mapeados en memoria: leds, buttons e id');
gettext('Button-tic: Configurable button that emits a tic when it is pressed');
gettext('Configurable button (pull-up on/off. Not on/off)');
gettext('FPGA internal pull-up configuration on the input port');
gettext('Select positive or negative logic for the input (0=positive, 1=negative)');
gettext('Unibus-access-8-bits: Access to a 8-bit unidirectional bus');
gettext('2-to-1 Multplexer (8-bit channels)');
gettext('2-to-1 Multplexer (4-bit channels)');
gettext('2-to-1 Multplexer (1-bit channels)');
gettext('## COMANDOS\n\n| Comando | Abrev. | Código | Descripción |\n|---------|-------------|----------------|-------------|\n| **SET ADDRES POINTER ** *val* | SAP  | 0x7D       | Establecer el valor del registro de dirección |\n| **WRITE REGISTER** *val*      | WR   | 0x7E       | Escribir en el registro apuntado por el registro de dirección |\n| **READ REGISTER**             | RD   | 0x7F       | Leer el registro apuntado por el registro de dirección |\n\n');
gettext('### Registro de LEDs');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| 12h  | R     |  PULSADORES | Estado de los pulsadores SW1 y SW2 | 00h |\n| FDh  | R     |  ID | Código de identificación del periférico | 50h |\n');
gettext('Valor por defecto');
gettext('**Código de los comandos**');
gettext('**BUS de direcciones**');
gettext('**BUS de datos** de entrada');
gettext('**Bloque cmd-reg**');
gettext('**Bloque Reg-addr**');
gettext('**BUS de control** ');
gettext('### Registro de Identificacion');
gettext('### Registro de pulsadores');
gettext('Número que identifica  \na este periférico');
gettext('Detectar accesos a su dirección');
gettext('Dirección donde está  \nmapeada la constante');
gettext('Dirección de  \nmapeo');
gettext('## SPI esclavo completo. Modo 0: CPOL=0, CPHA=0. Velocidad: 2MHZ\n\nBloque SPI esclavo de test: Implementa el acceso a 3 registros mapeados en memoria:  \nUno para acceso a los LEDs, otro para leer los pulsadores y otro para leer el  \nidentificadoor del periférico');
gettext('**Lectura de registros**:  \nDevolver el contenido del registro seleccionado  \nSi no hay ninguno seleccionado se devuelve  \nel valor 0x00');
gettext('Valor a enviar al  \nmaestro, en la  \nlectura');
gettext('**BUS de datos**  \nde salida');
gettext('Valor a devolver cuando  \nno hay ningun registro  \nseleccionado');
gettext('Button state signal');
gettext('Tic: button pressed');
gettext('Rising edge detector');
gettext('Pull up on/off');
gettext('Not on/off');
gettext('Internal pull-up  \n* 0: OFF\n* 1: ON');
gettext('Synchronization stage');
gettext('Normalization stage\n\n* 0: Wire\n* 1: signal inverted');
gettext('Debouncing stage');
gettext('When k=0, it works like a wire  \n(The output is equal to the input)  \nWhen k=1, it act as a not gate\n(The output is the inverse of the input)');
gettext('### Truth table for XOR\n\n| k | input | output | function |\n|---|-------|--------|----------|\n| 0 | 0     |  0     | wire     |\n| 0 | 1     |  1     | wire     |\n| 1 | 0     |  1     | Not      |\n| 1 | 1     |  0     | Not      |');
gettext('Channel B');
gettext('Channel A');
gettext('SPI16master');
gettext('Emax-ES08A');
gettext('Futaba-3003');
gettext('TowerPro-SG90');
gettext('blocks');
gettext('ServoPWM-8bits');
gettext('Controlador de servos, de 8 bits. El periodo del PWM por defecto es de 20ms (Futaba 3003)');
gettext('**Salida PWM**');
gettext('Conectar directamente  \nal servo');
gettext('Posición del servo. Indica el  \nancho del pulso en unidades de  \n10 usec. Así, un valor de 60  \nindica una anchura de 600 usec');
gettext('Tic de escritura de  \nuna nueva posición');
gettext('Habilitación del servo');
gettext('ServoBit-90');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit para microservos EMAX ES08A. Controlador de 1 bit para mover el servo a las 2 posiciones POS0 y POS1');
gettext('**Posición 1**: Posición del servo cuando  \nse introduce un 1\n\nEl valor por defecto es de 135 grados\n');
gettext('**Posición 0**: Posición del servo cuando  \nse introduce un 0\n\nEl valor por defecto es de 45 grados');
gettext('**Entrada**: posición a donde llevar  \nel servo (posición 0 ó 1)');
gettext('**Servobit paramétrico** para los microservos **EMAX-ES08A** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **580 usec**  \n* Extremo izquierdo **2550 usec**\n');
gettext('ServoBit');
gettext('Servobit-90');
gettext('ServoBit para Futaba 3003. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('ServoBit paramétrico para Futaba 3003. Controlador de 1 bit para mover el servo a las 2 posiciones P0 y P1');
gettext('**Servobit** para Servos Futaba 3003 o comaptibles\nLas dos posiciones están distanciadas **90 grados**  \n\n* **Posicion 0**: 45 grados  \n* **Posicion 1**: 135 grados  ');
gettext('**Servobit paramétrico** para los microservos **Futaba 3003** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **380 usec**  \n* Extremo izquierdo **2410 usec**\n');
gettext('Servobit');
gettext('Servobit-90');
gettext('ServoBit para micrservo TowerPro-SG90. Controlador de 1 bit para mover un servo a 2 posiciones. El ángulo entre una posición y otra es de 90 grados');
gettext('**Servobit paramétrico** para los microservos **TowerPro SG-90** o compatibles\n\nLos parámetros **P1** y **P0** son las posiciones asociadas a un valor de la entrada de 1 ó 0  \nEstán expresados en **micro-segundos** (usec). Este tiempo es el ancho del pulso\n\nSus **valores** deben estar comprendidos en este rango: \n\n* Extremo derecho: **500 usec**  \n* Extremo izquierdo **2350 usec**\n');
gettext('Servobit');
gettext('ServoPWM-8bits');
gettext('Temporizador en unidades de 10 usec');
gettext('Temporizador  \nTiempo en unidades  \nde 10us');
gettext('Genera el ancho del  \npulso según el  \nvalor de delay que  \nindique el usuario');
gettext('**Registro posición**');
gettext('Almacena la posición actual  \ndel servo');
gettext('**Registro de**  \n**estado**');
gettext('0: Servo deshabilitado  \n1: Servo activado');
gettext('**Periodo del PWM**');
gettext('Por cada periodo nuevo se  \ngenera un pulso nuevo, de anchura  \nespecificada por su registro  \nde posición');
gettext('ServoTime-20ms');
gettext('note');
gettext('Emitir un tono (onda cuadrada) definido por su divisor');
gettext('cmd8');
gettext('tablas_bin');
gettext('tablas_hex');
gettext('1bit_entrada');
gettext('2bit_entrada');
gettext('3bit_entrada');
gettext('4bit_entrada');
gettext('5bit_entrada');
gettext('6bit_entrada');
gettext('7bit_entrada');
gettext('8bit_entrada');
gettext('tabla-bin-1-1');
gettext('Circuito combinacional de 1 entradas y 1 salidas');
gettext('tabla-bin-1-2');
gettext('Circuito combinacional de 1 entradas y 2 salidas');
gettext('tabla-bin-1-3');
gettext('Circuito combinacional de 1 entradas y 3 salidas');
gettext('tabla-bin-1-4');
gettext('Circuito combinacional de 1 entradas y 4 salidas');
gettext('tabla-bin-1-5');
gettext('Circuito combinacional de 1 entradas y 5 salidas');
gettext('tabla-bin-1-6');
gettext('Circuito combinacional de 1 entradas y 6 salidas');
gettext('tabla-bin-1-7');
gettext('Circuito combinacional de 1 entradas y 7 salidas');
gettext('tabla-bin-1-8');
gettext('Circuito combinacional de 1 entradas y 8 salidas');
gettext('tabla-bin-2-1');
gettext('Circuito combinacional de 2 entradas y 1 salidas');
gettext('tabla-bin-2-2');
gettext('tabla-bin-2-3');
gettext('Circuito combinacional de 2 entradas y 3 salidas');
gettext('tabla-bin-2-4');
gettext('tabla-bin-2-5');
gettext('Circuito combinacional de 2 entradas y 5 salidas');
gettext('tabla-bin-2-6');
gettext('Circuito combinacional de 2 entradas y 6 salidas');
gettext('tabla-bin-2-7');
gettext('Circuito combinacional de 2 entradas y 7 salidas');
gettext('tabla-bin-2-8');
gettext('tabla-bin-3-1');
gettext('Circuito combinacional de 3 entradas y 1 salidas');
gettext('tabla-bin-3-16');
gettext('Circuito combinacional de 3 entradas y 16 salidas');
gettext('tabla-bin-3-2');
gettext('Circuito combinacional de 3 entradas y 2 salidas');
gettext('tabla-bin-3-3');
gettext('Circuito combinacional de 3 entradas y 3 salidas');
gettext('tabla-bin-3-4');
gettext('Circuito combinacional de 3 entradas y 4 salidas');
gettext('tabla-bin-3-5');
gettext('Circuito combinacional de 3 entradas y 5 salidas');
gettext('tabla-bin-3-6');
gettext('Circuito combinacional de 3 entradas y 6 salidas');
gettext('tabla-bin-3-7');
gettext('Circuito combinacional de 3 entradas y 7 salidas');
gettext('tabla-bin-3-8');
gettext('Circuito combinacional de 3 entradas y 8 salidas');
gettext('tabla-bin-4-1');
gettext('Circuito combinacional de 4 entradas y 1 salidas');
gettext('tabla-bin-4-16');
gettext('tabla-bin-4-18');
gettext('Circuito combinacional de 4 entradas y 18 salidas');
gettext('tabla-bin-4-19');
gettext('Circuito combinacional de 4 entradas y 19 salidas');
gettext('tabla-bin-4-2');
gettext('Circuito combinacional de 4 entradas y 2 salidas');
gettext('tabla-bin-4-3');
gettext('Circuito combinacional de 4 entradas y 3 salidas');
gettext('tabla-bin-4-4');
gettext('Circuito combinacional de 4 entradas y 4 salidas');
gettext('tabla-bin-4-5');
gettext('Circuito combinacional de 4 entradas y 5 salidas');
gettext('tabla-bin-4-6');
gettext('Circuito combinacional de 4 entradas y 6 salidas');
gettext('tabla-bin-4-7');
gettext('Circuito combinacional de 4 entradas y 7 salidas');
gettext('tabla-bin-4-8');
gettext('tabla-bin-4-9');
gettext('Circuito combinacional de 4 entradas y 9 salidas');
gettext('tabla-bin-5-1');
gettext('Circuito combinacional de 5 entradas y 1 salidas');
gettext('tabla-bin-5-17');
gettext('Circuito combinacional de 5 entradas y 17 salidas');
gettext('tabla-bin-5-19');
gettext('Circuito combinacional de 5 entradas y 19 salidas');
gettext('tabla-bin-5-2');
gettext('Circuito combinacional de 5 entradas y 2 salidas');
gettext('tabla-bin-5-3');
gettext('Circuito combinacional de 5 entradas y 3 salidas');
gettext('tabla-bin-5-4');
gettext('Circuito combinacional de 5 entradas y 4 salidas');
gettext('tabla-bin-5-5');
gettext('Circuito combinacional de 5 entradas y 5 salidas');
gettext('tabla-bin-5-6');
gettext('Circuito combinacional de 5 entradas y 6 salidas');
gettext('tabla-bin-5-7');
gettext('Circuito combinacional de 5 entradas y 7 salidas');
gettext('tabla-bin-5-8');
gettext('Circuito combinacional de 5 entradas y 8 salidas');
gettext('tabla-bin-6-1');
gettext('Circuito combinacional de 6 entradas y 1 salidas');
gettext('tabla-bin-6-16');
gettext('Circuito combinacional de 6 entradas y 16 salidas');
gettext('tabla-bin-6-2');
gettext('Circuito combinacional de 6 entradas y 2 salidas');
gettext('tabla-bin-6-20');
gettext('Circuito combinacional de 6 entradas y 20 salidas');
gettext('tabla-bin-6-3');
gettext('Circuito combinacional de 6 entradas y 3 salidas');
gettext('tabla-bin-6-4');
gettext('Circuito combinacional de 6 entradas y 4 salidas');
gettext('tabla-bin-6-5');
gettext('tabla-bin-6-6');
gettext('Circuito combinacional de 6 entradas y 6 salidas');
gettext('tabla-bin-6-7');
gettext('Circuito combinacional de 6 entradas y 7 salidas');
gettext('tabla-bin-6-8');
gettext('Circuito combinacional de 6 entradas y 8 salidas');
gettext('tabla-bin-7-1');
gettext('Circuito combinacional de 7 entradas y 1 salidas');
gettext('tabla-bin-7-2');
gettext('Circuito combinacional de 7 entradas y 2 salidas');
gettext('tabla-bin-7-21');
gettext('Circuito combinacional de 7 entradas y 21 salidas');
gettext('tabla-bin-7-3');
gettext('Circuito combinacional de 7 entradas y 3 salidas');
gettext('tabla-bin-7-4');
gettext('Circuito combinacional de 7 entradas y 4 salidas');
gettext('tabla-bin-7-5');
gettext('Circuito combinacional de 7 entradas y 5 salidas');
gettext('tabla-bin-7-6');
gettext('Circuito combinacional de 7 entradas y 6 salidas');
gettext('tabla-bin-7-7');
gettext('Circuito combinacional de 7 entradas y 7 salidas');
gettext('tabla-bin-7-8');
gettext('Circuito combinacional de 7 entradas y 8 salidas');
gettext('tabla-bin-8-1');
gettext('Circuito combinacional de 8 entradas y 1 salidas');
gettext('tabla-bin-8-2');
gettext('Circuito combinacional de 8 entradas y 2 salidas');
gettext('tabla-bin-8-3');
gettext('Circuito combinacional de 8 entradas y 3 salidas');
gettext('tabla-bin-8-4');
gettext('Circuito combinacional de 8 entradas y 4 salidas');
gettext('tabla-bin-8-5');
gettext('Circuito combinacional de 8 entradas y 5 salidas');
gettext('tabla-bin-8-6');
gettext('Circuito combinacional de 8 entradas y 6 salidas');
gettext('tabla-bin-8-7');
gettext('Circuito combinacional de 8 entradas y 7 salidas');
gettext('tabla-bin-8-8');
gettext('Circuito combinacional de 8 entradas y 8 salidas');
gettext('1bit_entrada');
gettext('2bit_entrada');
gettext('3bit_entrada');
gettext('4bit_entrada');
gettext('5bit_entrada');
gettext('6bit_entrada');
gettext('7bit_entrada');
gettext('8bit_entrada');
gettext('9bit_entrada');
gettext('tabla-hex-1-1');
gettext('tabla-hex-1-2');
gettext('tabla-hex-1-3');
gettext('tabla-hex-1-4');
gettext('tabla-hex-1-5');
gettext('tabla-hex-1-6');
gettext('tabla-hex-1-7');
gettext('tabla-hex-1-8');
gettext('tabla-hex-2-1');
gettext('tabla-hex-2-2');
gettext('tabla-hex-2-3');
gettext('tabla-hex-2-4');
gettext('tabla-hex-2-5');
gettext('tabla-hex-2-6');
gettext('tabla-hex-2-7');
gettext('tabla-hex-2-8');
gettext('tabla-hex-3-1');
gettext('tabla-hex-3-12');
gettext('Circuito combinacional de 3 entradas y 12 salidas');
gettext('tabla-hex-3-16');
gettext('tabla-hex-3-2');
gettext('tabla-hex-3-3');
gettext('tabla-hex-3-4');
gettext('tabla-hex-3-5');
gettext('tabla-hex-3-6');
gettext('tabla-hex-3-7');
gettext('tabla-hex-3-8');
gettext('tabla-hex-3-9');
gettext('Circuito combinacional de 3 entradas y 9 salidas');
gettext('tabla-hex-4-1');
gettext('tabla-hex-4-12');
gettext('Circuito combinacional de 4 entradas y 12 salidas');
gettext('tabla-hex-4-16');
gettext('tabla-hex-4-2');
gettext('tabla-hex-4-20');
gettext('Circuito combinacional de 4 entradas y 20 salidas');
gettext('tabla-hex-4-3');
gettext('tabla-hex-4-32');
gettext('Circuito combinacional de 4 entradas y 32 salidas');
gettext('tabla-hex-4-4');
gettext('tabla-hex-4-5');
gettext('tabla-hex-4-6');
gettext('tabla-hex-4-7');
gettext('tabla-hex-4-8');
gettext('tabla-hex-5-1');
gettext('tabla-hex-5-16');
gettext('Circuito combinacional de 5 entradas y 16 salidas');
gettext('tabla-hex-5-2');
gettext('tabla-hex-5-3');
gettext('tabla-hex-5-4');
gettext('tabla-hex-5-5');
gettext('tabla-hex-5-6');
gettext('tabla-hex-5-7');
gettext('tabla-hex-5-8');
gettext('tabla-hex-5-9');
gettext('Circuito combinacional de 5 entradas y 9 salidas');
gettext('tabla-hex-6-1');
gettext('tabla-hex-6-16');
gettext('tabla-hex-6-2');
gettext('tabla-hex-6-3');
gettext('tabla-hex-6-4');
gettext('tabla-hex-6-5');
gettext('tabla-hex-6-6');
gettext('tabla-hex-6-7');
gettext('tabla-hex-6-8');
gettext('tabla-hex-6-9');
gettext('Circuito combinacional de 6 entradas y 9 salidas');
gettext('tabla-hex-7-1');
gettext('tabla-hex-7-2');
gettext('tabla-hex-7-3');
gettext('tabla-hex-7-4');
gettext('tabla-hex-7-5');
gettext('tabla-hex-7-6');
gettext('tabla-hex-7-7');
gettext('tabla-hex-7-8');
gettext('tabla-hex-8-1');
gettext('tabla-hex-8-16');
gettext('Circuito combinacional de 8 entradas y 16 salidas');
gettext('tabla-hex-8-2');
gettext('tabla-hex-8-3');
gettext('tabla-hex-8-4');
gettext('tabla-hex-8-5');
gettext('tabla-hex-8-6');
gettext('tabla-hex-8-7');
gettext('tabla-hex-8-8');
gettext('tabla-hex-9-1');
gettext('Circuito combinacional de 9 entradas y 1 salidas');
gettext('tabla-hex-9-12');
gettext('Circuito combinacional de 9 entradas y 12 salidas');
gettext('tabla-hex-9-16');
gettext('Circuito combinacional de 9 entradas y 16 salidas');
gettext('tabla-hex-9-6');
gettext('Circuito combinacional de 9 entradas y 6 salidas');
gettext('tabla-hex-9-9');
gettext('Circuito combinacional de 9 entradas y 9 salidas');
gettext('Comp-clk');
gettext('Generic component with clk input');
gettext('Generic component with  \nsystem clock input');
gettext('Comp');
gettext('Componente genérico');
gettext('Const');
gettext('Doc');
gettext('Bloque con documentación');
gettext('Documentación genérica');
gettext('blocks');
gettext('Programmable_timer_us');
gettext('Programmable timer.');
gettext('Corazón de bombeo de tics a con periodo paramétrico de microsegundos');
gettext('Contador descendente de 8 bits. ');
gettext('### Temporizador programable. ###\n\n* Cuando llega a 0 un contador interno se para y \"ov\" produce un tic.\n\n* Si \"in\" = 0 entonces no hay tic de salida.\n\n* Es a partir de 1 hasta 255 que obtendremos tics de salida en diferentes tiempos; se ha de validar la entrada con \"ld\" y el temporizador se pondrá en marcha.\n\n* Cuanto más alto sea la entrada \"in\" mayor tiempo en producirse el tic de salida. Por ejemplo, si la entrada vale 1 y damos un tic en \"ld\" al cabo de 1ms (1000us) se producirá un tic por \"ov\". Si en \"in\" pusieramos el valor 50, al darle un tic a la patilla \"ld\" se produciría un tic al cabo de 50ms, etc.');
gettext('# Programmable Discounter.');
gettext('El flip-flop y la AND evita que al ponerse en marcha dé un pulso, porque \"ov\" se pondrá a 1.');
gettext('bus-cycle');
gettext('Generar un ciclo de bus');
gettext('timer-10usec');
gettext('timer-msec-rst');
gettext('timer-msec-stop');
gettext('Timer in ms, with stop input');
gettext('timer-msec');
gettext('timer-sec');
gettext('timer-system');
gettext('timer-usec-rst');
gettext('timer-usec');
gettext('timer-10usec');
gettext('Corazón de bombeo de tics, cuyo periodo está especificado en micro-segundos. Solo se hace el bombeo cuando está habilitado');
gettext('Comparador de dos operandos de 8 bits');
gettext('Almacenar el tiempo  \nde espera al arrancar');
gettext('**Registro de**  \n**espera**');
gettext('**Contador de**  \n**tiempo**');
gettext('Cada unidad de tiempo  \nson 10 usecs');
gettext('Contador en reset  \ncuando apagado');
gettext('¿Han transcurrido el tiempo  \nindicado por el registro  \nde espera?');
gettext('Ha transcurrido el tiempo indicado');
gettext('**Biestable**  \n**de estado**');
gettext('0: Apagado  \n1: Funcionando');
gettext('VGA-retro');
gettext('Monster-LED-green');
gettext('Convertir la pantalla de la VGA en un LED gigante. Version para la AP-VGA');
gettext('Generador de sencuencias refresco horizontales y verticales para monitor VGA. Resolucion 256x240');
gettext('Comparador mayor o igual que, de un operando de 10 bits');
gettext('Comparador menor o igual que, de un operando de 10 bits');
gettext('Comparador menor que, de un operando de 10 bits');
gettext('Agregador de 2 cables en un bus de 2-bits');
gettext('Comparador mayor o igual que, de un operando de 9 bits');
gettext('Comparador menor o igual que, de un operando de 9 bits');
gettext('Comparador menor que, de un operando de 9 bits');
gettext('Contador del sistema, de 9 bits, con salida de valor máximo alcanzado');
gettext('Contador módulo M, ascendente, de 10 bits, con reset ');
gettext('Multiplicador de cables. Genera un bus de 2 bits, con la entrada duplicada');
gettext('Adaptador para placa AP-VGA');
gettext('Bus4-Join-half: Join the two buses into a 4-bits Bus');
gettext('VS (VERTICAL)  ');
gettext('**VGA**');
gettext('R0');
gettext('R1');
gettext('B0');
gettext('B1');
gettext('G0');
gettext('G1');
gettext('**Estado fondo pantalla**:  \n0: Negro  \n1: Verde  ');
gettext('Actualizar el estado del fondo:  \nSólo se captura cuando ha  \nterminado el frame');
gettext('HS (VERTICAL)  ');
gettext('**Bit del canal verde**:  \n0: Pixel negro (apagado)  \n1: Pixel verde (Máxima intensidad)');
gettext('Fondo activo y estamos  \nen zona visible');
gettext('**Canales Azul y Rojo desactivados**');
gettext('Adaptador AP-VGA');
gettext('Tamaño de la línea en píxeles.  \nCada pixel es igual a  un tic  \n');
gettext('Comienzo del pulso de  \nsincronismo horizontal  \n');
gettext('Fin del pulso de sincronismo  \nhorizontal  \n');
gettext('**Calculo de parámetros HORIZONTALES**  \nH_MAX = H_DISPLAY + H_BACK + H_FRONT + H_SYNC - 1  \nHS_START = H_DISPLAY + H_FRONT  \nHS_END = H_DISPLAY + H_FRONT + HSYNC -1  ');
gettext('Tamaño vertical  \nen líneas');
gettext('Comienzo del pulso de  \nsincronismo vertical\n');
gettext('Fin del pulso de  \nsincronismo vertical\n');
gettext('**Calculo de parámetros VERTICALES**  \nV_MAX = V_DISPLAY + V_BOTTOM + V_TOP + V_SYNC - 1  \nVS_START = V_DISPLAY + V_TOP \nVS_END = V_DISPLAY + V_TOP + VSYNC -1  ');
gettext('**Sincronización horizontal**  \n\n* H_DIPLAY = 305 -->  Resolución  \n* H_FRONT = 7  \n* H_SYNC = 46\n* H_BACK = 23  \n');
gettext('**Sincronización vertical**  \n\n* V_DIPLAY = 480 -->  Resolución  \n* V_TOP = 10 \n* V_SYNC = 2\n* V_BOTTOM = 33  \n');
gettext('```\n                         H_MAX (pixeles)  \n<------------------------------------------------------------>  \nH_DISPLAY (visible)      |   H_FRONT   | H_SYNC   |  H_BACK  |\n<------------------------><------------><--------><---------->  \n                                       ^          ^           \n                                       |          |   \n                                   HS_START     HS_END\n```');
gettext('**Generación ventana visibilidad**');
gettext('**Display_on**');
gettext('Funciona con los dos monitores: Fuji y LCDtv  \n\nAunque he tenido que ajustar la posición dentro del propio  \nmonitor  ');
gettext('Señales de sincronía:  \nvhs[1]: VS  \nvhs[0]: HS');
gettext('Sincronismo HORIZONTAL');
gettext('Sincronismo\nVERTICAL');
gettext('Sync');
gettext('Test-FPGAwars');
gettext('Test for the VGA-retro');
gettext('Dibujar un marco que cubre toda la zona visible. Muy util para ajustar el monitor');
gettext('Bus8-Split-half: Split the 8-bits bus into two buses of 1 and 7 wires');
gettext('b6: **HS. HORIZONTAL**  ');
gettext('**SINCRONISMO**');
gettext('### Rectángulo rojo relleno');
gettext('La señal es visible');
gettext('La imagen solo se muestra en la primera mitad vertical  \n(En la segunda mitad se activan no hay imagen)');
gettext('v y h son las direcciones de cada pixel');
gettext('Todo se trasa un ciclo de reloj');
gettext('Duplicar el cable');
gettext('b5: **B0**');
gettext('b4: **B1**');
gettext('b3: **G0**');
gettext('b2: **G1**');
gettext('**VERDE**');
gettext('b1: **R0**');
gettext('b0: **R1**');
gettext('**ROJO**');
gettext('**AZUL**');
gettext('b7: **VS. VERTICAL**  ');
gettext('## Inyectar información de cada canal');
gettext('### Marco azul perimetral');
gettext('### Imagen verde');
gettext('## Dibujar 3 elementos, cada uno en un color');
gettext('## Generador de señales para VGA');
gettext('## Conector placa AP-VGA');
gettext('Modulo for drawing a frame around the visible zone  \n');
gettext('VGA-LED-2v');
gettext('Dos LEDs verticales en la VGA');
gettext('Separador de bus de 8-bits en 2 buses de 1 y 7 bits');
gettext('Cualquier señal enviada al  \ncanal de color tiene que  \nestar a 0 cuando la señal NO  \nes visible');
gettext('Señal vídeo  \nde la Barra 1');
gettext('Combinación de las  \nseñales de Vídeo:  \nBarra1 + Barra0');
gettext('Señal vídeo  \nde la Barra 0');
gettext('Se entra en la zona de la  \nbarra 0 cuando hpos[7]=0');
gettext('**Estado Barra 0**');
gettext('**Estado Barra 1**');
gettext('Actualizar el estado de la \nBarra 1 cada vez que se  \nacaba de dibujar un frame');
gettext('Extraer Bit de mayor  \npeso de hpos  \n');
gettext('frame');
gettext('Icemove4');
gettext('Icemove4: Controlador de 4 movimientos para el Icebot');
gettext('# ICEmove4\n\nControlador para el [robot Icebot](https://github.com/Obijuan/icebot/wiki), que genera **4 movimientos**:  \nParado, giro derecha (arco), giro izquierda (arco) y adelante');
gettext('**Código del movimiento**');
gettext('**Motor de la rueda derecha**');
gettext('**Motor de la rueda izquierda**');
gettext('## Tabla de movimientos\n\n| Código de entrada | Movimiento del Robot   |\n|-------------------|------------------------|\n|  0                |  Parado                |\n|  1                |  Giro derecha (arco)   |\n|  2                |  Giro izquierda (arco) |\n|  3                |  Adelante              |');
gettext('**Entrada de reloj**');
gettext('Icemove9');
gettext('Icemove9: Controlador de 9 movimientos para el Icebot');
gettext('# ICEmove9\n\nControlador de 9 movimientos para el robot Icebot  \n(Entrada de 4 bits)');
gettext('## Tabla de movimientos\n\n| Código de entrada | Movimiento del Robot   |\n|-------------------|------------------------|\n|  0, 1, 2, 3       |  Parado                |\n|  4,6              |  Arco derecha          |\n|  5,7              |  Arco izquierda-atrás  |\n|  8,9              |  Arco derecha-atrás    |\n|  10,11            |  Arco izquierda        |\n|  12               |  Giro derecha          |\n|  13               |  Atrás                 |\n|  14               |  Adelante              |\n|  15               |  Giro izquierda        |');
gettext('sp-1');
gettext('Stack pointer for 1 element');
gettext('**Stack state:**  \n0: empty  \n1: Full');
gettext('##  SP-1  \nStack pointer for stacks of only 1 element!  \n');
gettext('The stack is empty');
gettext('The stack is full');
gettext('The push cmd is valid is the  \nstack is empty');
gettext('Push command');
gettext('Pop command');
gettext('The pop cmd is only valid  \nif the stack is full');
gettext('According to the stack state,  the  \npop command is either ok or  \nunderflow!');
gettext('According to the statck state,  the  \npush command is either ok or  \noverflow!');
gettext('sp-2');
gettext('Stack pointer for 2 elements');
gettext('##  SP-2  \nStack pointer for stacks of two elementos  \n');
gettext('According to the statck state,  the  \npop command is either ok or  \nunderflow!');
gettext('Load a new value  \nin the SP register');
gettext('**SP Register**');
gettext('reset the SP');
gettext('ADC');
gettext('Displays');
gettext('LEDs');
gettext('Memory');
gettext('Motors');
gettext('PWM');
gettext('Pines-ES');
gettext('Pulsadores');
gettext('SPI');
gettext('Teclado');
gettext('Test');
gettext('VGA');
gettext('peripherals');
gettext('01-Potentiometer-LEDs-2');
gettext('Bus12-Split-one-third: Split the 12-bits bus into three buses of equal size');
gettext('**ADC_SDA** (INOUT)  ');
gettext('**ADC_SCL**');
gettext('**Frecuencia de**  \n**muestreo**');
gettext('**Canal 0**');
gettext('## Ejemplo 1-2: Lectura de un potenciómetro\n\nSe lee el potenciómetro conectado al canal 0 de la icezum Alhambra  \ny se muestra su valor digital (8 bits) en los LEDs  \nLa lectura se realiza 20 veces por segundo (20Hz)');
gettext('**Conversor A/D**');
gettext('Valor digital del  \npotenciómetro');
gettext('01-Potentiometer-LEDs');
gettext('## Ejemplo 1: Lectura de un potenciómetro\n\nSe lee el potenciómetro conectado al canal 0 de la icezum Alhambra  \ny se muestra su valor digital (8 bits) en los LEDs  \nLa lectura se realiza 20 veces por segundo (20Hz)');
gettext('02-Potentiometer-serial');
gettext('Serial transmitter with system clock freq parameter');
gettext('## Ejemplo 2: Lectura de un potenciómetro y envío al PC\n\nSe lee el potenciómetro conectado al canal 0 de la icezum Alhambra  \ny se envía su valor digital al PC, además de mostrarse en los LEDs  \nLa lectura se realiza 100 veces por segundo (100Hz)');
gettext('03-Potentiometer-servo');
gettext('## Ejemplo 3: Moviendo un servo con el potenciómetro  \n\nLa salida del conversor A/D se conecta a la entrada de un servo para  \ncambiar su posición con el potenciómetro\n\n');
gettext('04-Potentiometer-BCD-7Seg');
gettext('Separador de bus de 8-bits en buses de 4 bits');
gettext('## Ejemplo 4: Mostrar potenciómetro en un display de 7 segmentos  \n\nEl valor analógico se divide en 16 niveles (4 bits) y se muestra en un  \ndisplay de 7 segmentos como un dígito hexadecimal. Sólo hay que quedarse  \ncon los 4 bits más significativos de la muestra y sacarlos por el  \n7 segmentos\n');
gettext('Mostrar el valor en  \nbinario en los LEDs');
gettext('Mostrar el valor en  \nel display de 7 seg  \nen hexadecimal');
gettext('4 bits de mayor peso  \nde la muestra');
gettext('Se puede ver en funcionamiento en este [vídeo de Youtube](https://www.youtube.com/watch?v=8GTkoyxFUTY):\n\n[![Click to see the youtube video](http://img.youtube.com/vi/8GTkoyxFUTY/0.jpg)](https://www.youtube.com/watch?v=8GTkoyxFUTY)');
gettext('05-Potentiometer-8LEDs');
gettext('Separador de bus de 8-bits en 2 buses de 3 y 4 bits');
gettext('Decoder-3-8:  3 to 8 decoder. Output bus');
gettext('Bus8-Join-all: Join all the wires into a 8-bits Bus');
gettext('Decoder-3-8:  3 to 8 decoder');
gettext('Decoder-1-2:  1 to 2 decoder');
gettext('Bus3-Split-1-2: Split the 3-bits bus into two: 1-bit and 2-bits buses');
gettext('Decoder-2-4:  2 to 4 decoder. Output bus');
gettext('Decoder-2-4:  2 to 4 decoder');
gettext('Bus2-Split-all: Split the 2-bits bus into two wires');
gettext('AND-Busen-4: Enable a 4-bits bus. When the enable signal is 0, the output is 0');
gettext('## Ejemplo 5: Usar el potenciómetro para seleccionar entre 8 opciones  \n\nEl valor analógico se divide en 8 niveles (3 bits) y se muestra en los  \n8 LEDs, encendiendo un único led por cada nivel. Esto permite usarlo como  \nun selector entre 8 opciones\n');
gettext('Decodificador de  \n3 a 8');
gettext('Se puede ver en funcionamiento en este [vídeo de Youtube](https://www.youtube.com/watch?v=SLV-YsCvrmw):\n\n[![Click to see the youtube video](http://img.youtube.com/vi/SLV-YsCvrmw/0.jpg)](https://www.youtube.com/watch?v=SLV-YsCvrmw)');
gettext('Active when the input  \nis 4-7');
gettext('Active when the input  \nis 0-3');
gettext('## Truth table\n\n| input   |  o7     | o6     | o5     | o4     | o3     | o2    | o1     | o0     |\n|---------|---------|--------|--------|--------|--------|-------|--------|--------|\n| 000     |   0     | 0      |  0     | 0      | 0      | 0     |  0     | **1**  |\n| 001     |   0     | 0      |  0     | 0      | 0      | 0     |  **1** | 0      |\n| 010     |   0     | 0      |  0     | 0      | 0      | **1** |  0     | 0      |\n| 011     |   0     | 0      |  0     | 0      | **1**  | 0     |  0     | 0      |\n| 100     |   0     | 0      |  0     | **1**  | 0      | 0     |  0     | 0      |\n| 101     |   0     | 0      |  **1** | 0      | 0      | 0     |  0     | 0      |\n| 110     |   0     | **1**  |  0     | 0      | 0      | 0     |  0     | 0      |\n| 111     |   **1** | 0      |  0     | 0      | 0      | 0     |  0     | 0      |\n\n');
gettext('## Truth table\n\n|i  |  o1 | o0 |\n|---|-----|----|\n|0  |  0  |  1 |\n|1  |  1  |  0 |');
gettext('## Truth table\n\n| input  |  o3 | o2 | o1 | o0 |\n|--------|-----|----|----|----|\n| 00     |   0 | 0  |  0 | 1  |\n| 01     |   0 | 0  |  1 | 0  |\n| 10     |   0 | 1  |  0 | 0  |\n| 11     |   1 | 0  |  0 | 0  |\n\n');
gettext('Enable input');
gettext('Bus input');
gettext('Bus output');
gettext('01-Potentiometer-LEDs');
gettext('01-Potentiometer-LEDs-2');
gettext('02-Potentiometer-serial');
gettext('03-Potentiometer-servo');
gettext('04-Potentiometer-BCD-7Seg');
gettext('05-Potentiometer-8LEDs');
gettext('Alhambra II_adc-test-01');
gettext('COM-1129-SparkFun');
gettext('SPI');
gettext('01-spi-serial-test');
gettext('### Ejemplo 1: Probando el display desde el PC\n\nEjemplo del usao de la pasarela SERIE-SPI para manejar el display SPI de 4  \ndígitos de 7 segmentos. Es necesario usar un divisor de 8 para que la  \nfrecuencia del reloj sea de 250Khz (por especificaciones del display)');
gettext('Frecuencia de funcionamiento:  \n2Mhz / 8 = 250Khz');
gettext('Datos recibidos desde el PC  \npor el puerto serie para  \nenviarlos al display');
gettext('Del display no se recibe  \nnada. No conectamos MISO');
gettext('No hay que enviar nada  \nal PC de vuelta. No  \nconectamos TX');
gettext('02-Digito-pulsador');
gettext('### Ejemplo 2: Mostrar un dígito constante al apretar el pulsador\n\nSe debe probar después de haber alimentado el display. Cada vez que se aprieta  \nel pulsador sw1, se muestra el dígito 3 en la posición del cursor del display');
gettext('Número constante a  \nsacar por el display');
gettext('03-Digito-aleatorio');
gettext('### Ejemplo 3: Mostrar un dígito \"aleatorio\" al apretar el pulsador\n\nCada vez que se aprieta SW1 se muestra un dígito entre 0 y 9 en el display,  \nque proviene de un contador módulo 10 que está incrementándose a la frecuencia  \nde 1Mhz');
gettext('**Contador**');
gettext('Los 4 bits de mayor  \npeso del dato enviado  \nsiempre están a 0');
gettext('Frecuencia: 1MHz');
gettext('Dígito (0-9)');
gettext('04-Digito-aleatorio-cls');
gettext('### Ejemplo 4: Dígito aleatorio y Borrado de pantalla\n\nCuando se aprieta el pulsador SW1, se muestra un número aleatorio entre  \n0 y 9. Cuando se aprieta SW2 se ejecuta el comando CLS para borrar  \nel display\n\n');
gettext('Número  \n\"aleatorio\"');
gettext('Comando CLS');
gettext('**Codificador**  \n2 a 1');
gettext('Pulsador de CLS');
gettext('1: Botón de CLS  \n0: Botón de datos');
gettext('Pulsador: Sacar  \nun dato');
gettext('Alguno de los dos pulsadores  \nse ha apretado');
gettext('**Multiplexor**');
gettext('08-contador-100-decimas');
gettext('### Ejemplo 8: Contador de 100 décimas\n\nEjemplo de uso del controlador del display de 7 segmentos:  \nContador de 100 décimas, de 0 a 99');
gettext('**Contador de**  \n**décimas**');
gettext('Digitos de mayor peso:  \nlos dos a cero');
gettext('**Contador de**  \n**segundos**');
gettext('**Controlador**  \ndel display SPI');
gettext('Bloque digitos-4');
gettext('Tiempo de una  \ndécima en ms');
gettext('09-minutero-segundero-mm_ss');
gettext('### Ejemplo 9: Minutero y segundero\n\nLlevar la cuenta de los minutos y segundos, empezando desde  \n00:00. Cada medio segundo se cambia el estado de los dos  \npuntos, para mostrar actividad en el reloj. Los segundos se  \nmuestran en los dos dígitos de la derecha, y los minutos en  \nlos dos de la izquierda\n');
gettext('**Unidades**  ');
gettext('**Decenas**');
gettext('Bloque **Time-4**');
gettext('**Unidades**');
gettext('Estado de los  \ndos puntos (:)');
gettext('Cada medio segundo se  \nactualiza el display');
gettext('Cada medio segundo se  \ncambia el estado de  \nlos dos puntos');
gettext('10-contador-hexa-0000-FFFF');
gettext('Control del brillo con pulsadores up/down');
gettext('Sumador de un operando de 8 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('06-SL-ld: 6 bits shift left register with load. Verilog implementation');
gettext('### Ejemplo 10: Contador hexadecimal con animación\n\nContador de 4 dígitos hexadecimales, que cuenta desde 0000 hasta  \nFFFF. Se incrementa cada décima de segundo. Además se realiza  \nuna animación en los puntos, enviando un valor desplazado un bit  \na la izquierda cada medio segundo\n\nEl brillo del display se controla mediante los pulsadores');
gettext('Bloque **Digitos-4++**');
gettext('Control del brillo del display');
gettext('Animacion de los puntos:  \nDesplazamiento a la izquierda  \ndel bit, cada medio segundo');
gettext('El contador se incrementa  \ncada décima de segundo (100ms)');
gettext('El display se actualiza  \ncada décima de segundo');
gettext('Registro  \nprincipal');
gettext('Incremento');
gettext('Decremento');
gettext('top = 1 cuando se  \nha llegado al límite  \nsuperior');
gettext('¿Contador = Max?');
gettext('¿Contador = Min?');
gettext('bott = 1 cuando se  \nha llegado al límite  \ninferior');
gettext('Registro inicializado  \ncon el valor máximo');
gettext('**Brillo**');
gettext('**Incrementos**  \n**del brillo**');
gettext('**Casos en los que NO se incrementa el brillo:**  \n\nEn esos casos se deshabilita el corazón');
gettext('El brillo está al máximo y se está  \napretando el botón de UP');
gettext('El brillo está al mínimo y se está  \napretando el botón de DOWN');
gettext('Deshabilitar  \ncorazón');
gettext('**Las entradas deben**  \n**ser los pulsadores**');
gettext('11-secuencia-texto');
gettext('Separador de bus de 32-bits en 4 buses de 8 bits');
gettext('Valor constante 0, de 6 bits');
gettext('Valor genérico constante, de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('### Ejemplo 11: Texto animado\n\nMostrar una animación con el texto \"HOLA FPGA\"  \nSe usa un contador que recorre una memoria de  \n16 x 32, que contiene en cada posición los  \ncuatro caracteres que se deben mostrar  en  \nel display en cada momento');
gettext('Duración de cada mensaje  \nen la animación');
gettext('Todos los puntos  \ndesactivados');
gettext('12-animacion-segmentos');
gettext('Agregador de 1 cable y un bus de 6 bits a bus de 7-bits');
gettext('6bits constant value: 0');
gettext('Generic: 6-bits generic constant (0-63)');
gettext('06-SL: 6 bits shift left register. Verilog implementation');
gettext('### Ejemplo 12: Animación en los segmentos\n\nEjemplo de una animación usando segmentos individuales  \nSe usan 4 registros de desplazamiento, inicializados con  \ndiferentes valores. Se desplazan hacia la izquierda cada  \n100ms, generando la animación\n');
gettext('Bloque **Segment-4**');
gettext('Desplazar los registros cada 100ms');
gettext('01-spi-serial-test');
gettext('02-Digito-pulsador');
gettext('03-Digito-aleatorio');
gettext('04-Digito-aleatorio-cls');
gettext('08-contador-100-decimas');
gettext('09-minutero-segundero-mm_ss');
gettext('10-contador-hexa-0000-FFFF');
gettext('11-secuencia-texto');
gettext('12-animacion-segmentos');
gettext('Ejemplo-03-grupo-ocho-leds');
gettext('Multiplicador de cables. Genera un bus de 8 bits, a patir del bit de entrada');
gettext('### Ejemplo 3: Un grupo de 8 LEDs brillando a su máxima intesidad  \n\nSe encienden los ocho leds, del 0 al 7, como si fuesen un único LED  \nSe usa un bloque multiplicador de cables de 8 bits');
gettext('Bit que define el  \nestado del grupo  \nde LEDs');
gettext('**Grupo de 8 LEDs**');
gettext('Bloque multiplicador  \ndel cables:  \n**mult-1-8-bus**');
gettext('Ejemplo-05-grupo-ocho-leds-brillo-bajo');
gettext('Fijar el brillo constante para el LED');
gettext('8-bits Syscounter with reset');
gettext('08-Sys-reg-rst: 8 bits system register with reset. Verilog implementation');
gettext('### Ejemplo 5: Grupo de 8 LEDs con brillo bajo  \n\nSe enciende un grupo de 8 LEDs con brillo bajo');
gettext('**Niveles de Brillo**  \n0 : Apagado  \n255: Máxima intensidad');
gettext('**Bloque Brillo-LED**');
gettext('el contador  \nvuelve a comenzar desde 0  \n');
gettext('Ejemplo-08-degradado-8-LEDs');
gettext('### Ejemplo 8: Degradado en 8 LEDs\n\nColocamos 8 bloques brillo-LED en paralelo para obtener un  \ndegradado de brillo desde 256 hasta 32, en saltos de 32,  \nen los 8 LEDs\n\n');
gettext('Ejemplo-10-Potenciometro-grupo-8-LEDs');
gettext('### Ejemplo 10: Control del brillo con un potenciometro\n\nEl nivel de brillo se establece con un potenciómetro leido a  \ntravés del conversor A/D de la Alhambra-II');
gettext('Brillo-LED');
gettext('Multiplicador  \nde cables');
gettext('Frecuencia de muestreo  \ndel potenciómetro');
gettext('Ejemplo-12-fundido-desvanecimiento-pulsador');
gettext('Brillo gradual entre los dos extremos (Máx y Min). La entrada indica el brillo objetivo (1=Máximo, 0=Mínimo)');
gettext('Contador ascendente/descendente con límites');
gettext('Agregador de 3 cables en un bus de 3-bits');
gettext('### Ejemplo 12: Fundido y desvanecimiento con pulsador\n\nMientras el pulsador esté apretado, se realiza un encendido progresivo  \nde los LEDs (fundido). Al cabo de 2 segundo se habrá alcanzado el brillo  \nmáximo. Al soltar el pulsador se realiza un desvanecimiento\n');
gettext('**Transición**');
gettext('Multiplicador de  \ncables');
gettext('**Bloque brillo-gradual**');
gettext('| Top | Bot | dir | enable | Descripción |\n|-----|-----|-----|--------|------|\n|  0  |  0  |  x  |  1     | Limites no alcanzados |\n|  0  |  1  |  0  |  0     | Limite inferior. No dec |\n|  0  |  1  |  1  |  1     | Limite inferior, pero inc |\n|  1  |  0  |  0  |  1     | Limite sup, pero dec |\n|  1  |  0  |  1  |  0     | Limite sup. No inc   |\n|  1  |  1  |  x  |  0     | Imposible |');
gettext('Siguiente valor');
gettext('Según la dirección,  \nel se toma como sigueinte  \nvalor el incrementado o  \ndecrementado');
gettext('Circuito combinacional para habilitar o no  \nla cuenta. Si estamos en el límite inferior y  \nla dirección es descendente --> NO decrementar  \n\nSi estamos en el límite superior y la dirección es  \nascendente --> NO incrementar');
gettext('**Dirección**:  \n0 : Descendente  \n1 : Ascencente');
gettext('**Tic de cuenta**');
gettext('Dejar pasar el tic de  \ncuenta, o no');
gettext('Registro inicializado  \ncon el valor mínimo');
gettext('Ejemplo-14-LEDs-pulsantes-grupo-8');
gettext('Simplified-Heart-ms-sys-32bits: Nominal periodic signal in mili seconds');
gettext('### Ejemplo 14: Grupo de 8 LEDs pulsantes\n\nEl grupo de 8 LEDs se enciende y apagan progresivamente, con un periodo  \nde 2 segundos. El tiempo de transición es de 500ms');
gettext('**Periodo**');
gettext('Ejemplo-16-LEDs-estela');
gettext('Contador descendente con limite inferior. Cuando dir=1 se inicializa al valor máximo');
gettext('### Ejemplo 16: LEDs con estela\n\nEjemplo del bloque de desvanecimiento (fade-out) para mostrar la estela  \nde dos LEDs. Al apretar los pulsadores, el LED correspondiente se enciende  \ny luego se va desvaneciendo.\n\nEl **primer LED** está conectado al **tic** generado por el **pulsador SW1**. Nos permite  \ncomprobar cómo se visualizan los tics  \n\nEl **segundo LED** está conectado a la **salida de nivel** del pulsador **SW2**. Hasta que  \nno se suelta, no comienza el desvanecimiento\n');
gettext('**tic**');
gettext('**Tiempo de**  \n**desvanecimiento**');
gettext('**Nivel**');
gettext('Bloque fade-out');
gettext('tic');
gettext('Si contador es 0 y  \nla direccion es  \ndecremento, bloquear tic');
gettext('Si llega un tic  \nllevar el contador  \nal máximo');
gettext('Ejemplo-19-animacion-brillo-ajustable-teclas');
gettext('Establecimiento del brillo en un bus de 8 bits');
gettext('AND bit a bit entre dos buses de 8 bits');
gettext('Copy-8: Copy the input wire twice and generate a 8 bits Bus output (Verilog implementation)');
gettext('### Ejemplo 19: Animación con brillo ajustable con pulsadores\n\nSe saca una secuencia por los LEDs, y el brillo se ajusta  \nmediante los dos pulsadores de la Alhambra II\n');
gettext('Envío alternativo de los números  \n0xF0 y 0x0F, a la frecuencia  \nde 2Hz');
gettext('**Bloque Brillo-8**');
gettext('**Bloque Brillo-control**');
gettext('Establecer el nivel de brillo  \ncon dos pulsadores');
gettext('Ejemplo-21-contador-binario-gradual');
gettext('Desvanecimiento de los bits a 0 de números de 8 bits ');
gettext('### Ejemplo 21: Contador binarioSegundero con transiciones suaves\n\nSe muestra en los LEDs una cuenta en binario, cada segundo, donde las  \ntransiciones de los bits son suaves');
gettext('**Brillo-gradual-8**');
gettext('Ejemplo-22-segundero-gradual');
gettext('Transición gradual de brillo entre dos números de 7 bits');
gettext('Separador de bus de 7-bits en 7 cables');
gettext('Agregador de 7 cables de 1-bit a bus de 7-bits');
gettext('**Display de**  \n**7 segmentos**');
gettext('### Ejemplo 20: Segundero decimal con transiciones suaves\n\nPor el display de 7 segmentos se muestra una cuenta de 0 a 9,  \nincrementándose cada segundo. Las transiciones entre cada dígito son  \nsuaves, apareciendo y desapareciendo segmentos en un tiempo de 400ms');
gettext('**Contador**  ');
gettext('**Decodificador**  \n**BCD a 7 segmentos**');
gettext('**Bloque**  \n**Brillo gradual-7**');
gettext('Ejemplo-23-coche-fantastico');
gettext('### Ejemplo 23: Animación del coche fantástico\n\nAnimación del LED que \"va y viene\", dejando una estela. La longitud  \nde la estela depende de cuánto mayor es el tiempo de desvanecimiento  \ncon respecto al tiempo de paso del LED');
gettext('**Bloque fade-out-8**');
gettext('Animación del  \nLED que va i viene');
gettext('Generación de  \nla estela');
gettext('Ejemplo-24-contador-binario-efimero');
gettext('**fade-out**');
gettext('Retrasar 1 ciclo  \nde reloj el tic');
gettext('Convertir los 8 bits  \ndel número en 8 tics  \nen parlelo');
gettext('Número efímero  \nSólo dura 1 ciclo  \nde reloj');
gettext('### Ejemplo 24: Contador binario de números efímeros\n\nEn los LEDs se muestra una cuenta binaria, que se incrementa cada  \nsegundo. Cada número generado sólo se visualiza durante 400ms y  \nluego se desvanece: es efímero');
gettext('Ejemplo-25-contador-decimal-efimero');
gettext('Habilitación de bus de 7 bits');
gettext('Desvanecimiento de los bits a 0 de números de 7 bits ');
gettext('### Ejemplo 25: Contador decimal efímero\n\nPor el display de 7 segmentos se muestra una cuenta de 0 a 9,  \nincrementándose cada segundo. Cada número mostrado sólo dura 400ms.  \nUna vez que se visualiza se va desvaneciendo poco a poco hasta  \ndesaparecer');
gettext('Convertir los 7 bits  \ndel número en 7 tics  \nen parlelo');
gettext('**fade-out-7**');
gettext('Ejemplo-03-grupo-ocho-leds');
gettext('Ejemplo-05-grupo-ocho-leds-brillo-bajo');
gettext('Ejemplo-08-degradado-8-LEDs');
gettext('Ejemplo-10-Potenciometro-grupo-8-LEDs');
gettext('Ejemplo-12-fundido-desvanecimiento-pulsador');
gettext('Ejemplo-14-LEDs-pulsantes-grupo-8');
gettext('Ejemplo-16-LEDs-estela');
gettext('Ejemplo-19-animacion-brillo-ajustable-teclas');
gettext('Ejemplo-21-contador-binario-gradual');
gettext('Ejemplo-22-segundero-gradual');
gettext('Ejemplo-23-coche-fantastico');
gettext('Ejemplo-24-contador-binario-efimero');
gettext('Ejemplo-25-contador-decimal-efimero');
gettext('Test');
gettext('test-memory-128B-str');
gettext('128-bytes memory, initilized with a string');
gettext('Máquina de contar, de 7 bits');
gettext('7-bits adder. One operand is a constant (no carry)');
gettext('two operand 7-bits comparator');
gettext('Valor genérico constante (menos 1), de 7 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('07-Reg-rst: 7 bits Register with reset. Verilog implementation');
gettext('Serial transmiter for the stdout bus, with sysclk parameter');
gettext('stdout bus splitter into data and tic signals');
gettext('Convert the 1-bit next signal into a 10-bit stdout bus');
gettext('Transmit one character to the STDOUT bus');
gettext('Extract the next signal from the stdout bus');
gettext('stdout bus joiner (data + tic)');
gettext('2-to-1 Multplexer (10-bit channels). Verilog implementation');
gettext('8bits ASCII new line');
gettext('## Test Memory-128B-str\n\nThe 64-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('**START HERE**');
gettext('**Count machine**');
gettext('It address the memory,  \nsending the two addresses  \n(0/1)');
gettext('Synchronize the tic  \nwith the data from the  \nmemory (The reading is  \nsynchronous)');
gettext('### STDOUT management');
gettext('**New Line**');
gettext('Send the current byte  \nto the serial port');
gettext('REMEMBER:  \nThe memory changes the last  \ncharacter by '\\0'');
gettext('Show the current  \nvalue on the LEDs');
gettext('## STDOUT serial\n\nSerial transmitter for the STDOUT bus\n');
gettext('**STDOUT Bus**  \n* Data to transmit (8 bits)  \n* tic (1 bit)\n* data sent (done tic, 1 bit)');
gettext('## PUTC: Transmit one character (STDOUT bus)\n\nWhen **idle**, the STDOUT bus crosses the component without modification    \n\nWhen the machine starts, the char is outputed and the state is changed to busy  \nWhen the transmitter is done (tic received in next)  the machine is turned off');
gettext('Start tic: The byte from the  \ninput char is transmited');
gettext('Char to be transmited');
gettext('State of the machine:  \n1: ON: transmitting  \n2: OFF: transparent mode  ');
gettext('If the machine is on  \nand the character has been  \ntransmitted: Turn it off');
gettext('The machine has finished');
gettext('**STDOUT BUS**');
gettext('**Create the bus**  \nfrom the data and tic signals');
gettext('Transparent mode...  \nor not');
gettext('test-memory-128B');
gettext('128 Bytes Synchronous memory');
gettext('## Test Memory-128B\n\nThe 128-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-16B-str');
gettext('16-bytes memory, initilized with a string');
gettext('## Test Memory-16B-str\n\nThe 16-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-16B');
gettext('16 Bytes Synchronous memory');
gettext('## Test Memory-16B\n\nThe 16-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-256B-str');
gettext('256-bytes memory, initilized with a string');
gettext('Máquina de contar, de 8 bits');
gettext('Valor genérico constante (menos 1), de 8 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('## Test Memory-256B-str\n\nThe 256-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-256B');
gettext('256 Bytes Synchronous memory');
gettext('## Test Memory-256B\n\nThe 256-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-2B-str');
gettext('2-bytes memory, initilized with a string');
gettext('Mach-count-1-bit: 1-bit count machine');
gettext('1-to-2 DeMultplexer (1-bit channels)');
gettext('## Test Memory-2B-str\n\nThe 2-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('If the machine is active, no more start signals  \nare allowed to enter');
gettext('Execution tic:  \n* One tic per state');
gettext('1-bit counter');
gettext('1-to-2 Demux');
gettext('Turn off  \nthe machine');
gettext('n=1');
gettext('n=0');
gettext('The next signal can only go inside the machine  \nif it is busy');
gettext('The machine is busy from the very  \nbegining in which the start_ok  \nsignal arrives');
gettext('Initial state cycle  \n(n = 0)');
gettext('When the next_ok signal is received  \nthe initial cycles is finished');
gettext('When the next_ok is received the counter is  \nincreased');
gettext('The machine is active: either in the first  \nstate cycle (n=0) or the next cycles (n=1)');
gettext('Wait one cycle for the  \ncounter to be updated');
gettext('The next_ok signal output either as the  \nexec signal (when n=1) or as the done signal  \nwhen (n = 0)');
gettext('Then count machine has three states:  \n\n* Idle: The machine is off, waiting to receive the start signal  \n* n = 0: Initial state cycle. It goes from receiveing the start signal until  \n  the first next signal arrives\n* n = 1: second state cycle. Fron the first next signal to the second');
gettext('test-memory-2B');
gettext('2 Bytes Synchronous memory');
gettext('## Test Memory-2B\n\nThe 2-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-32B-str');
gettext('32-bytes memory, initilized with a string');
gettext('## Test Memory-32B-str\n\nThe 32-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-32B');
gettext('32 Bytes Synchronous memory');
gettext('## Test Memory-32B\n\nThe 32-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-4B-str');
gettext('4-bytes memory, initilized with a string');
gettext('## Test Memory-4B-str\n\nThe 2-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-4B');
gettext('## Test Memory-4B\n\nThe 4-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-64B-str');
gettext('Máquina de contar, de 6 bits');
gettext('6-bits adder. One operand is a constant (no carry)');
gettext('two operand 6-bits comparator');
gettext('Valor genérico constante (menos 1), de 6 bits. Su valor se introduce como parámetro. Por defecto vale 0');
gettext('06-Reg-rst: 6 bits Register with reset. Verilog implementation');
gettext('64-bytes memory, initilized with a string');
gettext('## Test Memory-64B-str\n\nThe 64-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-64B');
gettext('64 Bytes Synchronous memory');
gettext('## Test Memory-64B\n\nThe 64-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-8B-str');
gettext('8-bytes memory, initilized with a string');
gettext('## Test Memory-8B-str\n\nThe 8-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-8B');
gettext('8 Bytes Synchronous memory');
gettext('## Test Memory-8B\n\nThe 8-bytes memory is dumped initially or  \nwhen the button is pressed');
gettext('test-memory-128B');
gettext('test-memory-128B-str');
gettext('test-memory-16B');
gettext('test-memory-16B-str');
gettext('test-memory-256B');
gettext('test-memory-256B-str');
gettext('test-memory-2B');
gettext('test-memory-2B-str');
gettext('test-memory-32B');
gettext('test-memory-32B-str');
gettext('test-memory-4B');
gettext('test-memory-4B-str');
gettext('test-memory-64B');
gettext('test-memory-64B-str');
gettext('test-memory-8B');
gettext('test-memory-8B-str');
gettext('Stepper');
gettext('Serial_stepper_full');
gettext('### Shutdown:\nWith a 0 the motor is always active.\nA 1 only activates the motor while it is moving and after a while the motor turns off.');
gettext('Info: https://groups.google.com/g/fpga-wars-explorando-el-lado-libre/c/v-gzvkIyNoI/m/vXaLzsmGAQAJ');
gettext('Simple_Serial_Stepper');
gettext('SmoothStepper');
gettext('Absolute position control for stepper motors through the serial port. 16bits. With homing, shutdown and smooth speed control.');
gettext('Stepper motor control with shutdown.');
gettext('Comparison of stepper motor position with desired position. 16 bits. With homing, shutdown and smooth speed control.');
gettext('Counter Bidirectional, 16 bits.');
gettext('Repeat 'n' numbers of times the time set to the constant 'us'');
gettext('Frecuencia programable.');
gettext('Corazón de bombeo de tics a un frecuencia parametrica en Hz');
gettext('8 bits start and end of speed control.');
gettext('Divide by 2.');
gettext('Separador de bus de 16-bits en buses de 8 bits');
gettext('Separador de bus de 4-bits en bus de 3 bits y cable');
gettext('Agregador de buses de 1 y 3-bits a a bus de 4-bits');
gettext('Comparador de 2 operando de 16 bits.');
gettext('Sumador de un operando de 16 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Extractor de 1 bit de un bus de 16 bits');
gettext('The maximum output is 255. If it were greater it would remain at 255.');
gettext('15-bit Bidirectional counter and limited at the ends.');
gettext('Resta b-a y sale el valor absoluto de esa resta. 16 bits.');
gettext('Retrasa la señal de entrada 3 ciclos de reloj.');
gettext('Initial tic.');
gettext('Motor with activity');
gettext('Time between one step and the next.');
gettext('The brain of the beast!');
gettext('Translator of pulses and direction in signals for the motor coils.');
gettext('The tables below are different settings to create the smooth movement. R500 is the shortest \"smooth\" and R3000 is the longest. Choose the one that best suits your project.');
gettext('### home:\n* With a \"tic\" the motor will move backwards at the slowest speed.\n\n* Holding a \"1\" will move at the fastest speed while this pin is at 1. This function is for setting the maximum speed.\n\n* By giving a \"tic\" or a 1 on the \"reset\" pin the motor will stop.');
gettext('### rst:\n* Resets the motor position. When the motor does \"homing\" it will serve as detection of point 0. It can also serve (with an OR door) as \"emergency stop\".\n');
gettext('### shtdw:\n* If this pin is kept at \"1\" after a configurable time, once the motor stops and that time elapses the motor will no longer be magnetized. With a \"0\" the motor will always be active.');
gettext('Info: https://groups.google.com/forum/#!topic/fpga-wars-explorando-el-lado-libre/6N8tBEX9ucQ');
gettext('### 16 bits Bidirectional Counter');
gettext('l = a < b');
gettext('### Bidirectional 15-bit counter and limited at the ends.');
gettext('When it reaches 32767, if it receives another pulse to increase, it will not increase, it will stay at 32767.\r\n\r\nWhen it reaches 0, if it receives another pulse to decrease, it will not decrease, it will stay at 0.');
gettext('**Retrasa la señal de entrada varios ciclos de reloj.**');
gettext('Serial_stepper_full');
gettext('Simple_Serial_Stepper');
gettext('SmoothStepper');
gettext('01-Brillo-LED-pulsador-2bits');
gettext('Counter-x02: 2-bits counter');
gettext('Inc1-2bit: Increment a 2-bits number by one');
gettext('AdderK-2bit: Adder of 2-bit operand and 2-bit constant');
gettext('Adder-2bits: Adder of two operands of 2 bits');
gettext('Bus2-Join-all: Joint two wires into a 2-bits Bus');
gettext('**Valor de la anchura**  \n');
gettext('## Ejemplo 1. PWM: Cuatro niveles de Brillo en LED, con pulsador\n\nGeneración de una **señal PWM** de **4 niveles**: 0, 25%, 50%, 75% a frecuencia máxima (sin prescalado)  \nCon el pulsador se cambia de un nivel a otro, y se vuelve al comienzo. El nivel actual se muestra  \nen los LEDs 1 y 0\n\nEl contador principal es de **4 bits**, por lo que la **frecuencia** del PWM es de **3MHz**');
gettext('**Incrementar brillo**');
gettext('**Nivel actual**');
gettext('Mostrar el nivel en  \nlos LEDs (en binario)');
gettext('**Unidad de PWM**');
gettext('Incrementar contador con  \ncada pulsación');
gettext('Usar el tic del pulsador  \npara establecer el nuevo nivel  \n(en el siguiente ciclo de reloj)');
gettext('## Montaje\n\n![Esquema del montaje](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-02.png)');
gettext('\n* **Nivel 1**: \n  * 100 muestras\n  * Freq. muestreo: 24MHz\n  * \n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-03.png)');
gettext('## Mediciones\n');
gettext('* **Todos lo niveles**, medidos por separado y agrupados  \ny agrupados en una única figura\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-04.png)');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=SfixjIhfQ2c)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/SfixjIhfQ2c/0.jpg)](https://www.youtube.com/watch?v=SfixjIhfQ2c)');
gettext('02-Brillo-LED-pulsadores-4bits');
gettext('Contador ascendente/descendente de 4 bits');
gettext('**16 Niveles:**  \n**0**: No hay PWM  \n**15**: 93.75%  \n');
gettext('## Ejemplo 2. PWM: 16 niveles de brillo en LED, con prescalado\n\nSeñal **PWM de 16** niveles: 0, 6.2% ... 93.75% y frecuencia de **91.5 Hz**  \n(Prescalado de 13 bits) para controlar el brillo de un LED con **dos pulsadores**,  \nuno para incrementar el brillo y otro para disminuirlo. El nivel de brillo actual  \nse muestra en los **LEDs 3-0** (4 bits). El LED controlado es el **LED 7**');
gettext('**Decrementar brillo**');
gettext('Contador con  \nincremento/decremento');
gettext('Introducir como parámetro  \nlos bits de prescalado');
gettext('## Montaje\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT1-PWM-LED/ej4-06.png)');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=FaMuqZrrD1Y)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/FaMuqZrrD1Y/0.jpg)](https://www.youtube.com/watch?v=FaMuqZrrD1Y)');
gettext('## Mediciones\n\n');
gettext('* **Medición niveles 4, 10 y 15**: Se han tomado por separado y juntado en esta figura\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-07.png)');
gettext('* **Medición nivel 1:** (PWM 6.25%): 2M muestras. Frecuencia muestreo: 24MHz \n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-06.png)');
gettext('03-Brillo-LEDs-pot-8bits');
gettext('Valor constante 0 para bus de 2 bits');
gettext('**Frecuencia de lectura**  \n**del potenciómetro**');
gettext('## Ejemplo 3: 256 niveles de brillo en LEDs, con potenciómetro\n\nSe usa una unidad PWM de 46.9KHz y 8bits para variar la intesidad de los  \n8 LEDs de la Icezim Alhambra a la vez. Hay 256 niveles de intesidad');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=ln9it85tJiM)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ln9it85tJiM/0.jpg)](https://www.youtube.com/watch?v=ln9it85tJiM)');
gettext('**Para medir**');
gettext('## Mediciones');
gettext('* **Medición nivel 1**: (PWM 0.39%): 5K muestras. Frecuencia muestreo: 24MHz \n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-10.png)');
gettext('* **Medición de tres anchuras**: Se han medido por separado y juntado en esta figura\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-11.png)');
gettext('## Montaje\n\n* **Elementos**: **Potenciómetro** y **analizador lógico** para hacer las medicicones\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT1-PWM-LED/bloque-ej-09.png)');
gettext('04-Brillo-LEDs-serial-8bits');
gettext('**Receptor serie**\n');
gettext('Valor del brillo  \n(0-255)');
gettext('## Ejemplo 4: Servidor hardware de 256 niveles de brillo en LEDs\n\nEjemplo de control del brillo de los 8 LEDs (a la vez) con una unidad  \nde PWM de 46.8Hz a través del puero serie. El valor recibido (0-255)  \ndetermina el nivel de intensidad de brillo.');
gettext('[Vídeo de funcionamiento en youtube](https://www.youtube.com/watch?v=Im8lueRn09U)\n\n[![Click to see the youtube video](http://img.youtube.com/vi/Im8lueRn09U/0.jpg)](https://www.youtube.com/watch?v=Im8lueRn09U)');
gettext('01-Brillo-LED-pulsador-2bits');
gettext('02-Brillo-LED-pulsadores-4bits');
gettext('03-Brillo-LEDs-pot-8bits');
gettext('04-Brillo-LEDs-serial-8bits');
gettext('02-pin-entrada-test-2');
gettext('InOut:  Input-Output block');
gettext('Pin de entrada  \n(Configurado manualmente)');
gettext('**Bloque InOut**');
gettext('Configurar  \ncomo entrada');
gettext('Entrada dout  \nno conectada');
gettext('## Ejemplo: Configuración manual de un pin de entrada\n\nEjemplo de uso del bloque InOut para configurar manualmente el pin D13  \ncomo entrada. El ejemplo simplemente captura un 1 en un biestable y  \nlo muestra en LED0 cuando se aprieta un pulsador externo conectado a D13');
gettext('04-pin-salida-test-2');
gettext('Pin de salida  \n(Configurado manualmente)');
gettext('**LED Externo**');
gettext('No usado');
gettext('Habilitar salida');
gettext('Los bits del corazón  \nsalen por D13');
gettext('**Bloque InOut-right**');
gettext('## Ejemplo: Configuración manual de un pin de salida\n\nEjemplo de uso del bloque InOut para configurar manualmente el pin D13  \ncomo salida. El ejemplo hace parpadear un LED externo conectado a  \nD13');
gettext('05-inout-test-02');
gettext('Simplified-Heart-Hz-sys-32bits: periodic signal in Hertz. 50% of duty cycle');
gettext('## Ejemplo: Configuración de un pin para entrada/salida\n\nEl pin D13 se configura como entrada o salida mediante un interruptor  \nexterno. Cuando se configura como salida se emite una señal cuadrada  \npara hacer parpadear un LED externo. Cuando se configur como entrada  \nse emite un pulso al apretar el pulsador y se enciende el LED7');
gettext('Circuito de  \nsalida');
gettext('Configuración manual  \ndel pin de entrada/salida  \nmediante un switch externo  \n**0**: Entrada  \n**1**: Salida');
gettext('Circuito de entrada');
gettext('**Pin de entrada/Salida**');
gettext('LED interno para comprobar  \nque la entrada funciona');
gettext('06-inout-test-03');
gettext('## Ejemplo: Configuración de un pin para entrada/salida. Versión 2\n\nEl pin D13 se configura como entrada o salida mediante un interruptor  \nexterno. Cuando se configura como salida se emite una señal cuadrada  \npara hacer parpadear un LED externo. Cuando se configur como entrada  \nse emite un pulso al apretar el pulsador y se enciende el LED7  \n\nCuando el pin está configurado como salida, al circuito de entrada  \nle llega un 0');
gettext('Cuando es un pin de salida  \nse deshabilita la entrada');
gettext('Si el pin es de salida,  \nal circuito de entrada  \nle llega siempre 0  \nSi el pin es de entrada  \nllega lo que haya por  \nla entrada');
gettext('07-inout-dos-circuitos');
gettext('## Ejemplo: Pin bidireccional entre dos circuitos\n\nComunicación entre dos circuitos usando un cable externo.  \nMediante un interruptor externo se configura el sentido de  \nla comunicación: del circuito 1 al 2 ó del 2 al 1\n\n');
gettext('### CIRCUITO 1  \n\nSegún la configuración del pin D13:\n\n**Entrada**: Saca por LED7 lo recibido  \n**Salida**: Envía señal de 10Hz por pin\n');
gettext('### CIRCUITO 2  \n\nSegún la configuración del pin D0:\n\n**Entrada**: Saca por LED0 lo recibido  \n**Salida**: Envía señal de 4Hz por pin\n');
gettext('**Establecer sentido**  \n**de la comunicación**  \n1: Circuito 1 ---> Circuito 2  \n0: Circuito 2 ---> Circuito 1  ');
gettext('02-pin-entrada-test-2');
gettext('04-pin-salida-test-2');
gettext('05-inout-test-02');
gettext('06-inout-test-03');
gettext('07-inout-dos-circuitos');
gettext('Tres-clicks');
gettext('Detect different clicks on the button: normal click, doble click or long click');
gettext('Pulsador con tic de cambio, pulsación y liberación de tecla');
gettext('Test if a tic is received within time');
gettext('Timer in ms, with start and stop');
gettext('Contador módulo M, ascendente, de 12 bits, con reset ');
gettext('Cambiar de estado el LED  \nal hacer \"click\" en el pulsador');
gettext('Cambiar de estado el LED  \nal hacer \"doble click\" en el pulsador');
gettext('Cambiar de estado el LED  \nal dejar apretado el pulsador  \nmás de 1 segundo');
gettext('Tiempo máximo para considerarlo  \nuna doble click');
gettext('Tiempo mínimo para considerarlo  \nuna pulsación larga  \n(hay que sumarle el tiempo  \ndel doble click)');
gettext('## Pulsador: Ejemplo de 3 clicks diferentes  \n\nSegún el tipo de click empleado, se cambia de estado  \nel led correspondiente: 0, 4 ó 7\n\n* Click normal\n* Doble click  \n* Pulsación larga');
gettext('## Button-click-3  \n\nDetect three different types of clicks in the Button:\n\n* Normal click  \n* Doble click  \n* Long click');
gettext('When the button is pressed  \nthe timer 1 is started');
gettext('If the button is pressed again  \nwithin the time, it is  \na doble click');
gettext('Timeout: It was  \nnot a doble click');
gettext('Check the current  \nbutton state: pressed  \nor not pressed');
gettext('Button state');
gettext('Button state:  \n1: Pressed  \n2: Not pressed');
gettext('Button is released:  \nwe have a click  \nIt is NOT a long click');
gettext('Button is still  \npressed: we do not know yet  \nif it is a click or long click');
gettext('Timeout for detecting a \ndoble click  \nAfter this time is not considered a  \ndoble click but two clicks in a row');
gettext('Wait for the release  \ntic');
gettext('Release tic has arrived  \nwithin time: it was a  \nnormal click  ');
gettext('In both cases it is  \nconsider a normal click');
gettext('The button has not been  \nreleased after the specified  \ntime: it is a long click');
gettext('**Outputs**');
gettext('## Timeout-ms\n\nWhen the machine is active, it detects if  \nan input tic arrive within the specified time  \nIf so, another tic is sent to done. If no tic is  \nreceived within time (timeout), a tic is sent  \nto tout');
gettext('Start the machine');
gettext('Tic to detect within time');
gettext('Main timer');
gettext('Start the timer');
gettext('If a tic is received when  \nthe timer is still on,  \nlet it pass...');
gettext('The tic is delayed one unit  \nto prevent reache the timer  \nin the same cycle than start  \n(it can happens if the same tic is  \nconnect both to start and tic inputs)  ');
gettext('Stop the timer:  the tic  \nhas arrived in time');
gettext('The tic arrived in time  \nTic detected!');
gettext('No tic detected  \nwithin time');
gettext('The machine is on');
gettext('tic: No input tic detected');
gettext('tic: input tic detected!');
gettext('Biestable de estado  \nde la máquina');
gettext('Mientras la máquina  \nesté apagada el  \ncontador está a 0');
gettext('Contador de tiempo  \nen unidades de  \nmilisegundos');
gettext('El tiempo ha expirado:  \napagar la máquina');
gettext('Unidades de tiempo:  \n1000 microsec = 1ms');
gettext('Al arrancar la máquina,  \neste corazón emite un  \ntic cada 1 ms');
gettext('**Parámetro**:  \nms de espera');
gettext('Sacar el tic de apagado de  \nla máquina por abort o done  \nsegún cómo haya sido');
gettext('Si es por stop: El timer ha abortado  \nSi no, es una terminación normal (timeout)');
gettext('cherry-test-1');
gettext('Cherry switch');
gettext('Serial Debugger for printing one bit + new line');
gettext('Print a bit plus a new line');
gettext(' Transmit one bit as a character. STDOUT-bus');
gettext('## Cherry-switch Test\n\nThe key state is shown in the LED  \nWhen the key is pressed, a '1' character  \n(plus a \\n) is sent to the serial port  ');
gettext('The console can be seen directly in the Web Browser  \nin this link:\n\n[Web Terminal](https://obijuan.github.io/FPGA-WEB-Serial/WebTerm/index.html)');
gettext('Convert to positive  \nlogic:  \n1: Button pressed  \n0: Button released');
gettext('Syncronize  \n(Avoid Metastability)');
gettext('**De-bouncing**');
gettext('**Button state**');
gettext('**Button tic**');
gettext('Rising edge  \ndetector');
gettext('Bit to be transmited');
gettext('Transmit now! (tic)  \nActivate the machine');
gettext('## Debugger-PrintLn-Bit\n\nPrint a bit on the console, followed by a new  \nline character');
gettext('## PrintLn-bit: Print one bit plus a new line character  \n');
gettext('**Block 1**  \nPrint the bit (0,1)');
gettext('The machine is busy either  \nthe block 1 is busy or  \nthe block 2 is busy');
gettext('**Block 2**  \nPrint new line char');
gettext('## PUTC-bit-stdout: Transmit one bit (STDOUT bus)  \n\nWhen activated, the bit input is sent as the character '0' or '1'  \nWhen not active, the stdout crossed the block (transparent mode)');
gettext('The bit to be transmitted should be  \nsyncronized with its transmit tic');
gettext('If the machine is ready and  \nthe next tic is received:  \nwe are done');
gettext('The machine is done');
gettext('Machine is on: send a character');
gettext('State of the machine  \n0: OFF  \n1: ON: Sending one character');
gettext('Character to transmit when  \nthe input bit is 1');
gettext('Character to transmit when  \nthe input bit is 0');
gettext('Select with character to transmit  \naccording to the input bit');
gettext('Tres-clicks');
gettext('cherry-test-1');
gettext('16bits');
gettext('SPI-master');
gettext('SPI-slave');
gettext('SerialSPI16master');
gettext('Convierte 2 bytes del puerto serie en una palabra de 16 bits para el SPI master de 16 bits.');
gettext('Agregador de 2 buses de 8-bits a bus de 16-bits');
gettext('Cuenta dos pulsos.');
gettext('Dos memorias tipo D (de 8 bits cada una) están puestas como registro de\ndesplazamiento. Cada vez que reciba un byte del puerto serie se memorizará\ny el contenido de la anterior pasa a la siguiente. Cada dos bytes recibidos\nformará una palabra de 16 bits.\n');
gettext('SPI Master 16 bits.');
gettext('SerialSPI16master');
gettext('Icestick');
gettext('Icezum-alhambra');
gettext('01-2-spi-master-constant');
gettext('### Ejemplo 1-2: Enviando una constante por SPI al esclavo\n\nEjemplo de envío de un dato desde el maestro al esclavo. Al apretar el  \npulsador se envía la constante por el spi. Tanto el maestro como el  \nesclavo se encuentra en la misma FPGA, pero son circuitos independientes');
gettext('**Bloque**  \n**spi-master-mode0-2MHz**');
gettext('# MAESTRO');
gettext('# ESCLAVO');
gettext('<-- Cable externo -->');
gettext('<-- Cable externo');
gettext('Cable externo-->');
gettext('### Cables externos necesarios: 4\n\n| Señal SPI | Pin Maestro | Pin Esclavo | Descripción |\n|-----------|-------------|-------------|-------------|\n|  SCLK     |  D13        |   D3        | Reloj       |\n|  MISO     |  D12        |   D2        | Datos Esclavo --> Maestro |\n|  MOSI     |  D11        |   D1        | Datos Maestro --> Esclavo |\n|  SS       |  D10        |   D0        | Selección de esclavo      |');
gettext('02-spi-master-lectura-id');
gettext('### Ejemplo 2: Enviando una constante por SPI al esclavo\n\nEjemplo de recepción de datos desde el esclavo al maestro. Se realiza la  \nlectura del esclavo cada 100ms. Devuelve el identificador (0xA5)  \n, que el maestro captura en un registro y lo saca por los leds  \nComo es un valor constante, no se aprecia cambio en los LEDs  \n(pero al conectar el analizador se observa el trasiego de datos)\n');
gettext('**Registro**');
gettext('Identificador que  \nse envía al maestro');
gettext('03-spi-master-lectura-escritura');
gettext('## Ejemplo 3: Envío y recepción por el SPI\n\nCada 100ms se realiza una transacción: Se lee el identificador  \ndel periférico del SPI (valor constante 0xA5) y se envía el valor  \nde un contador que se incrementa también cada 100ms\n\nPor los LEDs vemos los valores del contaddor recibidos en el esclavo,  \n(al apretar el botón 1), o bien el identificador recibido en el  \nmaestro (apretar botón 2).\n');
gettext('# MAESTRO\n\nCada 100ms se envía el valor del contador al  \nesclavo y se incrementa');
gettext('Mostrar por los LEDs bien los datos  \nrecibidos por el esclavo (pulsador 1) o  \nbien los datos recibidos por el maestro  \n(pulsador 2)');
gettext('Ver el maestro');
gettext('Ver el esclavo');
gettext('Se realiza una transacción  \ncada 100ms');
gettext('04-spi-master-medidas');
gettext('## Ejemplo 4: Medidas\n\nCircuito para realizar medidas del SPI con el analizador lógico  \nLos 4 primeros canales se conectan a D0, D1, D2 y D3 para mostrar las  \nseñales SS, MOSI, MISO y SCLK\n\nSe usan dos canales adicionales conectados a D4 y D5 para mostrar las  \nseñales de busy y done');
gettext('# MAESTRO\n\nSe envían los valores 0xAA y 0x55 alternativamente  \nal esclavo, para que los muestre en sus LEDs');
gettext('Se realiza una transacción  \ncada 300ms');
gettext('05-2-serial-spi-echo');
gettext('## Ejemplo 5-2: Serial-spi: Prueba de eco y LEDs, con el bloque serial-SPI\n\nPasarela Serie-SPI. Todo lo recibido desde el PC por el puerto serie  \nse envía hacia el SPI, y todo lo recibido del SPI se envía hacia  \nel PC por el puerto serie\n');
gettext('# MAESTRO\n');
gettext('06-serial-spi-cmd');
gettext('## Ejemplo 6: Serial-spi: Prueba de comandos, con el bloque serial-SPI\n\nPasarela Serie-SPI. Todo lo recibido desde el PC por el puerto serie  \nse envía hacia el SPI, y todo lo recibido del SPI se envía hacia  \nel PC por el puerto serie\n');
gettext('07-serial-spi-regs');
gettext('## Ejemplo 7: Serial-spi: Prueba de registros, con el bloque serial-SPI\n\nPasarela Serie-SPI. Todo lo recibido desde el PC por el puerto serie  \nse envía hacia el SPI, y todo lo recibido del SPI se envía hacia  \nel PC por el puerto serie\n');
gettext('08-1-serial-spi-flash-memory');
gettext('## Ejemplo 8-1: Acceso a la memoria flash SPI\n\nEjemplo de prueba de la memoria flash SPI desde la placa **Alhambra II**.  \nUsamos el bloque serial-spi para enviar los comandos desde el PC y  \ncomprobar su funcionamiento\n\n');
gettext('09-serial-spi-cap1188');
gettext('## Ejemplo 9: Pruebas del sensor capacitivo CAP1188 desde el PC\n\nUsamos el bloque Serial-SPI como maestro para envair comandos desde el PC  \nal esclavo CAP1188 situado fuera de la placa, conectado por los pines  \ndel SPI\n\n\n');
gettext('08-3-serial-spi-flash-memory-Icestick');
gettext('## Ejemplo 8-2: Acceso a la memoria flash SPI\n\nEjemplo de prueba de la memoria flash SPI desde la placa **Icezum Alhambra**.  \nUsamos el bloque serial-spi para enviar los comandos desde el PC y  \ncomprobar su funcionamiento\n\n');
gettext('08-3-serial-spi-flash-memory-Icestick');
gettext('08-2-serial-spi-flash-memory-Icezum-Alhambra');
gettext('08-2-serial-spi-flash-memory-Icezum-Alhambra');
gettext('01-2-spi-master-constant');
gettext('02-spi-master-lectura-id');
gettext('03-spi-master-lectura-escritura');
gettext('04-spi-master-medidas');
gettext('05-2-serial-spi-echo');
gettext('06-serial-spi-cmd');
gettext('07-serial-spi-regs');
gettext('08-1-serial-spi-flash-memory');
gettext('09-serial-spi-cap1188');
gettext('SPI-test');
gettext('icezum-Alhambra');
gettext('01-SPI-LEDs-mode0');
gettext('### Ejemplo 1: Mostrando en los LEDs el dato recibido\n\nEjemplo de un circuito esclavo por SPI, que simplemente saca por los  \nLEDs los bytes recibidos');
gettext('02-SPI-LEDs-regs');
gettext('Transición gradual de brillo entre dos números de 8 bits');
gettext('### Ejemplo 2: Registrando el dato recibido\n\nEjemplo de un circuito esclavo por SPI, que almacena el dato recibido  \nen un registro. Además se saca por los LEDs usando un efecto de  \ntransición suave');
gettext('Se carga con el dato recibido  \nusando el tic rcv');
gettext('**Brillo gradual**');
gettext('03-SPI-Pulsadores');
gettext('### Ejemplo 3: Transmitiendo al maestro\n\nEl estado de los pulsadores SW1 y SW2 se envía al maestro. Se sitúan  \nen los dos bits de menor peso del byte enviado. El resto de bits se  \nponen a 0');
gettext('Comienza una transacción  \nnueva');
gettext('Cargar el byte a enviar  \ncada vez que hay una  \ntransacción nueva');
gettext('Flanco de bajada');
gettext('04-SPI-send-receive');
gettext('### Ejemplo 4: Envío y recepción\n\nLos bytes recibidos del maestro se muestran por los LEDs  \nCada dato recibido se incrementa en 1 y se devuelve como  \nrespuesta en la siguiente transacción\n');
gettext('Dato recibido');
gettext('Dato recibido  \nincrementado');
gettext('El dato incrementado  \nse carga cuando ha  \nterminar la transacción  \nactual');
gettext('06-2-SPI-WRITE-LEDs');
gettext('### Ejemplo 6-2: Comando WRITE_LEDS\n\nImplementación del comando WRITE_LEDs usando el bloque sintáctico  \ncmd8-value8, que detecta el patron de código del comando write_leds y  \nsu valor');
gettext('**Registro LEDs**  \nContiene el valor que  \nse muestra en los LEDs');
gettext('**Comando**  \n**WRITE_LEDS**');
gettext('Valor recibido tras  \nel código de comando');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |');
gettext('**Bloque cmd8**');
gettext('07-2-SPI-WRITE-Brillo-LEDs');
gettext('### Ejemplo 7: Comandos WRITE_LEDs y Brillo-LEDs\n\nPeriférico por el SPI con dos comandos: WRITE_LEDS para escribir un  \nvalor por los LEDs y BRILLO_LEDS para establecer su brillo. Ambos  \ncomandos se han implementado con el bloque sintáctico cmd8\n');
gettext('**Brillo-8**');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **BRILLO_LEDS** *val* | 0x50       | Establecer el brillo de los LEDs   |');
gettext('### Comando BRILLO_LEDS');
gettext('Valor inicial para  \nel brillo: máximo');
gettext('**Registro**  \n**de Brillo**  ');
gettext('09-SPI-READ_buttons');
gettext('### Ejemplo 9: Comando READ_Buttons\n\nImplementación de 3 comandos: Dos para escribir en los LEDs y  \nmodificar su brillo. Un tercero para leer el estado de los pulsadores');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **BRILLO_LEDS** *val* | 0x50       | Establecer el brillo de los LEDs   |\n| **READ_BUTTONS**      | 0x60       | Lectura de los pulsadores          |');
gettext('10-SPI-READ_ID');
gettext('### Ejemplo 10: Comando READ_ID\n\nImplementación de 4 comandos: Dos de escritura, y dos de lectura');
gettext('| Comando | Código comando | Descripción |\n|---------|----------------|-------------|\n| **WRITE_LEDS** *val* |  0x40       | Sacar el número *val* por los LEDs |\n| **BRILLO_LEDS** *val* | 0x50       | Establecer el brillo de los LEDs   |\n| **READ_BUTTONS**      | 0x60       | Lectura de los pulsadores          |\n| **READ_ID**           | 0x70       | Lectura del identificador del chip |');
gettext('### Comando READ_ID');
gettext('Tic de lectura del  \nidentificador del chip');
gettext('**codificador**  \n2 a 1');
gettext('Se activa cuando se ha activado  \nalguno de los dos comandos');
gettext('Código del esclavo');
gettext('Número correspondiente al  \ncomando de lectura recibido:  \n0: READ_ID  \n1: READ_BUTTONs  ');
gettext('11-3-SPI-REG-LEDs');
gettext('# Ejemplo 11-3: Registro de LEDs con bloque reg-addr\n\nPeriférico para el SPI que tiene mapeado un registro de LEDs, de lectura y escritura. \nSe accede al registro a través de la dirección 0x10, que se debe depositar primero en el  \nregistro de dirección con el comando SAP');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |');
gettext('**Lectura del registro**:  \nSi está su dirección en el registro  \nde dirección, se devuelve su valor  \nde lo contrario se devuelve 0');
gettext('Valor a enviar al maestro  \nen la lectura');
gettext('Registro de LEDS  \nseleccioando');
gettext('12-serial-reg-LEDs');
gettext('# Ejemplo 12: Registro de LEDs por puerto serie\n\nEl registro de LEDs está mapeado en memoria, y es accesible a través de los comandos SAP,  \nWrite y RD recibidos por el puerto serie\n\n');
gettext('## COMANDOS\n\n| Comando | Abrev. | Código | Descripción |\n|---------|-------------|----------------|-------------|\n| **SET ADDRES POINTER ** *val* | SAP  | \"S\"       | Establecer el valor del registro de dirección |\n| **WRITE REGISTER** *val*      | WR   | \"W\"       | Escribir en el registro apuntado por el registro de dirección |\n| **READ REGISTER**             | RD   | \"R\"       | Leer el registro apuntado por el registro de dirección |\n\n');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| \"1\"  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |');
gettext('**Lectura del registro**:  \nSi está su dirección en el registro  \nde dirección, se devuelve su valor  \nde lo contrario se devuelve el  \ncarácter \"-\"');
gettext('**Receptor serie**');
gettext('**BUS de**  \n**Direcciones**');
gettext('**BUS de**  \n**Datos**');
gettext('**BUS de**  \n**control**');
gettext('**Bus de datos**  \n**de salida**');
gettext('13-SPI-dos-registros-mapeados');
gettext('# Ejemplo 13: Dos registros mapeados\n\nPeriférico SPI que tiene mapeados dos registros: uno para escribir en los LEDs y otro para cambiar  \nel nivel de brillo. Ambos registros son de lectura y escritura');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| 11h  | R/W   |  BRILLO  | Nivel de brillo de los LEDs | 255 |\n');
gettext('Se pone a 1 cuando NO hay  \nningún registro seleccionado');
gettext('### Registro de BRILLO');
gettext('**Bloque Brillo**');
gettext('Codificador  \nde 2 a 1');
gettext('14-SPI-cuatro-registros-mapeados');
gettext('# Ejemplo 14: Cuatro registros mapeados\n\nPeriférico SPI que tiene mapeados cuatro registros: Dos de lectura/escritura para establecer  \nel valor de los LEDs y su brillo. Y dos de sólo lectura. Uno con el identificador del  \nperiférico y otro con el valor de los pusaldores');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| 11h  | R/W   |  BRILLO  | Nivel de brillo de los LEDs | 255 |\n| 12h  | R     |  PULSADORES | Estado de los pulsadores SW1 y SW2 | 00h |\n| FDh  | R     |  ID | Código de identificación del periférico | 50h |\n');
gettext('15-Serial-cuatro-registros-mapeados');
gettext('# Ejemplo 15: Cuatro registros mapeados. Puerto serie\n\nPeriférico por puerto serie que tiene mapeados cuatro registros: Dos de lectura/escritura para establecer  \nel valor de los LEDs y su brillo. Y dos de sólo lectura. Uno con el identificador del  \nperiférico y otro con el valor de los pusaldores');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| \"1\"  | R/W   |  LEDs    |  Valor mostrado en los LEDs | 00h |\n| \"2\"  | R/W   |  BRILLO  | Nivel de brillo de los LEDs | 255 |\n| \"3\"  | R     |  PULSADORES | Estado de los pulsadores SW1 y SW2 | \"0\" |\n| \"I\"  | R     |  ID | Código de identificación del periférico | \"A\" |\n');
gettext('Construir el byte a transmitir  \nal maestro: 001100xx  \nLos dos de menos peso son\nSW1 y SW2 ');
gettext('16-SPI-mini-VGA');
gettext('Separador de bus de 8-bits en 1 buses de 6 bits y dos cables sueltos');
gettext('**HS**');
gettext('**VS**');
gettext('**Conexión con AP-VGA**');
gettext('**Sincronismo**');
gettext('## Ejemplo 16: Mini-controlador VGA por SPI\n\nEste periférico tiene mapeado un único registro:  \nVGALEDs. Sus dos bits de menor peso representan la  \nmitad izquierda y derecha de la pantalla de la VGA');
gettext('**VGALEDs**');
gettext('## REGISTROS\n\n| Dir. |  R/W  |  Nombre  |  Función  | Valor por defecto |\n|------|-------|----------|-----------|-------------------|\n| 10h  | R/W   |  VGALED |  Estado de las dos mitades de la pantalla VGA | 03h |');
gettext('### Registro VGALED');
gettext('00-1-spi-slave-test-id');
gettext('# Ejemplo 0-1: Probando el bloque spi-slave-test-id\n\nTodo lo recibido por el spi se saca por los LEDs. En cada transacción se  \ndevuelve el valor constante 0xA5  ');
gettext('### Código de prueba para Arduino');
gettext('00-2-spi-slave-test-eco');
gettext('# Ejemplo 0-2: Probando el bloque spi-slave-test-echo\n\nTodo lo recibido por el spi se saca por los LEDs y se almacena para  \nenviarlo de vuelta en la siguiente transacción (eco)  ');
gettext('00-3-spi-slave-test-cmd');
gettext('# Ejemplo 0-3: Probando el bloque spi-slave-test-cmd\n\nCon el comando Write_LED se saca un valor en los leds.  Con el comando Read_buttons  \nse devuelve el estado de los pulsadores');
gettext('Con los parámetros se establecen los códigos  \nde los comandos. Por defecto son 0x40 y 0x60');
gettext('00-4-spi-slave-test-regs');
gettext('# Ejemplo 0-4: Probando el bloque spi-slave-test-regs\n\nImplementa tres registros mapeados: leds, buttons e id, accesibles mediante los comandos  \nSAP, WR y RD');
gettext('Con los parámetros se establecen los códigos  \nde los comandos, sus direcciones y el ID');
gettext('00-1-spi-slave-test-id');
gettext('00-2-spi-slave-test-eco');
gettext('00-3-spi-slave-test-cmd');
gettext('00-4-spi-slave-test-regs');
gettext('01-SPI-LEDs-mode0');
gettext('02-SPI-LEDs-regs');
gettext('03-SPI-Pulsadores');
gettext('04-SPI-send-receive');
gettext('06-2-SPI-WRITE-LEDs');
gettext('07-2-SPI-WRITE-Brillo-LEDs');
gettext('09-SPI-READ_buttons');
gettext('10-SPI-READ_ID');
gettext('11-3-SPI-REG-LEDs');
gettext('12-serial-reg-LEDs');
gettext('13-SPI-dos-registros-mapeados');
gettext('14-SPI-cuatro-registros-mapeados');
gettext('15-Serial-cuatro-registros-mapeados');
gettext('16-SPI-mini-VGA');
gettext('18-SPI-Icezum-Alhambra-cuatro-registros-mapeados');
gettext('# Ejemplo 18: Icezum Alhambra: Cuatro registros mapeados\n\nPeriférico SPI que tiene mapeados cuatro registros: Dos de lectura/escritura para establecer  \nel valor de los LEDs y su brillo. Y dos de sólo lectura. Uno con el identificador del  \nperiférico y otro con el valor de los pusaldores');
gettext('18-SPI-Icezum-Alhambra-cuatro-registros-mapeados');
gettext('01-Key-test');
gettext('## Ejemplo 1\n\nLectura de una tecla aislada esando el **bloque key**  \nSe emiten dos pitidos, uno al pulsar y otro al soltar\n\n[Más información](https://github.com/Obijuan/FPGA-keyboard/wiki/Teclado-num%C3%A9rico-USB-Jelly-Comb)');
gettext('Mostrar por el LED  \nel estado de la tecla');
gettext('Pitido grave  \nPulsación');
gettext('Pitido agudo  \nLiberación');
gettext('Lectura de  \nTecla');
gettext('**Conexión de la tecla Backspace**  \nTeclado Jelly\n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-usb-26.png)');
gettext('### Escenario\n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/tecla-backspace-06.png)');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/YQmEWZz1FUs/0.jpg)](https://www.youtube.com/watch?v=YQmEWZz1FUs)');
gettext('02-Jelly-kbd-test1');
gettext('**Ejemplo 2**: Prueba del teclado matricial Jelly  \nCuando se aprieta una tecla se muestra su código de tecla en  \nlos LEDs y se emite un pitido  \nAl soltar la tecla se emite otro pitido más agudo  \nEl estado actual de la tecla (0 sin apretar, 1 pulsada)  \nse muestra en un LED externo\n\n[MÁS INFORMACIÓN](https://github.com/Obijuan/FPGA-keyboard/wiki/Teclado-num%C3%A9rico-USB-Jelly-Comb)');
gettext('Mostrar estado de la  \ntecla en el LED');
gettext('Emitir un **pitido** con la  \npulsación de cada tecla');
gettext('Emitir un **pitido** con la  \nliberación de cada tecla  \n(Pitido más agudo)');
gettext('### CONEXIONADO\n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/jelly-Alhambra-II.png)');
gettext('![](https://github.com/Obijuan/FPGA-keyboard/raw/master/wiki/jelly-keyboard/jelly-02.png)');
gettext('**C19**');
gettext('**C18**');
gettext('**C17**');
gettext('**C8**');
gettext('**C9**');
gettext('### ESCENARIO \n\n![](https://raw.githubusercontent.com/Obijuan/FPGA-keyboard/master/wiki/jelly-keyboard/key-matrix-04.png)');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ns8h2Tpm9Ns/0.jpg)](https://www.youtube.com/watch?v=ns8h2Tpm9Ns)\n');
gettext('03-Jelly-kbd-seleccion');
gettext('Separador de bus de 5-bits en 1 bit y bus de 4 bits');
gettext('Comparador menor que, de un operando de 5 bits');
gettext('Contador ascendente/descendente de 3 bits');
gettext('2-to-1 Multplexer (1-bit channels). Verilog implementation');
gettext('**Ejemplo 3**: Selección de canales  \n* Modo 1: Selección del canal apretando la tecla numérica correspondiente (NumLoc no activo)\n* Modo 2: Selección del canal mediante las flechas y la tecla ENTER (Numlock activado)');
gettext('Estado de **Numlock**:  \n0: No activado  \n1: Activado');
gettext('Sacar NumLock  \npor el LED');
gettext('Tecla 8 pulsada');
gettext('Tecla 2 pulsada');
gettext('NumLock');
gettext('Flecha  \narriba');
gettext('Flecha  \nabajo');
gettext('Contador  \nascendente/  \ndescendente');
gettext('Decodificador  \nde 3 a 8');
gettext('Numero seleccionado  \npor las flechas');
gettext('Tecla Enter');
gettext('Es Tecla 0 - 9');
gettext('Numero seleccionado  \npor tecla');
gettext('Canal seleccionado');
gettext('Pitidi agudo emitido  \nal seleccionar canal  \npor cualquier modo');
gettext('Emitir pitido grave  \nal mover alguna de las  \nflechas');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/OSDUV2FAFMs/0.jpg)](https://www.youtube.com/watch?v=OSDUV2FAFMs)');
gettext('04-Jelly-kbd-calculator');
gettext('Sumador  de 4 bits (sin acarreo)');
gettext('Suma de operandos');
gettext('Con la tecla de backspace se  \ninicializan todos los registros  \npara volver al estado inicial');
gettext('Los datos llegan  \nen serie');
gettext('Registro de  \ndato');
gettext('Registro de dato');
gettext('Resultado');
gettext('Selección de qué sacar por  \nel display: resultado u operando');
gettext('Display de 7 segmentos');
gettext('Es el primer o segundo  \ndígito tecleado');
gettext('Tecla de sumar');
gettext('Es la tercera tecla  \napretada');
gettext('Tecla valida pulsada');
gettext('Contador');
gettext('Cuando no hay teclas validas  \npulsadas se muestra el resultado');
gettext('Sonido para teclas  \nBackspace y +  \nagudo');
gettext('Sonido para teclas  \nnuméricas: grave');
gettext('La primera tecla pulsada  \no la segunda son digitos');
gettext('**Aplicación 2**: Calculadora de un dígito. Se hacen sumas de números de un dígito, en notación  \npolaca inversa. Ej: se pulsa 2, después 3 y depués +: se muestra 5 en el display  \nSólo se aceptan las teclas correctas en el momento adecuado Así, al comenzar, sólo se aceptarán dígitos  \nDespues de introducir los dos primeros dígitos, sólo se acepta la tecla +. Si se aprieta cualquier otra  \nse ignora.  \nCon la tecla backspace se hace un reset y se vuelve al estado inicial en cualquier momento');
gettext('### VIDEO 1\n\n[![Click to see the youtube video](http://img.youtube.com/vi/ia5OGJ10mm0/0.jpg)](https://www.youtube.com/watch?v=ia5OGJ10mm0)\n');
gettext('### VIDEO 2: Marcha imperial\n\n[![Click to see the youtube video](http://img.youtube.com/vi/cT7DrgvBubo/0.jpg)](https://www.youtube.com/watch?v=cT7DrgvBubo)\n');
gettext('05-Jelly-kbd-control-acceso');
gettext('Comparador de un operando de 16 bits. Se compara si el operando es igual al parámetro');
gettext('**Aplicación 4**: Control de acceso  \nCuando se introduce la contraseña correcta de 4 dígitos, se abre la  \npuerta. Con la tecla Backspace se hace reset y se vuelve a cerrar  \nCuando la puerta está abierta, las teclas se deshabilitan\n');
gettext('Es tecla 0-9  ');
gettext('Mostrar la tecla en el  \ndisplay');
gettext('Estado de la caja:  \n0: Cerrada  \n1: Abierta');
gettext('Contador de dígitos');
gettext('úLtimo digito introducido');
gettext('Clave  \ncorrecta');
gettext('Mostrar en el display  \nel último dígito que se  \npulsado');
gettext('Sonido para  \nlos dígitos');
gettext('Sonido para  \nla tecla backspace');
gettext('Dígito apretado  \ny caja cerrada');
gettext('Código de tecla  \nde 4 bits');
gettext('### VIDEO\n\n[![Click to see the youtube video](http://img.youtube.com/vi/CulgcF5UY2k/0.jpg)](https://www.youtube.com/watch?v=CulgcF5UY2k)');
gettext('06-Jelly-kbd-consola-serie');
gettext('Agregador de 2 buses de 1 y 4-bits a bus de 6-bits');
gettext('**Aplicación 5**: Consola serie  \nAl apretar las teclas se envían caracteres ASCII por el puerto  \nserie al PC. Con el numlock apretados se obtienen letras\n');
gettext('Display de 7  \nsegmentos');
gettext('Estado del NumLock');
gettext('Según la tecla pulsada y  \nel estado del Numlock se  \nobtiene de la tabla una  \nnota u otra');
gettext('Cualquier tecla apretada  \nsalvo NuLock');
gettext('Envío del carácter  \nASCII por el puerto  \nserie');
gettext('### VIDEO \n\n[![Click to see the youtube video](http://img.youtube.com/vi/xTKSQj8sTTI/0.jpg)](https://www.youtube.com/watch?v=xTKSQj8sTTI)');
gettext('01-Key-test');
gettext('02-Jelly-kbd-test1');
gettext('03-Jelly-kbd-seleccion');
gettext('04-Jelly-kbd-calculator');
gettext('05-Jelly-kbd-control-acceso');
gettext('06-Jelly-kbd-consola-serie');
gettext('01-Led-on');
gettext('### Prueba Hola-mundo\n\nComprobar que el circuito se carga  \ncorrectamente en la FPGA  \nSe enciende el LED 0');
gettext('02-Serial-eco');
gettext('Serial transmitter with a buffer for 1 byte');
gettext('1-byte buffer');
gettext('### Prueba del puerto serie\n\nSe hace ECO de todo lo recibido  \nVelocidad: 115200 baudios  \nLo recibido se saca por los LEDs también');
gettext('Empty Buffer  \n(There is no byte  \nwaiting)');
gettext('Byte stored in the  \nbuffer, waiting to be  \ntransmitted when the  \ntransmitter is ready');
gettext('Buffer state:  \n0: empty  \n1: full');
gettext('Transmitter ready');
gettext('If the transmittter is ready  \nand there is a character  \nin the buffer: Transmit!');
gettext('Serial transmitter state');
gettext('01-Led-on');
gettext('02-Serial-eco');
gettext('VGA-retro');
gettext('Icezum-Alhambra');
gettext('00-Plantilla');
gettext('HS (HORIZONTAL)  ');
gettext('## Plantilla\n\nPlantilla con los elementos necesarios para  \nempezar nuestros proyectos VGA-RETRO  \nConfigurado para la placa **AP-VGA** en una **Alhambra-II**');
gettext('01-Test-and-Adjust-VGA');
gettext('## CONEXIONADO (Alhambra-II)\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT2-VGA-Retro-I/AP-vga-08.png)');
gettext('## IMAGEN\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/test-vga-03.png)');
gettext('### FUNCIONAMIENTO\n\nPrueba en un monitor real\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT2-VGA-Retro-I/test-vga-02.png)');
gettext('## Ejemplo 1: Prueba de funcionamiento VGA\n\n* Placa Alhmabra-II con la AP-VGA\n* Conectar al monitor VGA\n* Comprobar que se la imagen correcta, con los colores correctos\n* Asegurarse de que el marco azul se ve completo');
gettext('Bloque de prueba:  \nTest-FPGAwars');
gettext('### Señales VGA');
gettext('02-Fondo-verde');
gettext('## Ejemplo 2: Fondo verde\n\nTodos los píxeles de la zona visible se activan, por lo que  \nveremos el fondo de esta zona de **color verde**. Simplemente hay  \nque conectar la salida *visible* del bloque SYNC con el **bit del  \ncanal verde**');
gettext('Mientras el haz esté en la  \nzona visible, activar los  \npixeles del canal verde');
gettext('### ESCENARIO\n\n![](https://raw.githubusercontent.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/master/wiki/CT2-VGA-Retro-I/vga-retro-09.jpg)');
gettext('03-Fondo-verde-parpadeo');
gettext('## Ejemplo 3: Fondo verde parpadeante\n\n\nHacer parpadear el fondo de la pantalla (zona visible)  \nConfiguración inicial: Parpadeo a 1Hz  \nSe usa un **biestable** para almacenar el **estado de la pantalla**:  \nencendida o apagada. Según este estado se activa o no el bit  \ndel canal verde. El estado sólo se captura cuando ha terminado  \nde dibujarse el frame actual (Freq de captura de 60Hz)');
gettext('Parpadeo de la pantalla  ');
gettext('04-MonsterLED-blink');
gettext('## Ejemplo 4: MonsterLED parpadeante \n\nHacer parpadear el MonsterLED a 2Hz');
gettext('Salida por  \nnivel');
gettext('**MonsterLED**');
gettext('05-MonsterLED-button');
gettext('Emitir un beep al recibir un tic');
gettext('## Ejemplo 5: MonsterLED con Pulsador \n\nSe usan dos pulsadores para encender el MonsterLED (y un LED externo)  \n* El pulsado2 no tiene memoria. El monsterLED estará encendido mientras esté pulsado. Al  \nsoltarlo se apagará\n* El pulsador1 tiene memoria. Al apretarlo cambia a un nuevo estado y al soltarlo lo recuerda.   \n  Para recordar está conectado a un biestable de cambio (Tipo T)  \n\nSe emite un pitido corto cada vez que se aprieta uno de los pulsadores');
gettext('Sin memoria');
gettext('Con memoria');
gettext('Biestable T  \n(de cambio)');
gettext('## Emitir un Beep con cada pulsacion');
gettext('06-MonsterLED-IR');
gettext('## Ejemplo 6: MonsterLED con Infrarrojos \n\nSe usa un sensor de infrarrojos para detectar la aproximación de un objeto  \nCuando se detecta se cambia el estado del MonsterLED  \nSi se pone delante del monitor, permite encenderlo y apagarlo \"con la fuerza\" :-)');
gettext('Sensor de  \ninfrarrojos');
gettext('Objeto  \ndetectado');
gettext('## Emitir un Beep con cada detección del IR');
gettext('08-Barra-1-ON');
gettext('## Ejemplo 8: Encender la barra 1\n\nEjemplo para poner en Verde la mitad derecha (barra 1) de la zona visible  \nLa mitad izquierda (barra 0) permanece apagada');
gettext('x[7]');
gettext('**Señal al canal verde VGA**:  \n**0**: Haz está fuera de la barra 1  \n**1**: Haz está en la barra 1\n');
gettext('09-Barra-1-boton');
gettext('## Ejemplo 9: Objeto de vídeo Barra 1\n\nLa pulsación del botón establece el estado de la parte derecha  \nde la zona visible del monitor: encendida o apaga. El efecto es que  \nen vez de la pantalla completa, como sucedía en los ejemplos anteriores  \nsólo se muestra la mitad derecha (Barra 1)');
gettext('**Estado** para el objeto  \nbarra 1:  \n**0**: No visible  \n**1**: Visible');
gettext('Haz en Barra 1 y  \nestá activado');
gettext('**Pulsador** (sin memoria)  \npara establecer el estado  \nde la barra 1');
gettext('10-Dos-Barras');
gettext('## Ejemplo 10: Dos barras independientes\n\nSe dibujan dos barras verticales, alternativamente. Inicialmente aparece  \nla barra 1, que es la mitad derecha de la zona visible. Al apretar el  \npulsador se apaga y se enciende la barra 0, que es la mitad izquierda  \nAl soltar el botón se vuelve a la situación inicial    \nLas señales de video de los dos objetos se combinan con una puerta OR\n');
gettext('## Señal video Barra 0');
gettext('## Señal video Barra 1');
gettext('## Combinar las dos barras');
gettext('11-VGALED2-Botones');
gettext('## Ejemplo 11: VGA-LEDs y pulsadores\n\nEncender y apagar los LEDs de la VGA con dos pulsadores  \nCada pulsador controla una mitad de la pantalla. Al apretarlos  \nse enciende el LED correspondiente, y al soltarlo se apaga  \n(pulsadores sin memoria)\n');
gettext('12-VGALED2-Contador');
gettext('2-to-1 Multplexer (32-bit channels). Verilog implementation');
gettext('## Ejemplo 12: Contador binario en VGA-LEDs\n\nLa salida de un contador de 2 bits se lleva a los LEDs de  \nla VGA para mostrar la cuenta en binario. Mediante un  \nswitch se selecciona la duración: 1 segundo o 1 décima  \nCon cada cuenta se emite un sonido corto');
gettext('Contador de 2 bits');
gettext('Interruptor de  \nselección');
gettext('Pitido corto,  \nde 20ms');
gettext('13-VGALED2-IR');
gettext('## Ejemplo 13: Sensores de IR en VGALEDs\n\nMostrar el estado de dos sensores de infrarrojos en los  \nVGALEDs. Se emite un pitido corto cuando se activa cada  \nuno de ellos');
gettext('14-VGALED2-Ruleta-IR');
gettext('## Ejemplo 14: Ruleta VGA: Si-NO\n\nNueva versión de la ruleta VGA. Ahora se usan las dos  \nmitades de la pantalla para encontrar la respuesta a  \nnuestras preguntas si-no. Se usa un único sensor de IR  \ncuya salida cambia de estado el biestable T que se  \nconecta al VGALED con una puerta not para que los dos  \n\"LEDs\" se activen alternativamente\n\n');
gettext('**Biestable T**');
gettext('Sólo una de las dos mitades  \nes la que está encendida');
gettext('00-Plantilla');
gettext('## Plantilla\n\nPlantilla con los elementos necesarios para  \nempezar nuestros proyectos VGA-RETRO  \nConfigurado para la placa **AP-VGA** en una **Icezum Alhambra**');
gettext('01-Test-and-Adjust-VGA');
gettext('## CONEXIONADO (Icezum Alhambra)\n\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-01.png)');
gettext('### FUNCIONAMIENTO\n\nPrueba en un monitor real\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-03.jpg)');
gettext('**HS. HORIZONTAL**  ');
gettext('**Rectángulo ROJO**');
gettext('**Marco azul**');
gettext('**Imagen Verde**');
gettext('**B0**');
gettext('**B1**');
gettext('**G0**');
gettext('**G1**');
gettext('**VS. VERTICAL**  ');
gettext('02-Fondo-verde');
gettext('### ESCENARIO\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-01.png)');
gettext('## PRUEBAS DE FUNCIONAMIENTO\n\n![](https://github.com/Obijuan/Cuadernos-tecnicos-FPGAs-libres/raw/master/wiki/CT2-VGA-Retro-I/A1-vga-retro-02.png)');
gettext('03-Fondo-verde-parpadeo');
gettext('Corazon genérico para bombear bits a la frecuencia fijada en Hz (por defecto 1Hz)');
gettext('04-MonsterLED-blink');
gettext('Agregador de buses de 2-bits a bus de 4-bits');
gettext('Si estamos en zona visible,  \nse envía el estado del  \nMonsterLED por el canal verde');
gettext('05-MonsterLED-button');
gettext('Pulsador de tics con sonido');
gettext('06-MonsterLED-IR');
gettext('08-Barra-1-ON');
gettext('hpos[7]');
gettext('visible');
gettext('09-Barra-1-boton');
gettext('Con cada pulsación del  \nbotón se emite un  \npitido  ');
gettext('10-Dos-Barras');
gettext('11-VGALED2-Botones');
gettext('12-VGALED2-Contador');
gettext('Selección de duración:  \n0: una décima de seg  \n1: Un segundo');
gettext('13-VGALED2-IR');
gettext('14-VGALED2-Ruleta-IR');
gettext('00-Plantilla');
gettext('01-Test-and-Adjust-VGA');
gettext('13-VGALED2-IR');
gettext('DHTxx');
gettext('MAX7912');
gettext('DHT11_Serial');
gettext('Muestra los datos que da el DHT11 por el puerto serie.');
gettext('Hace el checksum de 8 bits.');
gettext('8 bits flip-flop');
gettext('Retrasa 2 ciclos de reloj.');
gettext('Conversor de datos binarios a datos seriales para el DHT11.');
gettext('Código ASCII del carácter LF');
gettext('Conversor binario a ASCII.');
gettext('Une dos bytes en una salida de 10 bits. (Se pierden 5 bits.)');
gettext('space = ascii(32)');
gettext('Código ASCII del carácter %');
gettext('Código ASCII del carácter H');
gettext('Convierte una entrada de 10 bits binaria a 3 bytes ASCII.');
gettext('Contador BDC');
gettext('En la entrada de 10 bits ponemos la cantidad de pulsos que emitir.');
gettext('Máquina de contar, de 10 bits. Se introduce en el paso máximo (si N pasos, el paso máximo es N-1)');
gettext('Registro de 10 bits con entrada de reset');
gettext('Sumador de un operando de 10 bits con una constante pasada como parámetro (No hay accarreo)');
gettext('Comparador de dos operandos de 10 bits. Se compara si el operando es igual al parámetro');
gettext('Comparador de un operando de 10 bits. Se compara si el operando es igual al parámetro');
gettext('Conversor binario a ASCII de la temperatura.');
gettext('Código ASCII del carácter C');
gettext('Código ASCII del carácter A');
gettext('**Info: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg/EABhMgGiDgAJ**');
gettext('Tiempo de muestreo siempre >= 2 segundos.');
gettext('Este pin se ha de conectar al pin 2 del DHT11.');
gettext('**Para comprobar si el dato es válido hemos de sumar: h1+h0+t1+t0, si el resultado\ncoincide con el valor de chk (checksum), entonces el dato es válido, de lo contrario\nsignificaría que ha habido un error.**');
gettext('Para cumplir con las **normas de diseño síncrono** hemos de poner\nregistros en las entradas y en las salidas cuando cuando existe\nlógica combinacional en medio, en este caso son las operaciones\nsumas e igualdad.');
gettext('***Retrasa la señal varios ciclos del reloj (CLK).***');
gettext('Para el DHT11 los datos están en la entrada i1. En i0 siempre habrá ceros.\nPor esta razón se enrocan las entradas, para leer correctamente el\nvalor que queremos convertir en BCD.');
gettext('No se usa la centena, por eso aparece como un cable suelto.\nLa baja resolución de este integrado (y que sólo nos dará números enteros) sólo usa\nunidades y decenas.');
gettext('El DHT11 nos dará valores brutos donde por ejemplo, si en la entrada recibimos\nun 23, significa que eso mismo se ha de representar. Lo único que hay\nque hacer es convertir ese 23 binario a BCD y posteriormente a ASCII.');
gettext('**Conversor Binario a ASCII de 10 bits.**\n\nUn contador binario cuenta normal, pero esos mismos pulsos son compartidos por otro contador BCD. El resultado es convertir de binario a BCD.\nLo siguiente es convertir BCD a ASCII, para poder ser enviado por el puerto serie. Para ello lo único que hay que hacer es sumar 48 (es el número 0 en ASCII) a cada dígito BCD.\nEste método es lento, porque cuanto más pulsos más tiempo necesitará para la conversión, sin embargo es sencillo de comprender\ny si el tiempo de conversión no es un problema el resultado es igual de bueno que otros conversores.');
gettext('Contador BCD.');
gettext('Si hay N pasos, max = N - 1');
gettext('Para el DHT11 los datos están en la entrada i1. En i0 siempre habrá ceros.\nPor esta razón se enrocan las entradas, para leer correctamente el\nvalor que queremos convertir en BCD y luego a ASCII.');
gettext('El código ASCII de grado (º) es el 167, pero no sale\ncorrectamente cuando lo enviamos por el serial, entonces\nlo he sustituido por el asterisco (*) que es el 42.');
gettext('DHT22_MAX7912');
gettext('DHT22 se comunica con el MAX7912 y representa en el display la humedad y temperatura.');
gettext('Conversor de datos binarios procedentes del DHT22 a SPI para el MAX7912.');
gettext('Multiplexor de 8 a 1, de 16 bits.');
gettext('Registro de 3 bits con entrada de reset');
gettext('Inicializa el MAX7212 a modo displays BCD.');
gettext('Convierte una entrada de 10 bits binaria a 3 bytes BCD.');
gettext('En la entrada de 10 bits ponemos la cantidad de pulsos a emitir.');
gettext('Constante 0 BCD');
gettext('Constante BCD 8.');
gettext('Multiplexa 2 bytes');
gettext('Espacio vacío para el MAX7912.');
gettext('Cableado y configuración de datos y posición para el MAX7912.');
gettext('Posición 1 del MAX7912.');
gettext('Posición 2 del MAX7912.');
gettext('Posición 3 del MAX7912.');
gettext('Posición 4 del MAX7912.');
gettext('Posición 5 del MAX7912.');
gettext('Posición 6 del MAX7912.');
gettext('Posición 7 del MAX7912.');
gettext('Posición 8 del MAX7912.');
gettext('**INFO: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg/8r91dFi_DgAJ**');
gettext('Este pin se ha de conectar al pin 2 del DHTxx.');
gettext('El circuito inicializa el MAX7912 para prepararlo como periférico para displays. Una vez que ha inicializado, por la patilla\n\"iniTic\" saldrá un tic para avisar de que ya puede aceptar datos como un SPI convencional, pero adaptado para el MAX7912.\nEsto significa que hasta que no tengamos un tic por la salida \"iniTic\" no se debe enviar datos.');
gettext('Secuencia para configurar el MAX7912\ncomo displays de 8 dígitos. Por defecto\ntodo estará apagado.');
gettext('Maestro SPI de 16 bits en Modo 0.');
gettext('Un contador binario cuenta normal, pero esos mismos pulsos son compartidos por otros contadores BCD (uno por cada dígito).\n\nUna vez que tenemos los dígitos BCD le añadimos otros 4bits. Si estos últimos 4 bits es cero, representa\nel número de forma normal. Y si esos últimos 4 bits es un 8 significa que además del número hay de encenderse\nel punto en ese display.');
gettext('**Convierte una cifra binaria en dígitos BCD de 8 bits cada uno, con formato especial para ser representado por el MAX7912.**');
gettext('En la entrada de 10 bits ponemos la cifra que queremos convertir en pulsos y al dar un tic al \"start\" comenzará a hacerlo. En la salida \"pls\" saldrá dichos pulsos en forma de tic. Una vez terminado saldrá un tic por \"done\".');
gettext('**En este módulo cableamos los datos y las posiciones para dejarlo\npreparado para el MAX7912.**');
gettext('DHT22_Serial');
gettext('Conversor de datos binarios a datos seriales para el DH22.');
gettext('Conversor binario a Humedad DHT.');
gettext('dot = ascii(46)');
gettext('Código ASCII del carácter guión');
gettext('**INFO: https://groups.google.com/d/msg/fpga-wars-explorando-el-lado-libre/LEs77wvxBZg/X3NzhG4WDgAJ**');
gettext('Este pin se ha de conectar al pin 2 del DHT22.');
gettext('Tiempo de muestreo >= 2 segundos.');
gettext('**Conversor Binario a ASCII de 10 bits.**\n\nUn contador binario cuenta normal, pero esos mismos pulsos son compartidos por otro contador BCD. El resultado es convertir de binario a BCD.\nLo siguiente es convertir BCD a ASCII, para poder ser enviado por el puerto serie. Para ello lo único que hay que hacer es sumar 48 (es el número 0 en ASCII) a cada dígito BCD.\nEste método es lento, porque cuanto más pulsos más tiempo necesitará para la conversión, sin embargo es sencillo de comprender\ny si el tiempo de conversión no es un problema el resultado es igual de bueno que en otros conversores.');
gettext('DHT11_Serial');
gettext('SerialMAX7912');
gettext('Receptor UART de 16bits');
gettext('El circuito inicializa el MAX7912 para prepararlo como periférico para displays. Una vez que ha inicializado, por la patilla\n\"iniTic\" saldrá un tic para avisar de que ya puede aceptar datos como un SPI convencional, pero adaptado al MAX7912.\nEsto significa que hasta que no tengamos un tic por la salida \"iniTic\" no se debe enviar datos al SPI master.');
gettext('Este circuito emite un solo \"tic\" al iniciarse la FPGA.');
gettext('SerialMAX7912');
